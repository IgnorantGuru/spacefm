<html>
<head>
    <title>SpaceFM User's Manual</title>
</head>
<body>
<br><br>
<table cellspacing="0" cellpadding="10" align="center" width="80%" border=2>
<tr>
<td width="20%" valign="top">
<font size=+2>SpaceFM</font><br><br>
<a href="http://ignorantguru.github.io/spacefm/">Homepage</a><br>
<a href="https://github.com/IgnorantGuru/spacefm/tree/pkg">Downloads</a><br>
<a href="http://ignorantguru.github.io/spacefm/news.html">News</a><br>
<a href="https://github.com/IgnorantGuru/spacefm/wiki">Wiki</a><br>
<a href="https://github.com/IgnorantGuru/spacefm/issues">Report Issues</a><br>
<a href="http://ignorantguru.github.io/spacefm/spacefm-manual-en.html">User's Manual</a><br>
</td>

<td valign="top">
<font size=+3><a href="http://ignorantguru.github.io/spacefm/spacefm-manual-en.html">SpaceFM User's Manual</a></font><br><br>

<p>This manual uses your browser's default settings for fonts, font sizes, and colors.

<p><b><a name="context-help">TIP:</a></b>  For help within SpaceFM, <i>right</i>-click on a menu item and select <a href="#designmode-designmenu-help">Help</a>.  Or, highlight the menu item (hover your mouse cursor over it) and press F1.  Some dialogs also include a Help button which links to this manual.


<br><br><br><b>DISCLAIMER</b>
<br>While the authors, copyright holders, and maintainers of this software endeavour to keep all content up to date and valuable, we make no representations or warranties of any kind, express or implied, about the completeness, accuracy, reliability, suitability or availability with respect to the software or the information, communications, products, services, or related graphics for any purpose. Any reliance you place on such content is therefore strictly AT YOUR OWN RISK.<br><br><br>


<!-- @Introduction @Highlights -->
<a name="introduction-about"></a> <!-- backwards compat -->

<p>SpaceFM is a multi-panel tabbed file and desktop manager for Linux with built-in VFS, udev- or HAL-based device manager, customisable menu system, and bash integration.  SpaceFM aims to provide a stable, capable file manager with significant customisation capabilities.

<ul>
    <li><b>Flexible</b> - <i>Can appear very simple or very complex depending on configuration</i><br>
    Inspired by the simplicity and clarity of PCManFM's interface, SpaceFM's GUI aims to be simple and uncluttered, while still providing extensive capabilities for power users and flexibility in window components, behavior, and appearance.
    <ul>
	<li>Each window may contain up to four independently configured, interactive browser panels <a href="#gui-pan">*</a>
	<li>Each panel supports multiple folder tabs
	<li>Optional side panes in each panel can show Devices, Bookmarks, and a Directory Tree
	<li>How many panels you want displayed, how they are arranged and sized, what each panel contains, and what fonts and icons are used is largely up to you.  SpaceFM can be a window containing icons of a single folder's contents, or a multi-panel, tabbed arrangement of detailed file lists, devices, bookmarks, and folder trees.  <a href="http://ignorantguru.github.io/spacefm/screenshots.html">screenshots</a>
    </ul><br>

    <li><b>Feature-Rich</b> - <i>Subtle power features to improve efficiency and abilities</i><br>
    <ul>
	<li>Extensive file management features to move, copy, link, plus configurable drag-n-drop and unique clipboard functions
	<li>Find-As-You-Type search to quickly locate a file with a case-sensitive/insensitive search of filenames - just type a few letters, or use a wildcard pattern <a href="#gui-find">*</a>
	<li>System management features to safely perform convenient commands as root: edit, copy, move, and delete files and folders as root, change permissions, and create links, or run a root instance
	<li>In-program archive creation and extraction (or use an external app)
	<li>File search - flexibly search system-wide for file names, sizes, content, etc. with no daemon required
	<li>Extended Rename dialog allows not only renaming, but moving, copying, and creating links, with optional root priviledges, and allows creation of new files and folders from templates <a href="#gui-rename">*</a>
	<li>Roomy dialogs for easy editing and viewing of long filenames, paths, and commands
	<li>Extended Path Bar uses tab completion and allows entry of full bash commands with substitution <a href="#gui-pathbar">*</a>
	<li>Powerfully manage how files are opened <a href="#handlers-fil">*</a>
	<li>Sort options allow a natural sort and a case sensitive sort.  Folders in the file list may be placed before or after files, or mixed with files, and hidden files may be placed before or after regular files.
	<li>Custom date display format; binary or SI decimal file sizes and copy speeds
	<li>Easily customise window titles and program icon
    </ul><br>

    <li><b>Extensible</b> - <i>Design Mode allows you to create your own file manager</i><br>
    SpaceFM's unique extensible GUI rivals the flexibility and capabilities of the Linux command line.  Using SpaceFM and making gradual adjustments as you go, you become the designer of your own version of the file manager.
    <ul>
	<li>Almost every built-in menu and toolbar item can be renamed or hidden from view, bound to any keyboard shortcut, and given a custom icon <a href="#designmode">*</a>
	<li>Add your own custom menu items and submenus to any position in most menus.  Like word processor macros, custom menu items allow you to easily run commonly used programs or automate tasks using SpaceFM's unique integration with the bash scripting language, with file manager data exported as ready-to-use bash variables <a href="#designmode">*</a>
	<li>The Bookmarks menu and side pane can contain not only bookmarks, but submenus, custom commands to be run, and applications. <a href="#gui-book">*</a>
	<li>With the built-in SpaceFM Dialog tool - a zenity-like tool but with much greater power - easily create, use, and control custom dialogs or mini-apps.  <a href="#dialog">*</a>
	<li>Make your custom commands respond to window events and manipulate the GUI directly using socket commands <a href="#sockets">*</a>.
	<li>Monitor the stdout/stderr output of custom commands in a dialog, with error detection and popup control, or automatically run commands in a terminal or as an independent process. <a href="#designmode-command">*</a>
	<li>Plugins are available to extend SpaceFM's functions <a href="https://github.com/IgnorantGuru/spacefm/wiki/plugins">*</a>, and creating or sharing a plugin is as simple as exporting any custom menu item you have created. <a href="#plugins">*</a>
    </ul><br>
    
    <li><b>Lightweight &amp; Independent</b> - <i>Written in C with GTK+, udev and inotify support</i><br>
    <ul>
	<li>Written entirely in C - super fast with low resource usage
	<li>Independent of particular distributions and desktop environments
	<li>Builds easily on almost all Linux systems
	<li>Builds with any version of GTK+ ranging from 2.18 to 3.x; relies only on stock GTK+ icons
	<li>Built-in virtual filesystem (VFS) code uses core C kernel functions for speed and reliability, with no dependence on gvfs, etc.
	<li>Interfaces directly with udev (or eudev) for device support, with <b>no dependency on udisks</b>; can also be built with deprecated HAL support instead of libudev
	<li>Built-in support for inotify-capable kernels (>=2.6.13), meaning there are no dependencies on file alteration monitors (fam, gamin, gvfs, etc).  (For rare kernels without inotify support, can easily be built with deprecated fam/gamin support.)
    </ul><br>

    <li><b>Task Manager &amp; Queue</b> - <i>Centralized multi-task queue and popup control</i><br>
    <ul>
	<li>Rather than opening a popup dialog and making you wait while a copy or other task runs, SpaceFM's Task Manager lists all the tasks running in the current window (including copy speed and other statistics), freeing you to continue working <a href="#tasks">*</a>
	<li>Popup dialogs are shown when errors occur, or can be configured to be shown for all tasks <a href="#tasks-dlg">*</a>
	<li>To optimize performance, SpaceFM's task queue smartly pauses some tasks which involve devices already in use, or you can manually pause, queue, resume or stop any task <a href="#tasks-queue">*</a>
	<li>Includes extended overwrite, auto-rename, and error handling options <a href="#tasks-menu-popover">*</a>
	<li>Provides a common interface to multiple su and graphical su programs, terminals, and editors - you simply select which tools you want to use, and SpaceFM handles the details of running your commands as other users, in a terminal, etc.
    </ul><br>

    <li><b>Device Manager</b> <a href="#devices">*</a> - <i>Programmable device management</i><br>
    <ul>
	<li>Single-click mounting and unmounting of devices <a href="#devices-list">*</a>
	<li>Optional automatic mounting and opening of devices on insert <a href="#devices-settings-optical">*</a>
	<li>Programmable event-based manager runs any commands or apps you specify on device or media insertion, mount, and removal <a href="#devices-settings-runm">*</a>
	<li>customisable root functions to format, backup and restore partitions and MBRs, check filesystems, and change volume labels <a href="#devices-root">*</a>
	<li>Custom format of display names for devices <a href="#devices-settings-name">*</a>, and hide or show any device <a href="#devices-settings">*</a>
	<li>Built-in udev (or eudev) support - can be used with <a href="http://ignorantguru.github.io/udevil/">udevil</a> (a mount tool designed specifically for SpaceFM), pmount, udisks, or your custom mount solution <a href="#devices">*</a>
	<li>When used without udisks, there is no need for policykit, consolekit, devicekit, gvfs, and other troublesome components susceptible to frequent breakage and misconfiguration
	<li>Add custom <a href="#handlers-dev">Device</a> and <a href="#handlers-pro">Protocol</a> handlers, and mount options based on fstype or device <a href="#devices-settings-opts">*</a>
    </ul><br>
    
    <li><b>Desktop Manager</b> - <i>Includes a built-in, lightweight DM daemon</i><br>
    Based on LXDE's former desktop manager, SpaceFM can conveniently manage the icons and wallpaper on your desktop, and supports a transparent background.  Works great with Openbox and other WMs, and can be extended with custom menu items. <a href="#invocation-desktopmanager">*</a><br><br>

    <li><b>Daemon Mode</b> - <i>Keep SpaceFM always running</i><br>
    Run SpaceFM in the background as a daemon to auto-mount and auto-open devices, and quickly open browser windows on demand. <a href="#invocation-daemonmode">*</a><br><br>

    <li><b>Network Support</b> - <i>Mounts network filesystems and ISO files</i><br>
    Conveniently mount network URLs (nfs:// ftp:// smb:// ssh://) and ISO files using the highly configurable <a href="http://ignorantguru.github.io/udevil/">udevil</a>.  Or, configure a custom protocol handler to mount networks using any external tools you choose, plus create custom protocols of your own. <a href="#gui-pathbar-proto">*</a>  NOTE:  Network share support in SpaceFM is ad hoc by design.  This means there aren't many built-in functions pertaining to networks, and SpaceFM does not make network connections itself.  Network discovery and other functions are handled via plugins and your custom commands.<br><br>    
</ul>


<!-- @Introduction @History -->

<p>SpaceFM was originally developed from a fork of the legacy PCManFM file manager.  When PCManFM reached version 0.5.2 (aka 'the legacy version'), the original author (Hon Jen Yee) abandoned it for a major rewrite which made later versions (the 0.9.x series) dependent on gvfs and other components.  At about this same time, PCManFM-Mod was created as a minor fork of the legacy version which added features, addressed bugs, and kept the legacy version alive for those who prefered it for its light dependencies and added features.

<p>PCManFM-Mod was later used as a base for developing SpaceFM, which included an extensible user interface, multiple panel support, a new udev device manager, inotify support, and removed dependencies on fam/gamin and HAL.  Much of the internal virtual filesystem (VFS), which had been developed and debugged in legacy PCManFM and PCManFM-Mod, was retained and extended, providing SpaceFM with a reliable VFS to build upon.

<p>Due to the extensive changes in many parts of the project, SpaceFM was released with its new name as an alpha test version in January 2012.

<p>With version 0.7.5 in April 2012, SpaceFM replaced udisks with direct udev support for device detection and information, and support for multiple mount solutions including <a href="http://ignorantguru.github.io/udevil/">udevil</a> (a mount program developed specifically for SpaceFM), pmount, udisks v1 or v2, or any program you specify.  When used with udevil or a custom protocol handler, this update also added support for network filesystems.

<p>In 2012, the GTK3 version of SpaceFM was introduced.  Rather than abandoning GTK2, users can choose what version of the GTK+ library (2.18 thru 3.x) they want to use with SpaceFM.

<p>In 2013-2014, improvements included extending the features of SpaceFM's Desktop Manager, a new Menu Item Properties dialog for adding and customising menu items, socket commands for interacting with a running instance, and an improved panel configuration memory.

<p>In 2014-2015, handlers were added, greatly extending SpaceFM's ability to open devices and protocols, and handle archives and files.  Also, a new Bookmarks side pane was added to include submenus and much more powerful bookmarks.  Other changes included the addition of video thumbnails and a transparent desktop background mode.


<!-- @Installation @Downloads -->

<p><a href="https://github.com/IgnorantGuru/spacefm/wiki/Distros">Packages</a> <a name="installation-packages">are available<!-- backwards compat --></a> for many distros, and SpaceFM is already included in some distros and repositories.  For others, there is a <a href="#installation-installer">self-extracting installer</a>, as well as several <a href="#installation-manualbuild">manual build methods</a> available.

<p>NOTE: Enabling <a href="#devices-kernpoll">kernel polling</a> is recommended after installing SpaceFM.

<p>SpaceFM's source code archives are distributed from <a href="http://sourceforge.net/projects/spacefm/files/">SourceForge</a> and <a href="https://github.com/IgnorantGuru/spacefm/tree/pkg">Github</a>.

<p><b>All distributed files are signed for your protection.</b>  Before using downloaded files, it is recommended that you authenticate your download using the spacefm-x.x.x.SHA256.asc file for the current version and <a href="http://ignorantguru.github.io/spacefm/spacefm.SHA256.txt">these instructions</a>.

<p>You can also check the <a href="http://ignorantguru.github.io/spacefm/">homepage</a>, <a href="http://ignorantguru.github.io/spacefm/news.html">latest news</a> and <a href="https://github.com/IgnorantGuru/spacefm/issues">report issues</a>.

<p>The <a href="https://github.com/IgnorantGuru/spacefm/wiki">SpaceFM Wiki</a> contains user-contributed <a href="https://github.com/IgnorantGuru/spacefm/wiki/plugins/">plugins</a>, help, and information.  Everyone is encouraged to contribute to the wiki.




<!-- @Installation @Installer -->

<a name="installer"><p></a>If a package is not yet available for your distribution, SpaceFM is easily installed using its self-extracting installer available in <a href="https://github.com/IgnorantGuru/spacefm/tree/pkg">Downloads</a> (to save a file, click on its filename and click 'View Raw').  The installer extracts, builds, and installs automatically.

<P>To use the installer, first install <b>required <i>build</i> dependencies</b> (below are Debian package names - packages names in your distribution's repository may vary but should be similar):

<blockquote><i>autotools-dev bash build-essential dbus desktop-file-utils libc6 libcairo2 libdbus-1-3 libffmpegthumbnailer-dev libglib2.0-0 libgtk2.0-0 (>=2.18) libgtk2.0-bin libpango1.0-0 libx11-6 shared-mime-info intltool pkg-config libgtk2.0-dev libglib2.0-dev fakeroot libdbus-1-dev libudev0 (>=143) libudev-dev</i></blockquote>

<p><b>Also</b> Recommended:
<blockquote><i><a href="http://ignorantguru.github.io/udevil/">udevil</a>|pmount|udisks, eject, lsof, wget, ktsuss|gksu, libstartup-notification0, libstartup-notification0-dev, curlftpfs, jmtpfs, fuseiso, gphotofs, ifuse</i></blockquote>

<p><b>IF</b> building with HAL support (device manager functions are very limited), you also need:
<blockquote><i>hal libhal-dev libhal-storage-dev libdbus-glib-1-dev libhal-storage1 libhal1 libdbus-glib-1-2</i><br>
With HAL, you do NOT need: <i>libudev0 libudev-dev</i></blockquote>

<p><b>IF</b> disabling inotify support, you also need fam or gamin:
<blockquote><i>fam|gamin libfam0|libgamin0 libfam-dev|libgamin-dev</i></blockquote>

<p><b>IF</b> you don't want video thumbnail support, add configure option --disable-video-thumbnails and libffmpegthumbnailer is not required.
    
<p>Next, <b>run the installer</b> in a terminal like this (substitute the correct version for "x.x.x"):
<pre>    bash spacefm-x.x.x-installer.sh</pre>

Or, to see the help for alternate build options, run:
<pre>    bash spacefm-x.x.x-installer.sh --help</pre>

<p><b>If build dependencies are missing</b>, examine the errors, install required dependencies, and run the installer again.

<p><b>To upgrade to the latest version</b>, just download the latest installer and run it.

<p>NOTE: Enabling <a href="#devices-kernpoll">kernel polling</a> is recommended after installing SpaceFM.

<!-- @Installation @Manual Builds #manualbuild -->

<p>For easy-to-follow manual build instructions, please see the <a href="https://github.com/IgnorantGuru/spacefm/blob/master/README">README</a> file.  Sections there include:

<ul>
    <li>BUILD GTK2 - build from source with default GTK2 support
    <li>BUILD GTK3 - build with GTK3 support
    <li>BUILD HAL - build with HAL support instead of udev (this severely limits the <a href="#devices">device manager</a> and other capabilities)
    <li>BUILD NEXT - build the 'next' branch of SpaceFM.  This version is a work in progress which eventually becomes the next release version.
    <li>BUILD DEBUG - build SpaceFM with debug symbols for reporting crashes with a gdb backtrace
    <li>CREATE DEB PACKAGE - easily create a deb binary package file of SpaceFM for almost any Debian-based distro
</ul>

<!-- @Installation @Uninstall -->

<p>If you installed SpaceFM from a package, <b>use your package manager</b> to remove it.  Otherwise, if you installed via the self-extracting installer or a manual build, you can remove SpaceFM (including plugins) with these commands, <b>all run as root</b>:

<p>(these commands assume you installed with the default <code>--prefix=/usr/local</code> - adjust as needed)
<pre>    rm /usr/local/bin/spacefm /usr/local/bin/spacefm-auth
    rm -r /usr/local/share/spacefm
    rm /usr/local/share/pixmaps/spacefm.png
    rm /usr/local/share/pixmaps/spacefm-*.png
    rm /usr/local/share/icons/hicolor/*/apps/spacefm.png
    rm /usr/local/share/icons/hicolor/*/apps/spacefm-*.png
    rm /usr/local/share/icons/Faenza/apps/48/spacefm.png
    rm /usr/local/share/icons/Faenza/apps/48/spacefm-*.png
    rm /usr/local/share/locale/*/LC_MESSAGES/spacefm.mo
    rm /usr/local/share/applications/spacefm*.desktop
    rm /usr/local/share/mime/packages/spacefm-mime.xml
    update-mime-database /usr/local/share/mime > /dev/null
    update-desktop-database -q
    gtk-update-icon-cache -q -t -f /usr/local/share/icons/hicolor</pre>


<!-- @Invocation @Command Line -->

<p>To see SpaceFM's command line usage run <code>spacefm --help</code>
<pre>Usage:
  spacefm [OPTION...] [DIR | FILE | URL | DEVICE]... 

Help Options:
  -h, --help                   Show help options
  --help-all                   Show all help options
  --help-gtk                   Show GTK+ Options

Application Options:
  -t, --new-tab                Open folders in new tab of last window (default)
  -r, --reuse-tab              Open folder in current tab of last used window
  -n, --no-saved-tabs          Don't load saved tabs
  -w, --new-window             Open folders in new window
  -p, --panel=P                Open folders in panel 'P' (1-4)
  --desktop                    Launch desktop manager daemon
  --desktop-pref               Show desktop settings
  --show-pref=N                Show Preferences ('N' is the Pref tab number)
  -d, --daemon-mode            Run as a daemon
  -c, --config-dir=DIR         Use DIR as configuration directory
  -f, --find-files             Show File Search
  --set-wallpaper              Set desktop wallpaper to FILE
  -g, --dialog                 Show a custom dialog (See <a href="#dialog">-g help</a>)
  -s, --socket-cmd             Send a socket command (See <a href="#sockets">-s help</a>)
  --profile=PROFILE            No function - for compatibility only
  --no-desktop                 No function - for compatibility only
  --version                    Show version information
  --display=DISPLAY            X display to use</pre>

<p>Normally, your session file and other user files are saved in <a href="#programfiles-home">~/.config/spacefm/</a>  To make SpaceFM read and save your files in another folder (~/.config/spacefm-alt in this example), stop ALL <i>instances</i> of SpaceFM and run:
<pre>    # first stop all instances:
    killall spacefm

    # then:
    spacefm --config-dir ~/.config/spacefm-alt</pre>

<p>IMPORTANT:  The config directory path may not contain spaces or other special characters - keep it simple.  Also, if /etc/xdg/spacefm exists, its contents will be copied to the config directory if it doesn't exist at startup.

<!-- @Invocation @Opening Windows #windows -->
<p>To open an initial SpaceFM window, run 'spacefm' with or without a folder specification:
<pre>    spacefm

    # or to open a folder:
    spacefm /home

    # or to open several folders in tabs:
    spacefm /home /usr/bin

    # or to not open saved tabs:
    spacefm -n
</pre>

<p>To open an additional folder in a new tab of the last used SpaceFM window on the current workspace:
<pre>    spacefm /etc</pre>

<p>To open a folder in the current tab of the last used SpaceFM window on the current workspace:
<pre>    spacefm -r /etc</pre>

<p>To simply bring the SpaceFM window to the top of other windows:
<pre>    spacefm -r</pre>

<p>To open a second window:
<pre>    spacefm -w

    # or to open a specified folder in a second window:
    spacefm -w /boot

    # or to open a second window without loading saved tabs:
    spacefm -wn
</pre>

<p>To open a File Search window:
<pre>    spacefm --find-files</pre>

<p>SpaceFM maintains <a href="#programfiles-tmp-socket">a socket</a> for each user/display combination, so when you open multiple windows using the same user and display, all windows are run from a single instance of SpaceFM.  Unless a <a href="#invocation-daemonmode">daemon</a> or the <a href="#invocation-desktopmanager">desktop manager</a> is running, SpaceFM will exit when all windows are closed.

<p>When a window is closed, the current folder tabs are saved to your session file if option File|Save Tabs is checked.  The next time you run SpaceFM, these folder tabs will be re-opened in addition to opening tabs for any folders you specify on the command line (unless you specify -n on the command line).

<p>To specify a specific panel in which to open a folder:
<pre>    # open a folder in panel 2:
    spacefm --panel=2 /usr/bin</pre>

<p>To simply show and focus panel 2 in the last used window:
<pre>    spacefm --panel=2</pre>

<p>As a more advanced example, consider wanting to open multiple SpaceFM windows, each containing different folder tabs in each panel, using a single command.  For this, use a script like this to start SpaceFM:
<pre>
    #!/bin/bash

    # open new window with two tabs in panel 1
    spacefm -wn --panel=1 /etc /usr &
    sleep 0.2
    # add two tabs to panel 2
    spacefm -rn --panel=2 /bin /lib
    sleep 0.2
    # open second window with two tabs in panel 1
    spacefm -wn --panel=1 /boot /media
    sleep 0.2
    # add two tabs to panel 2 of second window
    spacefm -rn --panel=2 /sbin /var
</pre>
The sleep commands give time for the socket to be created and the newly created window to become the last used window.  A shorter sleep time of 0.1 may also work on your system.

<!-- @Invocation @Opening Files, URLs, and Devices #file -->
<p>If you specify a file rather than a folder on the command line, SpaceFM will open the file using the default MIME application for this file type (File Handlers are not used), but will not open a SpaceFM window:
<pre>    # open a file:
    spacefm /etc/fstab</pre>

To open a URL (see <a href="#handlers-pro">Protocol Handlers</a>):
<pre>    spacefm ftp://ftp.us.debian.org/debian/</pre>

To mount and open a device (see <a href="#handlers-dev">Device Handlers</a>), or open an already mounted device:
<pre>    spacefm /dev/sdd1</pre>


<!-- @Invocation @GTK Themes -->

<p>The GTK theme you're using may have a significant impact on SpaceFM's performance, and a non-working theme may create dysfunctional behavior.  Because multiple panels in SpaceFM use many GUI elements, some themes cause SpaceFM to run more slowly.  For example, the Clearlooks GTK2 theme has been observed to be very slow with SpaceFM, while the Raleigh theme is quite fast.

<p>SpaceFM may be built to use GTK v2 or v3.  To see if your installed copy of SpaceFM is using GTK2 or GTK3 themes, run <code>spacefm --version</code>

<!-- #GTK 2 #gtk2 --> 
<b>When using GTK2</b>, it is possible to use a specific theme just for SpaceFM, overriding your default theme.  For example, to use the Raleigh theme (if installed), run SpaceFM like this:
<pre>    GTK2_RC_FILES=/usr/share/themes/Raleigh/gtk-2.0/gtkrc spacefm</pre>

<p>You can also test SpaceFM's speed with no theme, which should be faster than any theme:
<pre>    GTK2_RC_FILES="" spacefm</pre>

<p>To specify a GTK2 theme within a desktop file, copy SpaceFM's desktop file to your home folder:
<pre>    mkdir -p ~/.local/share/applications
    cp <a href="#programfiles-usr-spac-dt">/usr/local/share/applications/spacefm.desktop</a> ~/.local/share/applications/
    # OR
    cp /usr/share/applications/spacefm.desktop</a> ~/.local/share/applications/</pre>

Then open ~/.local/share/applications/spacefm.desktop in your editor and set the Exec= line using env.  For example:
<blockquote>Exec=env GTK2_RC_FILES=/usr/share/themes/Raleigh/gtk-2.0/gtkrc spacefm</blockquote>

<p><a href="http://irtfweb.ifa.hawaii.edu/~spex/computers/techdocs/misc/gtk_themes.html">More information on using GTK2 themes</a>

<!-- #GTK 3 #gtk3 --> 
<b>When using GTK3</b>, theme choice becomes especially important because themes are often broken with every minor GTK3 release, and a theme not made specifically for your current version of GTK3 can cause memory leaks, GUI glitches, and other severe problems visible in SpaceFM.  To determine if your theme is the cause of problems, run SpaceFM in a terminal to see any warnings, and also compare behavior with Adwaita (default GNOME theme).


<!-- @Invocation @Desktop Manager -->

<p>SpaceFM includes a lightweight desktop manager to manage desktop icons and show wallpaper (or a transparent background).  SpaceFM's DM works well with Openbox, for example, which doesn't include a desktop manager.  To start a desktop manager daemon, first terminate any other software which is managing your desktop, then run:
<pre>    spacefm --desktop</pre>

<p>You can also run <code>spacefm --desktop</code> from your login script.  For example, if you're using Openbox, add this line to ~/.config/openbox/autostart.sh:
<pre>    ( spacefm --desktop ) &amp;</pre>

<p>While managing the desktop, SpaceFM's <a href="#devices">volume monitor</a> will also be running, meaning that if configured to do so, it will automount devices.

<p>To set the wallpaper from the command line, run a command like:
<pre>    spacefm --set-wallpaper <i>/home/user/wallpaper.jpg</i></pre>

<p>To open the desktop preferences window from the command line run:
<pre>    spacefm --desktop-pref</pre>

<p>To stop management of the desktop prematurely (before logoff), send spacefm a quit signal:
<pre>    killall spacefm</pre>

Like other menus in SpaceFM, <a href="#designmode">Design Mode</a> may be used in the desktop's right-click menu to add custom menu items and set key shortcuts (which will be active when the desktop has focus).


<!-- @Invocation @Daemon Mode -->

<p>If you want SpaceFM always running in the background, ready to quickly open windows and automount volumes, but <i>don't</i> want it to manage the desktop, start a daemon instance of SpaceFM:
<pre>    spacefm -d</pre>

<p>No window will open in this case, but an instance will be started if not already running, and it will continue running for the duration of your X login session.  You can also start the daemon from your login script.  For example, if using Openbox, add this line to ~/.config/openbox/autostart.sh:
<pre>    (sleep 2 && spacefm -d) &</pre>

<p>One particular use for daemon mode is to make sure leftover folders in /media are removed.  SpaceFM can unmount removable devices on exit to prevent folders remaining in /media at shutdown (if you check option <a href="#devices-settings-exit">Settings|Auto-Mount|Unmount On Exit</a>).  If running as a normal instance, this means devices will be unmounted whenever you close the last SpaceFM window.  When running as a daemon (or as a desktop manager daemon), devices won't be unmounted until you logoff.

<p>To stop a daemon mode instance, send SpaceFM a quit signal:
<pre>    killall spacefm</pre>


<!-- @Quick Start @Frequently Asked Questions #faq -->

<ul>
    <a href="#context-help">How do I see help for a menu item?</a><br>
    <a href="#designmode">How do I set or change key shortcuts and icons?</a><br>
    How to I set or change the key to go Up a directory?<br>
	<blockquote>Right-click on the file list, right-click on menu item Go|Up, and select Key Shortcut.</blockquote>
    <a href="#adjview">How do I change the file list view, add/remove columns, etc.?</a><br>
    <a href="#impcon">How do I hide a menu item?</a><br>
    <a href="#designmode-toolbars">How do I customise the toolbars?</a><br>
    <a href="#designmode-toolbars">I hid the toolbar - how do I restore it?</a><br>
    How do I create a custom menu item?<br>
	<blockquote>Use <a href="#designmode">Design Mode</a> to add a <a href="#designmode-designmenu-new">New</a> custom menu item.</blockquote>
    <a href="#designmode-designmenu-cut">How do I move a custom menu item to another menu or menu position?</a><br>
    <a href="#designmode-designmenu-import">How do I import a plugin to another menu?</a><br>
    How do I create a new tab in the current folder?<br>
	<blockquote>Right-click on any tab and select Tab Here (you can assign any key shortcut to this item using <a href="#designmode-designmenu-key">Design Mode</a>).</blockquote>
    <a href="#handlers-arc-arcdef">How do I make archives (tar.gz etc) open with an application?</a><br>
    Why aren't all my thumbnails displayed?<br>
	<blockquote>View|Preferences|Max Pic Size To Thumbnail may limit what pics are thumbnailed.</blockquote>
</ul>


<!-- @GUI @Panels #pan -->

<p>SpaceFM includes up to four file manager panels in each window.  Each panel represents a complete file manager, including tabbed directory contents and optionally shown side panes, toolbar, path bar, and status bar.  Each panel can be hidden or shown via the View menu, or via the Panel Bar located to the right of the main menu bar.

<p>If shown, panels 1 and 2 are next to each other in the top half of the window, and panels 3 and 4 are in the bottom half.  This allows horizontally arranged panels, vertically arranged panels, and combinations of both.

<p><a name="adjview"><b>NOTE:</b></a> SpaceFM's main menu bar (File, View, etc.) is mostly used for <i>program-wide</i> settings and functions.  Most adjustments for an individual panel's appearance are found by right-clicking on the file list and selecting the View context menu.  This View menu will allow you to set which side panes and toolbars are visible in a panel, add and remove file list columns, set the list style and font, set the sort method, etc.

<!-- #Panel Memory #mem -->
<p>The best way to use SpaceFM's memory for panel configurations is to select the panels you want visible, then arrange each panel as you want it to appear.  Hide or show side panes and adjust their sizes, choose file list columns and adjust their widths, choose which toolbars are visible, etc.  Each time you select a different combination of panels, you may need to do some further configuration until SpaceFM gets to know all the combinations you use and how you like them arranged.

<!-- #How It Works #how -->
<p>Many settings in each panel are specific to that panel.  For example, a different font can be set for the file list or other panes in each panel.  Also, each panel may have a different view style (Detailed, Compact, or Icons), different file list columns visible, different side panes visible, etc.

<p>Some panel settings use a four-state memory, and these settings may be different depending on the panel's relationship to other panels in the window.  The four states are:
<ul>
    <li>panel is shown by itself in the window<br>
    <LI>panel has a horizonal neighboring panel<br>
    <li>panel has a vertical neighboring panel<br>
    <li>panel has both horizontal and vertical neighboring panels<br>
</ul>

<p>The four-state memory of each panel allows SpaceFM to remember how you configured each panel in combination with other panels.  This makes it easier to show and hide panels on the fly without having to readjust columns, side panes, etc.  SpaceFM will remember the selected columns (visibility), column widths, side pane visibility and sizes, and toolbar visibility for each state of each panel.

<p>For more advanced users, note that <a href="#sockets">socket commands</a> can be used to adjust panel configurations from a command or script.  When set as <a href="#sockets-events">event handlers</a>, adjustments can be made automatically when GUI or other events occur, such as showing/hiding a panel or changing window size.

<!-- #Maximized &amp; Fullscreen #max -->
<P>If you maximize the SpaceFM window, any changes to column widths are not remembered (in any panel or in the task manager).  This means that you can change column widths while maximized, and when you return to an unmaximized window state, your columns widths will revert to their original sizes.

<p>However, if you exit SpaceFM while the window is maximized, your column widths <i>will</i> be saved.  When you restart SpaceFM it will open maximized, and any changes to column widths thereafter will be remembered while maximized (unless you unmaximize and maximize again).

<p>In fullscreen mode, neither changes to column widths nor to side pane heights are remembered.  When you return to non-fullscreen mode, these will revert to their original sizes.

<!-- #Focus Highlighting #foc -->
SpaceFM is designed so that for most purposes, it is not necessary to know which panel has the focus.  By right-clicking in a panel, the context menu shown will be specific to that panel.  (Window level commands and settings are available via the main menu bar.)

<p>However, sometimes it is necessary to know which panel has focus, such as when using keyboard shortcuts on selected files, or using a custom command or plugin in the main menus.  For this purpose, SpaceFM provides an icon at the right of each panel's status bar.  This icon will be enabled for the panel which has focus.

<p>If you would like a more prominent reminder, it is possible to set custom highlight colors for the focused panel's status bar text and background.  To set highlight colors, right-click on the status bar of the panel and select Highlight Text or Highlight Bar.  Each panel may use different highlight colors, or the same.




<!-- @GUI @Path Bar -->

<p>SpaceFM's Path Bar (location bar) is located above the file list between the Left and Right <a href="#designmode-toolbars">toolbars</a>.  At its simplest, the Path Bar allows you to see the current folder's path, and you can enter a new path and press Enter to change to another folder.

<p>TIP:  To place the cursor in the Path Bar, you can use Go|Focus|Path Bar, accessed from the right-click menu of the file list.  By default, this is assigned to key shortcut Ctrl+L.

<p>In addition to displaying and accepting a folder path, SpaceFM's Path Bar has additional methods and uses as detailed below.

<!-- # Editing Keys #keys -->
When the cursor is in the Path Bar, the following editing key combinations can be used:

<br><br>
<table border=1 cellpadding="5">
<tr>
	<th>Key Combo</th>
	<th>Result</th>
</tr>
	<tr>
		<td>Shift+Backspace</td> <td>Clear the entry</td>
	</tr><tr>
		<td>Ctrl+Backspace</td> <td>Backspace to the previous separator</td>
	</tr><tr>
		<td>Ctrl+Left</td> <td>Jump to previous separator</td>
	</tr><tr>
		<td>Ctrl+Right</td> <td>Jump to next separator</td>
	</tr><tr>
		<td>Tab</td> <td><a href="#gui-pathbar-tab">Complete entry</a></td>
	</tr>
</table>

<p>When the Path Bar has focus, it will steal the following keypresses (even if they are set as key shortcuts): visible characters without a modifier key, Enter, Home, Shift+Home, End, Shift+End, Delete, Tab, Backspace, Left, Shift+Left, Right, Shift+Right.

<!-- # Auto Seek #seek -->
By default, the Path Bar will auto seek, which means that as you type in the Path Bar, the current directory will change automatically, and any partial filename typed will select the first matching directory or file found in the file list.  You can turn off auto seek by right-clicking on the Path Bar and unchecking option Auto Seek.  In this case, you will need to press the Enter key to change to the directory entered.

<p>To locate files within the current directory, use <a href="#gui-find">Find-As_You-Type Search</a> or <a href="#gui-pathbar-pattern">Edit|Select By Pattern</a>.

<!-- # Completion #tab -->
As you're entering a directory path in the Path Bar, completion will be active.  For example, if you enter "/us", a drop down box will appear listing /usr (and any other directories that may begin with "/us" on your system).  You can press Tab to complete the entry automatically ("/us" will be completed to "/usr/", or as much as possible if there are multiple matches).  If multiple possibilities are listed, press Down Arrow to select the desired completion and press Enter (or select it using the mouse).

<!-- # Breadcrumbs #bread -->
The Breadcrumbs feature allows you to Ctrl+Click on a portion of the path in the Path Bar to trim the path back.  This will also immediately change to the new path.  For example, if the path is currently <i>/usr/<b>share</b>/spacefm/plugins</i> and you Ctrl+Click on the name 'share', the path will change to <i>/usr/share</i>.  This provides a convenient way to go up to a specific directory.

<!-- # Middle-Click Auto Seek #middle -->
A middle-click in the Path Bar will replace the contents of the Path Bar with the contents of the primary clipboard, and will seek to the location.  The primary clipboard is set simply by selecting text in any application.  For example, if you select the text "/etc/fstab" in your editor, then middle click in SpaceFM's path bar, the directory will change to /etc and the 'fstab' file will be selected.  If you don't want to replace the contents of the Path Bar, and merely want to insert the primary clipboard text (the usual behavior of middle-click), hold down a modifier key while you click, such as Ctrl or Shift.

<!-- # File Path or Device #file -->
The path to a file may be entered or pasted in the Path Bar.  When you press Enter, SpaceFM will change to the directory containing the file and will select the file in the file list.

<p>Also, a device file (eg /dev/sdd1) may be entered in the path bar.  The device will be mounted if needed, and the mount point directory of the device will be opened.

<!-- # Protocol URL #proto -->
Any entry in the Path Bar which looks like a protocol, such as <i>ftp://mirrors.kernel.org/</i>, will be opened with the associated <a href="#handlers-pro">protocol handler</a>.  If a fileystem is mounted, SpaceFM will usually open the mount point directory automatically.  If the <a href="#devices-list">Devices List</a> has option <a href="#devices-settings-net">Settings|Show|Mounted Networks</a> checked, the filesystem may be listed.

<p>Regardless of the protocol, SpaceFM's default protocol handlers all accept URLs in the format:
<pre>    PROTOCOL://USERNAME:PASSWORD@HOST:PORT/SHARE</pre>

<p><b>WARNING:  Including a password in the URL is a very unsafe mode of use</b>, as your password is included in the command line and may be written to temporary and/or system files by SpaceFM or mount helpers.  See documentation specific to the filesystem for other authentication methods offered, or enter your password when prompted.

<p>Some parts of the above URL format may be omitted.  Examples include:
<pre>    ftp://mirrors.kernel.org
    smb://user:pass@10.0.0.1:50/docs
    ssh://user@sys.domain
</pre>

NFS and Samba (cifs) URLs may also be in the alternate formats:
<pre>    NFSHOST:/SHARE
    //SAMBAHOST/SHARE</pre>

For additional URL examples, see <a href="http://ignorantguru.github.io/udevil/udevil--help.html">URL protocols and formats handled by udevil</a>, which natively uses the same URL formats supported by SpaceFM.

<p>In addition, custom <a href="#handlers-pro">protocol handlers</a> may be added which accept URLs in the above formats, or in any format you prefer.
 
<p>URLs may also be opened via the main menu bar's File|Open URL item, which is equivalent to entering them in the Path Bar, or on the command line.

<p>TIP:  You can sometimes right-click on a mounted network in the <a href="#devices-list">Devices List</a> and select <a href="#devices-menu-bookmark">Bookmark</a> to bookmark the URL for future use.  Or, right-click on the Path Bar containing a URL and select New Bookmark.  Or, edit an existing bookmark to contain a URL target.


<!-- # Command Line #cmd -->
In addition, a bash command line can be entered in the Path Bar.  This is a convenient way to run a command without having to manually open a terminal.

<p>One or more <b>command prefixes</b> are required to tell SpaceFM how to run your command:
<p>
<table border=1 cellpadding="5">
<tr>
	<th>Prefix</th>
	<th>Result</th>
</tr>
	<tr>
		<td>$</td> <td>run as task</td>
	</tr><tr>
		<td>&amp;</td> <td>run and forget</td>
	</tr><tr>
		<td>+</td> <td>run in terminal</td>
	</tr><tr>
		<td>!</td> <td>run as root</td>
	</tr>
</table>

<p>A Path Bar entry is interpreted as a command only if at least one of the above prefixes preceeds the command.  A space after the prefix(es) is optional.  For example, enter in the Path Bar:
<pre>    $ ls</pre>

When you press Enter, ls will be run for the current directory, and a dialog will open showing the output.  When using prefix '$', the command is run as a task (it will be listed in the <a href="#tasks-man">Task Manager</a> if it takes longer than a half second to run), and a <a href="#tasks-dlg">popup dialog</a> will open only if the command produces output or an error.

<p>In addition, the substitution variables defined in <a href="#designmode-props-command">Command Line</a>, and the bash script variables described in <a href="#designmode-command-script">Command Script</a> may also be used in Path Bar command lines.

<p>For example, to open a dialog showing the path of the current directory:
<pre>    $ echo Current Directory: %d</pre>

Or to run umount in a terminal (+) as root (!) passing it the currently selected device (%v):
<pre>    +! umount %v</pre>

<p>When a plus sign (+) prefix is included, the command is run in a terminal, not as a task.  When an exclamation point (!) prefix is included, the command is run as root.

<p>If the ampersand (&amp;) prefix is included, the command is run and forgotten (no error or output will be shown).  This is useful for starting an application.  For example:
<pre>    &amp; firefox</pre>

For a reminder of prefixes and substitution variables, enter a lone dollar sign ($) in the Path Bar and press Enter.  Or press F1 while the Path Bar has focus to open this manual.

<!-- # Command History #hist -->
SpaceFM also keeps a command history.  As you enter a command, any commands previously entered will be shown in a popup.  Use Up/Down Arrow keys to select a previous command and press Enter, or click it.


<!-- # Select By Pattern #pattern -->
If a percent sign (%) prefix is entered in the Path Bar, SpaceFM treats the rest of the text as a file selection pattern.  This function is equivalent to right-clicking on the file list and selecting Edit|Select By Pattern.  For example, enter in the Path Bar:
<pre>    % *.avi</pre>

When you press Enter, all filenames in the file list ending in ".avi" will be selected, and all other files will be unselected.

If your pattern contains any uppercase characters, the matching will be case sensitive.  For additional wildcard characters and pattern specifics, see <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13_01">IEEE Pattern Matching Notation</a>.

<p>See also: <a href="#gui-find">Find-As-You-Type Search</a>.

<!-- # Font -->
The font used in the Path Bar can be customised (this is a per panel setting).  Right-click on the Path Bar and select Font.

<!-- # More To Come #more -->
Additional functions are planned for SpaceFM's Path Bar - check this manual for updates or see <a href="http://ignorantguru.github.io/spacefm/news.html">SpaceFM News</a> for recent changes.




<!-- @GUI @Find-As-You-Type Search #find -->

<p>When the file list has focus (click on the file list), pressing an alphanumeric key will open the Find-As-You-Type search box in the lower right corner of the file list, allowing you to quickly jump to a file.  Press down or up arrow, or scroll wheel up/down, to go to the next or previous matched filename.

<p>In addition, Find-As-You-Type Search supports the following modes:

<ul>
    <li><b>Pattern Mode:</b>  If the search key contains at least one asterisk (*) or question mark (?), a glob substring search is used. (An asterisk is automatically added before and after your key before testing.)  For pattern usage see <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13_01">IEEE Pattern Matching Notation</a>.<br><br>

    <li><b>Non-Pattern Mode:</b>  If your key does not contain an asterisk (*) or question mark (?), a normal substring search is performed, with the following new special characters recognized:<br><br>
    <ul>
        <li>If the search key begins with a caret (^), <b>or</b> the search key is less than three characters, the search will match names <i>beginning</i> with your key.
	<li>If the search key is longer than two characters and doesn't begin with a caret (^), a case insensitive substring search is conducted (this means if you type any part of a filename, the cursor will select the first filename which <i>contains</i> that string of characters.) 
        <li>If your key ends with a dollar sign ($), the search will match names <i>ending</i> with your key.
        <li>You can use both a caret and dollar sign to constrain both.  (Other regex characters and wildcards are <b>not</b> supported in this mode.)
    </ul><br>
    <li>Anytime you use an uppercase letter anywhere in your search key, the search mode becomes <b>case sensitive</b>.<br><br>

    <li>Regardless of mode, you can press down or up arrow, or scroll wheel down/up, to go to the <b>next or previous matched filename</b>.<br><br>
</ul>

See also: <a href="#gui-pathbar-pattern">Select By Pattern</a>.



<!-- @GUI @Rename Dialog #rename -->

<P>SpaceFM's Rename Dialog, accessed by right-clicking on a file and selecting Rename, does much more than rename files.  It can move, copy, or create a link to the selected file or directory.  It can also copy the target of a selected link, or create a new link to the target.  By checking As Root, the function will be performed as the root user.

<P>The Option button allows you to add and remove fields from the dialog.  The selected fields, which are extra-large for easy editing of long filenames, show different parts of the selected path, such as the name and extension, full filename, parent, or path.  As you edit the file's path, you will be advised if the entered path already exists.  If you use a path which doesn't exist, SpaceFM will create the necessary parents automatically.  The Confirm Create option determines if you will be prompted before parents are created.

<P>The Browse button allows you to browse for a filename, parent, or path, and insert it into the dialog.

<P>TIPS:  To select all the text in an entry, click the entry's label (eg 'Filename:'), press the Alt key shortcut, or use Tab.  To quickly copy an entry's text to the clipboard, double- or middle-click on the entry's label (eg 'Filename:').  Multiple files can be selected in the file browser to rename a batch of files.



<!-- @GUI @New File/Folder Dialog #newf -->

<P>The New File/Folder Dialog is opened by right-clicking on the file list and selecting New|File, Folder, or Link.  This dialog works similarly to the <a href="#gui-rename">Rename Dialog</a>, allowing you to create files and folders in other paths, create as root, create relative links (eg a link to ../filename.txt), and create new files and folders using templates.

<P>SpaceFM looks in $XDG_TEMPLATES_DIR/, ~/Templates/, or ~/.templates/ to find template files.  Templates are simply empty or partially filled files (of any type) used to create new files, so instead of an empty file you get a copy of the template file.  You can place any files or links to files in your Templates folder. Subfolders in the templates folder can also be used to create new folders pre-filled with a set of files, or to organize templates.

<p>After you have finished entering the path for your new file or folder, you can press Create to create it, or the '&amp; Open' button to create and open the file or folder in one step.



<!-- @GUI @Bookmarks #book -->

<p>SpaceFM's main Bookmarks menu works like most other menus - you can right-click in the menu to add <a href="#designmode">custom menu items</a>, and to cut, copy, and paste items to other menus.  Custom menu items may be <a href="#designmode-designmenu-bookmark">bookmarks<a/> which open folders, but they may also run <a href="#designmode-designmenu-new">commands</a> or <a href="#designmode-designmenu-app">applications</a>.  This means that items in SpaceFM's bookmarks can run <a href="#sockets">socket commands</a> to open folders in specific panels, change view settings, run external programs, and perform other automated tasks.

<!-- # Bookmarks Side Pane #side -->
<p>Items added to the Bookmarks menu may be shown in the Bookmarks side pane of each panel.  To show the Bookmarks pane, select Show Bookmarks from the main Bookmarks menu, or right-click on a file and select View|Bookmarks.

<p>Right-click in the Bookmarks pane and enter the <b>Settings</b> submenu to adjust behavior.  The <b>Single Click</b> option determines if a single- or double-click is required to open an item.  <b>New Tab</b>, if checked, will open bookmarks in a new tab.  <b>Bookmark Icon</b> and <b>Submenu Icon</b> are used to set the default icons used in the list, and individual item icons can also be configured via their <a href="#designmode-props">Properties</a>.  The <b>Font</b> setting adjusts the font and font size used in the Bookmarks side pane. 

<p>Finally, the <b>Follow Dir</b> option will cause the Bookmarks pane to follow the current directory.  If a bookmark matches the current directory, it will be highlighted.  If the matching bookmark is in a submenu, the submenu will be opened.

<p><b>Follow Dir is a per-panel setting</b>.  For example, you can turn it on in the Bookmarks pane of Panel 1, and turn it off in Panel 2.  When Follow Dir is off, the bookmark selection will not change automatically.
 
<p>Tip: <b>If you don't want SpaceFM to select a bookmark via Follow Dir</b>, prefix the bookmark's <a href="#designmode-props-target">target</a> with a semicolon (;).  Also note that SpaceFM's bookmarks can target multiple directories, URLs, and devices.  Only the first target is used by the Follow Dir function.

<p>Tip: When entering a submenu in the Bookmarks side pane, the current submenu will be shown as the first item in the list.  If clicked, this will take you up to the parent submenu.  Thus there is an 'Up' icon shown next to this item.  <b>The 'Up' icon used is taken from the Up item in SpaceFM's left toolbar.</b>  Changing the icon of the Up toolbar item will change the 'Up' icon shown in Bookmarks.  You can also assign a custom icon to each bookmarks submenu, which will be shown in place of the 'Up' icon.

<p>Tip: The Settings submenu of context menu of the Bookmarks pane (seen by right-clicking in the pane) can have custom items added after it or within it using <a href="#designmode">Design Mode</a>.  Click once on the Settings submenu to close it, then right-click on it for the design menu, or right-click on one of the items within the Settings submenu.

<p><b>To reorder items in the Bookmarks pane</b>, drag them.  Note that drag-n-drop in this pane currently only allows items to be reordered, not moved to other locations.  To move an item to a submenu, or to another SpaceFM menu, you must use Cut and Paste, or Export/Import.

<!-- # Adding A Bookmark #add -->
<p>To add a new bookmark, select Bookmarks|New Bookmark (a key shortcut may also be assigned to this item - right-click on it to set one), right-click on the file list and select New|Bookmark, or right-click in the Bookmarks pane or menu and select <a href="#designmode-designmenu-bookmark">New|Bookmark</a> (which will ask you to select a directory target).  To bookmark a mounted URL, in some cases you can right-click on the URL in the <a href="#devices-list">Devices List</a> and select Bookmark.  Or, a URL or file/dir path in the Path Bar may be bookmarked by right-clicking on the Path Bar and selecting New Bookmark.

<p>To view or adjust the properties of a bookmark, right-click on it and select <a href="#designmode-props">Properties</a>.

<p><b>Note</b>:  The Properties dialog of all custom menu items includes a <a href="#designmode-props-context">Context tab</a> which determines when and how menu items are displayed based on the file browser's current context.  Note that <b>Context settings do not affect display of bookmarks in the Bookmarks side pane</b>, which always shows all bookmarks.  The Context settings WILL affect how items are shown in the main Bookmarks menu.

<!-- # Exporting Bookmarks #export -->
<p>Any single item or submenu of items in Bookmarks may be exported to a <a href="#plugins">SpaceFM plugin file</a> by right-clicking on the item and selecting <a href="#designmode-designmenu-export">Export</a>.  Plugin files created in this way can also be imported into any other menu.

<p><b>To export all items in Bookmarks</b>, right-click on "Bookmarks" - the top item in the Bookmarks side pane - and select Export.  This will create a special plugin file named "Bookmarks.spacefm-bookmarks.tar.gz".  This file may then be imported into any SpaceFM menu, or into the Bookmarks side pane, by right-clicking and selecting Import|File.  Note that this bookmarks plugin file CANNOT be installed or imported via the main Plugins menu. 

<!-- # Importing GTK Bookmarks #gtk -->
<p>Some Gnome applications store bookmarks in GTK's bookmarks file (~/.gtk-bookmarks).  This is a plain text file which can be edited manually.  While SpaceFM is not a Gnome application and does not store its bookmarks in this file (the format of the file cannot store SpaceFM's specialized bookmarks and submenus), SpaceFM can import the contents of this file.  To do so, right-click on an item in the Booksmarks side pane and select New|Import|GTK Bookmarks.  All bookmarks will be imported into the current submenu (or, if you right-clicked on a submenu, then into the selected submenu).

<p><b>IMPORTANT</b>: Note that importing hundreds of bookmarks into SpaceFM is not recommended.  Due to their integration with the menu system, this may cause performance lags in the GUI.  If you have many GTK bookmarks, you may wish to edit the file before importing it, or import them into a submenu and keep only those you need.

<p>In addition to importing GTK's bookmarks, these bookmarks are also shown in the GTK file and folder chooser dialogs used in SpaceFM.  You will see the GTK bookmarks listed in the upper-left 'Places' pane of these dialogs, and you can use the plus (+) and minus (-) buttons there to add or remove bookmarks from that list (which will update ~/.gtk-bookmarks).  Changing bookmarks in this 'Places' list has no effect on SpaceFM's Bookmarks menu.





<!-- @Devices @Introduction -->

<p>SpaceFM includes a programmable udev-based device manager which lists device volumes, allows you to mount and unmount devices, and detects changes, insertions, and removals.  On events, SpaceFM can auto-mount and auto-open devices, and run commands you specify.  In addition, perform-as-root commands allow you to mount and unmount as root; change volume labels; and check, format, erase, backup, and restore partitions.  Like most parts of SpaceFM, the behavior and appearance of the device manager is customisable.

<p>Whenever SpaceFM is running, whether a window is visible or not, a volume monitor is running to monitor device events and take actions.  The volume monitor requires the udevd daemon to be running for device event detection, and enabling <a href="#devices-kernpoll">kernel polling</a> is recommended.

<p>SpaceFM mounts and unmounts devices using customisable <a href="#handlers-dev">Device Handlers</a> which can use <a href="http://ignorantguru.github.io/udevil/">udevil</a> (a mount program developed specifically for SpaceFM), pmount, the udisks command line tool (v1 or v2), or <a href="#devices-settings-mcmd">any program you specify</a>.  You can run the same command lines that SpaceFM uses in a terminal to troubleshoot behavior, or create your own custom handlers or menu items to manipulate devices.

<p>NOTE: If you choose to use udisks with SpaceFM, note that SpaceFM does not configure udisks.  It merely runs the udisks command line tool to mount and unmount devices (unless you install udevil, pmount or specify another program).  If you receive the common 'Not Authorized' or other similar errors from udisks when mounting, or you are prompted for a password, this indicates that udisks (and policykit, etc.) are not properly installed or configured.  This must be corrected in your system configuration, not in SpaceFM.  Installing udevil is the quickest way to solve such problems.

<p>Deprecated HAL support can also be used in SpaceFM (alternate build required).  However, SpaceFM's HAL device manager is far less capable than the udev-based version.  It can only be used to manually mount and unmount devices.  Thus the udev-based version is recommended, and this manual deals exclusively with the udev-based device manager.

<p>To have the device manager always running, responding to events even while no SpaceFM windows are open, run SpaceFM as a  <a href="#invocation-daemonmode">daemon</a> or <a href="#invocation-desktopmanager">desktop manager</a>.

<p>When testing the device manager, it may be useful to run the initial instance of SpaceFM in a terminal, so that you can see additional diagnostic output as it's running.  Just open a terminal window and run <code>spacefm</code>.


<!-- @Devices @List -->

<p>Each panel or tab in SpaceFM can display a Devices list to show devices and permit configuration of the underlying volume monitor.  A Devices list is your interface to the volume monitor's information and actions.  Even if multiple Devices lists are displayed or multiple SpaceFM windows are open, only one volume monitor will be running.

<p>To show or hide a Devices list in each panel, right-click on the file list and check or uncheck option View|Devices.  You can also show or hide the list using the 'Devices' toggle tool item on a toolbar.

<p><b>The Devices list will display only removable and optical devices</b>.  If your Devices list is empty, this means there are no removable or optical devices with media, the udevd daemon is not installed or is not working properly on your system, or you may need to enable <a href="#devices-kernpoll">kernel polling</a> for media detection.  To show or hide additional devices, use the <a href="#devices-settings">Show</a> submenu.

<p>You can mount and open a device in the Devices list by simply left-clicking on it.  The behavior of a left-click will vary depending on options <a href="#devices-settings-newtab">New Tab</a> and <a href="#devices-settings-single">Single Click</a>.

<p>Middle-clicking on a device is equivalent to right-clicking on the device and selecting <a href="#devices-menu-remove">Remove / Eject</a>. Thus to quickly remove a device, just middle-click on it. 

<!-- @Devices @Menu -->

<p>To access the Devices menu, right-click on the Devices list.  By right-clicking directly on a listed device, more options will be available.  Like most menus in SpaceFM, to see the help for any menu item, hover your mouse cursor over the menu item and press F1.  Alternatively, right-click on the menu item and select <a href="#designmode-help">Help</a> in the Design Menu.

In addition, SpaceFM's main menu bar and the desktop menu include Devices menus which list currently shown devices for ready access.  In these menus, you can left-click on a device to open it, or <i>right</i>-click on a device for an abbreviated context menu.  As in the Devices List, you can also middle-click on a device to 'Remove / Eject'.

<p>The Devices List context menu includes:

<!-- #Remove / Eject #remove -->
The 'Remove / Eject' item is used to remove a device and eject media.  When you click 'Remove / Eject', first a full sync is performed to ensure all data has been commited to all disks.  If the sync takes longer than about one half second, the <a href="#tasks-man">Task Manager</a> will auto-show and will list the Remove command as running.  <b>Do not remove</b> a device until the Task Manager shows this command has finished, or data may not be properly written, which can cause data loss.  (If using 'Remove / Eject' from the Devices menu on the desktop, a popup dialog will show removal progress.)  Note that if all other filesystems don't sync immediately, this may prolong the Remove command.  In that case, you can use <a href="#devices-menu-unmount">Unmount</a> instead, which only does a filesystem-specific sync.

<p>Next, if the volume is mounted, it will be unmounted, and if the device is ejectable, it will be ejected.  If the device is removable, it is safe to remove it once the 'Remove / Eject' command has completed without errors, and any lights on the device indicate activity has stopped.  (Even after the sync and unmount has finished, it may take a second or two for the device to stop flashing due to hardware caches.  If the device has no activity indicator, <b>it is best to wait 5 seconds before removing it</b>.)

<p>If you click 'Remove / Eject' and nothing seems to happen, this also indicates the device is ready to be removed.

<p>When a device is removed or unmounted, any tabs showing directories on the device may be automatically closed.

<p>Middle-clicking on a device in the Devices list is equivalent to right-clicking the device and selecting 'Remove / Eject'.  Thus to quickly remove a device, just middle-click on it.

<p>NOTE:  SpaceFM does NOT disable or power-down usb ports or spin down disks when removing a device, it merely performs a sync to ensure data is written.  Usually this is sufficient to prevent data loss.  If powering down is required for your device, you must add a custom command to the Devices menu, or add the applicable command or option to the general <A href="#devices-settings-ucmd">Unmount Command</a>.


<!-- #Reload -->
Reload is used to unmount, eject if necessary, and reload a device's media tray in one step, and can also be used to close an already open media tray.  The Reload item is similar to <a href="#devices-menu-remove">Remove / Eject</a> - the device will be synced, unmounted, and if possible, ejected.  After this, if ejected the tray will be closed.  The device will not be mounted unless <a href="#devices-settings-optical">auto-mount</a> is set.


<!-- #Unmount -->
Unmount will simply run an unmount command on the selected device.  The unmount command from the appropriate <a href="#handlers-dev">Device Handler</a> will be run- by default, <a href="http://ignorantguru.github.io/udevil/">udevil</a>, pumount, or the udisks command line tool will be used.  No general sync is performed (but a filesystem-specific sync is performed by umount).  If the command takes longer than about one half second, the <a href="#tasks-man">Task Manager</a> will auto-show and the Unmount command will be listed until finished.  <b>Do not remove</b> a device until the Task Manager shows this command has finished, or data may not be properly written, which can cause data loss.  (If using 'Unmount' from the Devices menu on the desktop, a popup dialog will show removal progress.)  (Even after the unmount has finished, it may take a second or two for the device to stop flashing due to hardware caches.  If the device has no activity indicator, <b>it is best to wait 5 seconds before removing it</b>.)

<!-- #Sync -->
Sync merely runs a sync command to commit all data to all disks.  If the command takes longer than about one half second, the <a href="#tasks-man">Task Manager</a> will auto-show and the Sync command will be listed until finished.

<!-- #Open -->
Selecting Open will cause the selected device to be mounted if it is not already mounted, and then the mount point directory of the device will be opened in the current tab.  If an error occurs, the error will be shown.  If the command takes longer than about one half second, the <a href="#tasks-man">Task Manager</a> will auto-show and the Open command will be listed until finished.

<p>You can also open a device by simply left-clicking on it.  The behavior of a left-click will vary depending on options <a href="#devices-settings-newtab">New Tab</a> and <a href="#devices-settings-single">Single Click</a>.

<p>To mount, SpaceFM runs the mount command from the appropriate <a href="#handlers-dev">Device Handler</a> for the selected device.  By default, <a href="http://ignorantguru.github.io/udevil/">udevil</a>, pmount, or the udisks command line tool will be used.  The mount point will be determined automatically by the mount program or handler, usually an automatically created subfolder in /media or /run/media/$USER.  If it was automatically created, this subfolder will be automatically removed when the device is unmounted.

<p>If the device has an entry in /etc/fstab, that mount point may be used instead, and its mount directory will not be removed when unmounted.

<p>The device will generally be mounted using SpaceFM's <a href="#devices-settings-opts">Mount Options</a>.  If the device has an fstab entry, options specified there may take precedence, depending on your mount program, which may also automatically add or change some mount options.

<p>pmount does not support conventional mount options, so when using pmount as the mount command, options set in <a href="#devices-settings-opts">Mount Options</a> will be ignored.  Instead, you can include pmount's command line options in the device handler.

<!-- Open In Tab #tab -->
Open In Tab works similarly to open, except that the device's mount point directory will be opened in a new tab, instead of reusing the current tab.  This is also the default behavior of a left-click on a device if option <a href="#devices-settings-newtab">New Tab</a> is checked.  Again, a left-click will not display an error, while selecting Tab will.

<!-- #Mount -->
Mount will simply run a mount command on the selected device.  The mount command from the appropriate <a href="#handlers-dev">Device Handler</a> will be run - by default, <a href="http://ignorantguru.github.io/udevil/">udevil</a>, pumount, or the udisks command line tool will be used.  The mount point will be determined automatically by the mount program or handler, usually an automatically created subfolder in /media or /run/media/$USER.  If the command takes longer than about one half second, the <a href="#tasks-man">Task Manager</a> will auto-show and the Mount command will be listed until finished.

<p>The device will generally be mounted using SpaceFM's <a href="#devices-settings-opts">Mount Options</a>.  If the device has an fstab entry, options specified there may take precedence.  The mount program may also automatically add or change some mount options.

<p>pmount does not support conventional mount options, so when using pmount as the mount command, options set in <a href="#devices-settings-opts">Mount Options</a> will be ignored.  Instead, you can include pmount's command line options in the device handler.

<!-- #Re/mount -->
The Re/mount item is used to mount or remount a device using specific mount options.  A dialog will open asking you for the mount options to be used.  If mounted, the device will first be unmounted.  Then the device will be mounted using the specified options.

<p>Because most mount programs cannot perform a true remount, the device will be unmounted and mounted.

<p>Re/mount accepts extended mount options, as detailed in <a href="#devices-settings-opts">Mount Options</a>.

<p>pmount does not support conventional mount options, so when using pmount as the mount command, options set here will be ignored.  Instead, you can include pmount's command line options in the device handler.

<!-- #Bookmark -->
The Bookmark item will only be shown if the selected device is a <a href="#devices-settings-net">mounted network</a>.  This item allows you to create a bookmark which will automatically mount the network.  Some mounted networks are not recognized.  To create a URL bookmark manually, edit an existing bookmark's target.

<p>Note:  Any custom menu items you add directly after the Bookmark menu item in the Devices menu will also only appear if the selected device is a mounted network, providing an automatic context.

<!-- #Root -->
The Root submenu allows you to perform actions on a device as root.  Dialog messages should be read carefully when using any command in the Root submenu, because actions performed as root can affect any aspect of your system.  SpaceFM will explain what is about to happen and will let you examine the final command line before it is executed.

<p>For details, see the <a href="#devices-root">Root</a> section below.

<!-- #Settings -->
The Settings submenu allows you to (globally) configure the appearance of the Devices list, controlling what devices are listed, how they are listed, what icons are used, etc., and also allows you to set the volume monitor to run commands on various events, such as device insertions, etc.

<p>For details, see the <a href="#devices-settings">Settings</a> section below.

<!-- #Properties -->
The Properties item will gather and show information about the currently selected device.

<p>If mounted, any mtab lines related to the device will be shown in DEVICE, showing you how and where the device is mounted.

<p>USAGE will show information about the filesystem on the device.

<p>If the device has any related lines in the /etc/fstab file, these will be listed in FSTAB.  These may include lines which are disabled (# comments).

<p>In the INFO section, the device's UUID will be listed if known, as well as detailed information from udev on the device's properties.

<p>The PROCESSES section, shown for mounted devices, uses lsof to display any processes which are using the device.  Sometimes when unmounting a device, you will receive an error that the device is in use.  You can check this processes list to see what is holding the device open.

<!-- # Custom Menus #cust -->
As with most menus, it is also possible to add your own custom menu items and submenus to the Devices menu.  This allows you to add commands which can take actions based on the currently selected device in one or more panels.

<p>There are several <a href="#exvar">provided bash variables</a> which your commands can use to get information about the currently selected device:
<pre>
    "$fm_device"              selected device (eg /dev/sr0)  ( same as %v )
    "$fm_device_udi"          device ID
    "$fm_device_mount_point"  device mount point if mounted (eg /media/dvd) (%m)
    "$fm_device_label"        device volume label            ( same as %l )
    "$fm_device_fstype"       device fs_type (eg vfat)
    "$fm_device_size"         device volume size in bytes
    "$fm_device_display_name" device display name
    "$fm_device_icon"         icon currently shown for this device
    $fm_device_is_mounted     device is mounted (0=no or 1=yes)
    $fm_device_is_optical     device is an optical drive (0 or 1)
    $fm_device_is_table       a partition table (usually a whole device)
    $fm_device_is_floppy      device is a floppy drive (0 or 1)
    $fm_device_is_removable   device appears to be removable (0 or 1)
    $fm_device_is_audiocd     optical device contains an audio CD (0 or 1)
    $fm_device_is_dvd         optical device contains a DVD (0 or 1)
    $fm_device_is_blank       device contains blank media (0 or 1)
    $fm_device_is_mountable   device APPEARS to be mountable (0 or 1)
    $fm_device_nopolicy       policy_noauto set (no automount) (0 or 1)

    "$fm_panel3_device"       panel 3 selected device (eg /dev/sdd1)
    "$fm_panel3_device_udi"   panel 3 device ID
    ...                       (all these are the same as above for each panel)
</pre>

For example, to add a custom command which shows the size of the currently selected device in bytes, use this command line:
<pre>    echo "$fm_device_size"</pre>



<!-- @Devices @Root -->
<p>The Root submenu allows you to perform actions on a device as root.  When performing commands as root, SpaceFM will use your configured Terminal SU or Graphical SU program to run the command.

<p>When most items on this menu are selected, a dialog will open showing you the exact command to be run, and allowing you to edit it.  If SpaceFM knows how to perform the function on the selected device type, a default command will already be present.

<p>In order to edit the default command, you must first depress the Edit button.  To restore the command to its default, depress Edit and then press Default.

<p>Most items accept the substitution variable %v in their command, which is used to insert the device file (eg /dev/sda2).  Some commands accept additional substitution variables.  These will be displayed in the dialog's instructions.

<p>When performing commands which result in data loss, such as format, the exact command line to be run will be displayed in the terminal after you enter the root password.  You will need to type the word 'yes' and press Enter to execute the command.

<p>The following functions are included:

<!-- #Unmount -->
By default, SpaceFM will use <a href="http://ignorantguru.github.io/udevil/">udevil</a> to unmount as root, but you can change this to any unmount command, such as a udisks, pumount, or umount command.  Only the substitution variable %v may be used in this command to insert the currently selected device file (eg /dev/sda2).

<!-- #Mount -->
Mount works similarly to Unmount, except that the selected device is mounted as root.  If you want any mount options added, you must specify them in the dialog.

<!-- #Label -->
Label is used to change the volume label of a device.  First, a dialog will open asking you to enter the volume label.  The device's current volume label, if any, will be entered as default.  To unset a volume label, leave the entry blank.

<p>Next the command used to change the volume label on this filesystem type will be shown.  If SpaceFM doesn't know how to change the volume label for this type, the command will be blank and you will have to supply your own.  This dialog remembers the change label command used for each filesystem type.

<p>When you click OK, your Graphical SU program will be used to run the command (no terminal will open).

<p>IMPORTANT:  SpaceFM will display a warning in both dialogs if the device is currently mounted.  Although some filesystem types permit it, it is generally good practice to unmount a volume before changing its label.

<!-- #Check -->
Check runs a filesystem check on the device, using fsck by default.  The command dialog remembers the check command used for each filesystem type.

<p>Check may only be used on unmounted filesystems.

<!-- #Format -->
The Format submenu allows you to format or simply erase a device or partition.  Although Format will work on an entire device, it is up to you to decide what device or device partition you want to format.

<p>The submenu contains common filesystem types to choose from.  To format, select the type and review or edit the command in the dialog.  This dialog remembers the format command used for each filesystem type.  When you click OK, the command will be run in a terminal.  After entering the root password, you will be shown the exact command to be run, and you must type the word 'yes' and press Enter to execute it.

<p>The format submenu also contain 'zero' and 'urandom'.  If selected, the device will be overwritten with zeroes or random values to completely erase it.  As with filesystem formats, you can edit the particular command used.  Edit with care!

<p>To test out the format function without actually formatting anything, try using format on a DVD drive, or an empty drive.  The entire procedure will be the same - you will merely receive an error when the command is finally executed.  This will allow you to safely review how SpaceFM conducts a format.  Just be sure you know which device is the DVD or empty drive!

<!-- #Backup|FSArchiver #fsarc -->
The Backup submenu allows you to perform a backup of a selected device or MBR.  There are several supported backup types.

<p>FSArchiver (<a href="http://www.fsarchiver.org/">website</a>) is a modern program which creates an archive of a filesystem.  It is similar to tar, except that the archive includes checksums, can be restored if corrupted, and includes additional information.

<p>One disadvantage to using FSArchiver is that unlike <a href="#devices-root-parti">Partimage</a>, the on disk locations of files will change when restored.  For most files this won't matter, but in the case of grub's stage files, moving them can cause the grub boot process to no longer work.  Thus if you restore a volume containing grub's files using an FSArchiver archive, you will then need to reinstall grub to the MBR (so that it knows accurately where it's files are - these locations are stored in the MBR's boot code).

<p>An advantage to FSArchiver is that it supports more filesystem types than Partimage, including ext4 and btrfs, and several compression methods.  Other advantages include file exclusion, multi-thread compression, and encryption.  The data may also be restored to any partition large enough to hold it, regardless of the original partition's size.  FSArchiver is also currently maintained, while Partimage is no longer actively developed.  There are additional differences between Partimage and FSArchiver - see their websites for details.

<p>By default, FSArchiver will backup unmounted volumes and volumes mounted read-only.  To backup a volume which is mounted read-write, you must add --allow-rw-mounted to the command.  This may create inconsistencies in the backup.  Run <code>man fsarchiver</code> for details.

<p>To create an FSArchiver backup, right-click on a device and select Root|Backup|FSArchiver.  A file save dialog will open asking you to select a filename and location.  Keep in mind that the archive size may be 50% or more of the total data saved in the filesystem.  Choose a save location with ample space.

<p>Next a command dialog will show you the FSArchiver command to be used, and allow you to edit it.  When you click OK, the command will be run immediately in a terminal.

<!-- #Backup|Partimage #parti -->
Although older than <a href="#devices-root-fsarc">FSArchiver</a>, Partimage (<a href="http://www.partimage.org/">website</a>) is still a valuable if simpler backup tool.  One advantage to Partimage is that the backup preserves the on disk locations of files, which means there is no grub MBR breakage.  However, Partimage does have some limitations when compared to FSArchiver:

<ul>
    <li>Partimage cannot be used to backup ext4 or btrfs filesystems.
    <li>Partimage cannot be used to backup mounted filesystems.
    <li>Partimage can only restore to a partition which is the same size or larger than the original partition, regardless of the actual amount of data in the archive.
    <li>Archives have no internal checksums, so it is not possible to detect corruption (unless you manually create an MD5 sum and check it yourself, etc.)
    <li>There is no built-in ability to encrypt an archive.
</ul>

There are additional differences between Partimage and FSArchiver - see their websites for details.

<p>To create a Partimage backup, right-click on an unmounted device and select Root|Backup|Partimage.  A file save dialog will open asking you to select a filename and location.  Keep in mind that the archive size may be 50% or more of the total data saved in the filesystem.  Choose a save location with ample space.  Note that Partimage will add a '.000' volume extension to the name you select.

<p>Next a command dialog will show you the Partimage command to be used, and allow you to edit it.  By default, the command will break the archive into archive volumes 4G in size.  This can be adjusted by carefully editing the command.  When you click OK, the command will be run immediately in a terminal.

<!-- #Backup|MBR #mbr -->
SpaceFM can also create a backup of a device's Master Boot Record (MBR).  This is a small backup (512 bytes) which contains the entire MBR.  (<A href="http://en.wikibooks.org/wiki/How_To_Backup_Operating_Systems#How_The_Computer_Boots_-_The_MBR_Explained">What Is The MBR?</a>)

<p>After selecting Root|Backup|MBR, a file save dialog will open asking you to select a filename and location.  This is a very small backup file.  When you click OK, a terminal will open and the command will be executed immediately.  (It is not possible to edit the MBR backup command.)

<!-- #Restore|From File #resfile -->
To restore the contents of a device, partition, or MBR using a backup archive file, right-click on the target partition and select Root|Restore|From File. A choose file dialog will open for you to choose a backup file.  This may be any backup file created by SpaceFM, including an <a href="#devices-root-fsarc">FSArchiver</a>, <a href="#devices-root-parti">Partimage</a>, or <a href="#devices-root-mbr">MBR</a> archive file.  (If the file was not created by SpaceFM but uses one of these formats, it may be possible to use the file if the file is named appropriately.)

<p>Next a dialog will show the restoration command to be used, and allow you to edit it.  When you click OK, a terminal will open prompting you for the root password.  Once entered, the exact command to be run will be shown.  You will need to type the word 'yes' and press Enter to execute it.

<p>IMPORTANT:  Restoring data to a partition overwrites any existing filesystem.

<p>After restoring from an FSArchiver backup, if the filesystem contains grub's files, you may need to reinstall grub to the MBR to restore normal boot behavior.  (Reinstalling grub is not handled by SpaceFM, and is outside the scope of this manual, but you can create a custom command to do so.)

<p>When restoring an MBR, only the first 448 bytes of the MBR are restored.  This portion contains the boot code.  The remaining portion of the MBR contains the primary partition table.  This portion is NOT restored (it is generally not useful to do so, and in the case of an out of date backup, could cause extreme data loss).  However, the <a href="#devices-root-mbr">MBR backup file</a> created by SpaceFM does contain the full 512 byte MBR, so if you do want to restore the entire MBR, consult appropriate instructions such as <a href="http://en.wikibooks.org/wiki/How_To_Backup_Operating_Systems#MBR_Restoration">these</a>.

<p>To practice restoring a file without making real changes, consider restoring to a DVD or empty drive as the target.  This will allow you to see the entire process, except that the final command will fail when executed.  Just be sure you know which device is your DVD or empty drive!

<!-- #Restore|File Info #resinfo -->
To examine the summary information in a backup file, select Root|Restore|File Info and select the backup file.

<p>Restore|File Info makes no changes to the backup file or any device - it only displays information about the backup file.  It may need to run as root to do so.

<!-- #Edit fstab #fstab -->
Edit fstab is a convenience function which simply opens the /etc/fstab file as root using root's editor (configured in View|Preferences|Advanced).


<!-- @Devices @Settings -->
<p>The Settings submenu is your interface for controlling the appearance and behavior of the Devices list and volume monitor.  Options include:

<!-- #Show|Internal Drives #internal -->
By default, the Devices list will only show removable and optical drives, while hiding internal system drives.  If option Show|Internal Drives is checked, internal system drives will also be shown in the Devices list.  For the root user, option Show|Internal Drives is checked by default.

<p>Internal drives are often treated differently by mount programs.  You may not be able to mount or unmount them as a normal (non-root) user without making changes to /etc/fstab or to the mount program's configuration.

<p>Note that some external esata drives report themselves as internal, so they may not be shown unless Show|Internal Drives is checked.  Another solution with these drives is to enter an exception for them in <a href="#devices-settings-vol">Show|Volumes</a>.

<!-- #Show|Empty Drives #empty -->
By default, the Devices list will only show drives which contain media, and will hide empty drives.  If option Show|Empty Drives is checked, drives not containing media will also be shown.

<p>Properties can still be obtained on empty drives, and you can use Remove or Reload to open or close the tray.

<p>NOTE:  For proper detection of media, enabling <a href="#devices-kernpoll">kernel polling</a> may be required.

<!-- #Show|Partition Tables #table -->
By default, the Devices list will not show devices which contain partition tables, such as a whole device file (eg /dev/sda) which contains the primary partition table in its MBR, or a partition (eg /dev/sda4) which contains the extended partition table.  Normally you will not work with these device files so it is not useful to show them.  If you do want them shown, check option Show|Partition Tables.  If the device is internal, option Show|Internal Drives is also required.

<p>IMPORTANT:  For some purposes, a whole device file, such as /dev/sda, designates not just the primary partition table, but also the entire device including partitions (/dev/sda1, /dev/sda2, etc.)  Thus if you format /dev/sda, for example, you will overwrite all partitions on the entire device.

<p>However, in some cases a device uses no partitions, and the entire device has been formatted with a single filesystem.  In this case, the Devices list does not consider the whole device file a partition table, so option Show|Partition Tables will have no effect on it being shown.

<p>The size displayed for a whole device file (eg /dev/sda) will generally be the size of the entire device (including all partitions), regardless of whether it contains a partition table or a filesystem.

<p>Specifically, SpaceFM considers a device to be a partition table if its udev properties include a 'partition table:' line, or the device is a partition of type 0x05 (extended partition).

<!-- #Show|Mounted Networks #net -->
By default, the Devices list will show recognized mounted network filesystems (eg nfs, cifs, etc).  This enables you to click on the network to open it's mount point directory, or right-click on it to use the Unmount and Bookmark menu items.  If you do not want mounted networks listed, uncheck option Show|Mounted Networks.

<!-- #Show|Mounted Other #files -->
By default, the Devices list will show files mounted to loop devices, and other non-block devices, such as mounted fuse filesystems.  For example, if you right-click on an ISO file and select Open|Mount ISO, the ISO file will be mounted so you can browse its contents.  You can then click on this device in the Devices list to open it's mount point directory, or right-click on it to use Remove or Unmount.

<p>If you do not want mounted files and non-block device filesystems listed, uncheck option Show|Mounted Other.

<!-- #Show|Ignore Hide Policy #hide -->
Some devices may have their udev property UDISKS_PRESENTATION_HIDE set to 1.  This is a hint to software that the device should be hidden.  By default, SpaceFM will honor these hints and hide such devices.  To ignore such hints, check option Show|Ignore Hide Policy.

<p>The hide policy of a device can be seen by selecting <a href="#devices-menu-properties">Properties</a> for the device and observing the value of 'presentation hide:' in the INFO section.

<p>To ignore UDISKS_PRESENTATION_HIDE for a specific device, use <a href="#devices-settings-vol">Show|Volumes</a>.

<!-- #Show|Volumes #vol -->
The Show|Volumes dialog allows you to specify display exceptions for some devices.  When deciding whether to show or hide a device in the Devices list, SpaceFM will first consult the Show|Volumes list.  If the device is present, it will be shown or hidden based on its entry in this list.  All other show or hide settings will be ignored for this device.

<p>One example use for Show|Volumes is to show an external esata drive which is erroneously identified by udev as internal.  Even if option <a href="#devices-settings-internal">Show|Internal Drives</a> is unchecked, the drive <i>will</i> be shown if listed in Show|Volumes.

<p>Show|Volumes opens a dialog which allows you to specify device files, volume labels, or device IDs in a space-separated list.  There must be a space between entries and a plus or minus sign directly before each item.  This list is case-sensitive.

<p>For example, to force showing device /dev/sdd1, include:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>+</b>/dev/sdd1

<p>Or, to force hiding of /dev/sdd1, include:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>-</b>/dev/sdd1

<p>The '/dev/' portion of the device file MUST be included.

<p>Devices can also be identified by volume label.  For example, to always hide a device with volume label "Label With Space" use:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>-</b>Label With Space

<p>DO NOT use quotes to enclose the label, even if it contains spaces.

<p>Finally, a device's ID may be used:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>+</b>ata-OCZ-part4

<p>For example, this list in Show|Volumes:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>+</b>/dev/sdd1 <b>-</b>Label With Space <b>+</b>ata-OCZ-part4

<p>would cause /dev/sdd1 and the OCZ device to be shown, and the volume with label "Label With Space" to be hidden.

<!-- #Show|Display Name #name -->
Display Name opens a dialog which allows you to edit the display name format used for the Devices list.  This controls how device names are displayed.

<p>In addition to separator characters of your choice, the following substitution variables may be used:
<center><table width="70%">
	<tr>
		<td>%v</td> <td>device filename (eg sdd1)</td>
	</tr><tr>
		<td>%s</td> <td>total size (eg 800G)</td>
	</tr><tr>
		<td>%t</td>	<td>fstype (eg ext4)</td>
	</tr><tr>
		<td>%l</td> <td>volume label (eg Label or [no media])</td>
	</tr><tr>
		<td>%m</td>	<td>mount point if mounted, or ---</td>
	</tr><tr>
		<td>%i</td>	<td>device ID</td>
	</tr>
</table></center>

<p>A device in the list is guaranteed to have a unique, non-blank device filename - no two will be alike.  The other values may be duplicated or empty in some cases.

<p>After you click OK, the display names of the currently shown devices will be updated.  The list is sorted alphabetically, ignoring spaces.

<!-- #Auto Mount|Mount Optical #optical -->
The Auto Mount submenu allows you to control the auto-mounting behavior of the volume monitor.  This determines what happens when a new device or new medium is inserted, whether a new tab is opened, and the auto-unmount behavior.

<p>IMPORTANT:  If you have multiple auto-mount solutions installed and running, this can create confusing behavior.  For example, if you use devmon, then when using SpaceFM's auto-mount features, it is best to disable devmon.

<p>If option Mount Optical is checked, optical devices such as CD/DVD drives will be automatically mounted when media is inserted, and at SpaceFM startup.

<p>TIP: For additional information on what the volume monitor is doing, try running SpaceFM in a terminal.  Information on devices being auto-mounted will be printed to the terminal, and error messages generated by your command may be seen there as well.

<!-- #Auto Mount|Mount Removable #remove -->
If option Mount Removable is checked, the device will be automatically mounted whenever a removable device is inserted, and at SpaceFM startup.

<!-- #Auto Mount|Ignore No Policy #nopolicy -->
Some devices may have their udev property UDISKS_PRESENTATION_NOPOLICY set to 1.  This is a hint to software that the device should not be automatically mounted.  By default, SpaceFM will honor these hints and not auto-mount such devices.  To ignore such hints, check option Show|Ignore No Policy.

<p>The policy of a device can be seen by selecting <a href="#devices-menu-properties">Properties</a> for the device and observing the value of 'presentation nopolicy:' in the INFO section.

<p>To ignore UDISKS_PRESENTATION_NOPOLICY for a specific device, use <a href="#devices-settings-mvol">Mount|Volumes</a>.

<!-- #Auto Mount|Mount Volumes #mvol -->
The Mount Volumes list works similarly to the <a href="#devices-settings-vol">Show|Volumes</a> list, except that it determines what devices will or will not be auto-mounted (and auto-unmounted, if option <a href="#devices-settings-exit">Unmount On Exit</a> is checked).  When deciding whether to auto-mount a device, SpaceFM will first consult the Mount Volumes list.  If the device is present, it will or will not be auto-mounted based on its entry in this list.  All other auto-mount settings will be ignored for this device.

<p>Mount Volumes opens a dialog which allows you to specify device files, volume labels, or device IDs in a space-separated list.  There must be a space between entries and a plus or minus sign directly before each item.  This list is case-sensitive.

<p>For example, to force auto-mounting of device /dev/sdc1, include:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>+</b>/dev/sdc1

<p>Or, to inhibit auto-mounting of /dev/sdc1, include:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>-</b>/dev/sdc1

<p>The '/dev/' portion of the device file MUST be included.

<p>Devices can also be identified by volume label.  For example, to inhibit auto-mounting of a device with volume label "Label With Space" use:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>-</b>Label With Space

<p>DO NOT use quotes to enclose the label, even if it contains spaces.

<p>Finally, a device's ID may be used:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>+</b>ata-OCZ-part4

<p>For example, this list in Mount Volumes:
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>+</b>/dev/sdc1 <b>-</b>Label With Space <b>+</b>ata-OCZ-part4

<p>would cause /dev/sdc1 and the OCZ device to be auto-mounted, and the volume with label "Label With Space" to not be auto-mounted.

<!-- #Auto Mount|Open Tab #tab -->
If option Open Tab is checked, when a device is auto-mounted by SpaceFM, a new tab will be opened for the mount point directory of the device.  If unchecked, the mount point directory will not be automatically opened.

<p>Note that the Open Tab option only affects what happens after a device is auto-mounted by SpaceFM.  It has no effect on devices mounted by other means, nor does it apply to devices mounted by user action within SpaceFM.

<!-- #Auto Mount|Unmount On Exit #exit -->
If option Unmount On Exit is checked, any device which would normally be auto-mounted by SpaceFM (based on auto-mount settings) will be unmounted when SpaceFM exits.  Exit occurs when the last SpaceFM window is closed, unless a daemon or desktop manager daemon is running.  Note that if SpaceFM is killed with SIGKILL (such as when you logout of your X session), the automatic unmount will NOT occur.  (To unmount all devices before or just after X logoff, consider running <code>devmon --unmount-all</code> (devmon is distributed with udevil).

<p>When mounting a device, if there is no fstab entry for the device, your mount program may create a subfolder for the device mount point in /media or /run/media/$USER.  If you or SpaceFM unmounts the device, this subfolder will be removed.  However, if you logoff without unmounting the device, the subfolder may be left behind.  In order to avoid these subfolders accumulating in /media, SpaceFM can unmount devices on exit.

<p>If you don't check option Unmount On Exit, you may need to unmount devices in some other way before logging off to avoid these /media subfolders accumulating.

<!-- #Auto Run|On Mount #runm -->
Auto Run|On Mount opens a dialog which allows you to set a command line to be run when a removable drive or optical data disc is auto-mounted by SpaceFM.  This command can be as simple as a program name to be run, or can be a one line bash script.  The following substitution variables may be used in the command line:
<center><table width="70%">
	<tr>
		<td>%v</td> <td>device (eg /dev/sda1)</td>
	</tr><tr>
		<td>%l</td> <td>device volume label</td>
	</tr><tr>
		<td>%m</td>	<td>device mount point (eg /media/disk)</td>
	</tr>
</table></center>

<p>Note:  When the command is run, %v, %l, and %m refer to the device being added or removed, not the device which is currently selected in the Devices list.

<p>For this command to be run, <b>the device must be auto-mounted by SpaceFM</b>.  It will not be run for devices mounted by other means, or for devices mounted by user action within SpaceFM.

<p>The command will not be run for devices which are auto-mounted at SpaceFM's initial startup.  Thus Auto Run affects devices you add after SpaceFM is running.

<p>For additional information on what the volume monitor is doing, try running SpaceFM in a terminal.  Information on devices being auto-mounted will be printed to the terminal, and error messages generated by your command may be seen there as well.

<p>For example, to automatically add a mounted volume to traydevice, set the On Mount command line to:
<pre>    traydevice %v</pre>

<p>Another example:  To have notify-send alert you of new drive mounts:
<pre>    notify-send --icon=block-device --urgency=low "Volume %l has been mounted"</pre>

<!-- #Auto Run|On Audio CD #runa -->
Similar to <a href="#devices-settings-runm">Auto Run|On Mount</a>, Auto Run|On Audio CD opens a dialog which allows you to set a command line to be run when an audio CD is inserted in a qualified optical device.

<p>The command will be run only if: a) option <a href="#devices-settings-optical">Mount Optical</a> is checked, AND b) the device qualifies for auto-mounting based on <a href="#devices-settings-mvol">Mount Volumes</a> (ie it is not inhibited).

<p>The command will not be run for media which is already inserted during SpaceFM's initial startup.  Thus Auto Run|On Audio CD affects media you insert after SpaceFM is running.

<p>For example, to set an audio CD to automatically start playing in the vlc media player, set the On Audio CD command line to:
<pre>    vlc --verbose=-1 cdda://%v</pre>

<!-- #Auto Run|On Video DVD #runv -->
Similar to <a href="#devices-settings-runa">Auto Run|On Audio CD</a>, Auto Run|On Video DVD opens a dialog which allows you to set a command line to be run when a video DVD is inserted in a qualified optical device.

<p>The command will be run only if: a) the device is auto-mounted by SpaceFM, AND b) the device contains a video DVD.

<p>The command will not be run for devices which are auto-mounted at SpaceFM's initial startup, nor will it be run for devices mounted by other means, nor for devices mounted by user action within SpaceFM.

<p>For example, to set a video DVD to automatically start in the vlc media player, set the On Video DVD command line to:
<pre>    vlc --verbose=-1 dvd://%v</pre>

<!-- #Auto Run|On Insert #runi -->
Auto Run|On Insert opens a dialog which allows you to set a command line to be run when any device is inserted.  This allows you to connect your command to the insertion (device added) event.

<p><a href="#devices-settings-optical">Auto-mount settings</a> have no impact on this function.

<p>Note that when inserting a single drive, your command may be run several times - once for each device file added.  For example, if you insert device /dev/sdd which contains one partition /dev/sdd1, your command will be run once with %v=/dev/sdd and once with %v=/dev/sdd1.  It is up to your command or script to discard events for unwanted devices or partitions.  A script can run one of these commands to get current information on a device's status:
<pre>    udevil info /dev/sdX
    udisks --show-info /dev/sdX
    udisksctl info -b /dev/sdX</pre>

<p>For greater control, an <a href="#sockets-events">event handler</a> may be set for event <a href="#sockets-events-device">evt_device</a>.

<!-- #Auto Run|On Unmount #runu -->
Auto Run|On Unmount opens a dialog which allows you to set a command line to be run when any device is unmounted by any means.

<p><a href="#devices-settings-optical">Auto-mount settings</a> have no impact on this function.

<p>For example, to automatically remove the drive from traydevice, set the On Unmount command line to:
<pre>    pkill -f "traydevice %v"</pre>

<p>For greater control, an <a href="#sockets-events">event handler</a> may be set for event <a href="#sockets-events-device">evt_device</a>.

<!-- #Auto Run|On Remove #runr -->
Auto Run|On Remove opens a dialog which allows you to set a command line to be run when any device is removed.  This allows you to connect your command to the removal event.

<p>The device must be removed.  Ejection of media will not cause this command to be run.

<p><a href="#devices-settings-optical">Auto-mount settings</a> have no impact on this function.

<p>Note that when removing a single drive, your command may be run several times - once for each device file removed.  For example, if you remove device /dev/sdd which contains one partition /dev/sdd1, your command will be run once with %v=/dev/sdd and once with %v=/dev/sdd1.  It is up to your command or script to discard events for unwanted devices or partitions.  Note that when the command is run, %v equals the device file which has been removed, not the device file which is selected in the Devices list.

<p>For greater control, an <a href="#sockets-events">event handler</a> may be set for event <a href="#sockets-events-device">evt_device</a>.

<!-- #Device Handlers #devh -->
Opens the <a href="#handlers-dev">Device Handlers</a> configuration dialog.

<!-- #Protocol Handlers #proh -->
Opens the <a href="#handlers-pro">Protocol Handlers</a> configuration dialog.


<!-- #Mount Options #opts -->
Mount Options opens a dialog which allows you to set default mount options.  These options may be used in Device Handlers via the substitution variable %o, and are used by the default mount command for all mounts, including auto-mounts.

<p>In addition to regular options, you can also specify options to be added or removed for a specific filesystem type by using the form OPTION+FSTYPE or OPTION-FSTYPE.

<p>For example, this set of options:
<br>&nbsp;&nbsp;&nbsp;&nbsp;nosuid, sync+vfat, sync+ntfs, noatime, noatime-ext4

<p>will add nosuid and noatime for all filesystem types, add sync for vfat and ntfs only, and remove noatime for ext4.

<p>Note that some options, such as nosuid, may be added by your mount program even if you don't include them.  Options specified in fstab may take precedence.

<p>pmount does not support conventional mount options, so when using pmount as the mount command, options set here will be ignored.  Instead, you can include pmount's command line options in the appropriate <a href="#handlers-dev">Device Handler</a>.

<!-- #Change Detection #chdet -->
Change Detection opens a dialog which allows you to enter a comma- or space-separated list of filesystems which should NOT be monitored for changes.  This setting only affects non-block devices (such as nfs or fuse), and is usually used to prevent SpaceFM becoming unresponsive with network filesystems.

<p>When SpaceFM opens a directory in a tab, normally it will detect changes, for example if you change, add, or delete files in the directory.  Because SpaceFM works directly with the kernel for file information, and because some network filesystems become temporarily unresponsive when busy, this can cause SpaceFM to become temporarily unresponsive to mouse clicks, etc.

<p>To prevent this, the device's filesystem can be listed in the Change Detection Blacklist.  In this case, SpaceFM will not detect file changes, and you will need to manually refresh the file list view to see them.  To do so, right-click on the file list and select View|Refresh, or press F5.

<p>An alternative approach to blacklisting filesystems is to close the tab containing the filesystem while a copy is in progress to that directory, for example.

<!-- #Single Click #single -->
If option Single Click is checked, the Devices list operates in single-click mode: a single left-click on a device will open it.  If unchecked, a single-click will only select a device, and a double-click is required to open it.

<!-- #New Tab #newtab -->
If option New Tab is checked, when a device is opened with a single or double click (depending on option <a href="#devices-settings-single">Single Click</a>), the mount point directory will be opened in a new tab in the current panel.  If unchecked, the mount point directory will be opened in the current tab.

<!-- #Icon #icon -->
The Icon submenu allows you to set custom icons to be displayed at the left of devices in the Devices list.  For example, to change the icon used for an internal, mounted drive, click Icon|Internal Mounted and enter the desired icon name.

<p>By default, SpaceFM reuses a limited number of icons so that only stock GTK icons are required.  If you would like the device icons to better reflect the changing state of devices, it is valuable to customise these icons.

<!-- #Font #font -->
Font opens a font selection dialog which allows you to select the font to be used for the Devices list.  Select a font family, style, and size and click OK, or click Default to use your <a href="#invocation-gtkthemes">GTK theme's</a> font.


<!-- @Devices @How To Enable Kernel Polling #kernpoll -->
<p>You may need to enable kernel polling for device media changes to be detected by SpaceFM.  For example, if you insert a CD and SpaceFM still says 'no media', this is a symptom that kernel polling is not enabled.

<p>Kernel polling is a newer feature of the Linux kernel and udev, so some distros don't yet have it enabled by default.  To use kernel polling, your Linux kernel may need to be <b>2.6.38 or newer</b>, and udev may need to be <b>version 173</b> or newer.

<p>To determine if kernel polling is enabled:
<pre>
    cat /sys/module/block/parameters/events_dfl_poll_msecs
    cat /sys/block/sr0/events_poll_msecs
</pre>

If you get 0 or -1 from both of those commands, kernel polling may be disabled.

<p><b>To enable kernel polling permanently</b> (survives a reboot), add the following command to your <b>/etc/rc.local</b> file (anywhere before the 'exit' line in that file):
<pre>
    echo 2000 > /sys/module/block/parameters/events_dfl_poll_msecs
</pre>

Any number between 2000 and 5000 (milliseconds) should be reasonable - the higher 5000 means poll every 5 seconds, which is less overhead but a little slower.

<p><b>OR</b> pass this option to the kernel boot command line in grub:
<blockquote>
    <i>block.events_dfl_poll_msecs=2000</i>
</blockquote>

<p><b>OR</b> add a udev rule to enable kernel polling on removable devices:<br>
<blockquote><code>
    echo 'ACTION=="add", ATTR{removable}=="1", ATTR{events_poll_msecs}=="-1", ATTR{events_poll_msecs}="2000"' > /etc/udev/rules.d/61-removable-storage-polling.rules
</code></blockquote>

<p>A reboot will be required for the above changes to take effect, or...

<p><b>To enable kernel polling temporarily and immediately</b>, enable common polling for the block module:
<pre>
    sudo bash -c 'echo 2000 > /sys/module/block/parameters/events_dfl_poll_msecs'
</pre>

<p><b>OR</b> you can enable polling just for a single device like this (/dev/sr0 in this example):
<pre>
    sudo bash -c 'echo 2000 > /sys/block/sr0/events_poll_msecs'
</pre>

This change should be immediate - media will be detected.  However, the above change will be lost when you reboot.

<p>References:<br>
<a href="http://www.mail-archive.com/lfs-dev@linuxfromscratch.org/msg15714.html">linuxfromscratch.org</a><br>
<a href="http://blogs.gentoo.org/mgorny/2011/06/20/uam-can-now-mount-cds-and-dvds/">uam-can-now-mount-cds-and-dvds</a><br>
<a href="https://bugs.archlinux.org/task/25609">bugs.archlinux.org</a><br>
<a href="http://unix.stackexchange.com/questions/38582/udev-triggers-are-not-firing-on-insert-of-cf-card-into-usb-card-reader-anymore">unix.stackexchange.com</a><br>



<!-- @Tasks @Task Manager #man -->
<p>Each SpaceFM window includes a single Task Manager which centrally manages the tasks of all panels in the window.  The Task Manager is designed to eliminate annoying popup dialogs which interfere with user multi-tasking, and allows you to continue working while large files are being copied, etc.  The Task Manager lists running tasks, automatically manages the <a href="#tasks-queue">task queue</a>, allows you to stop, pause, queue, or resume tasks manually, and opens <a href="#tasks-dlg">popup dialogs</a>.  Like most parts of SpaceFM, the Task Manager can also be <a href="#tasks-menu-cust">customised</a> with your own commands to control or interact with running tasks.

<p>A <i>task</i> is a job initiated by the user, such as copying a file.  Tasks come in two varieties: <i>internal</i> and <i>exec</i>.  SpaceFM's internal functions handle tasks such as a copying, moving, and deleting files, while an exec task runs an executable or script, either initiated from within SpaceFM's functions or from a custom command.  The output of exec tasks is also collected and shown in the popup dialog's output monitor.  exec tasks include custom commands as well as external commands run by SpaceFM, such as running udevil to unmount a device.

<p>The Task Manager is located at the bottom of the SpaceFM window, below all panels.  It has two display modes: <i>Show</i> and <i>Auto-Hide</i>.  If option <a href="#tasks-menu-show">View|Tasks|Show Manager</a> is selected, the Task Manager is always visible, even when no tasks are running.  Or, if option <a href="#tasks-menu-auto">View|Tasks|Auto-Hide Manager</a> is selected (the default), the Task Manager will become visible when tasks are running, and will be automatically hidden from view when the last task completes.  The size of the Task Manager may be adjusted by dragging the pane separator above it.

<p>When a task is initiated in any panel and runs for longer than about one half second, it will be listed in the Task Manager, and the Task Manager will be shown if in Auto-Hide mode.  If a task finishes in less than about one half second, the task will not be listed.  New tasks are added to the end of the task list.  When a task completes (successfully or with errors), it is immediately removed from the list.

<p>Task Manager <a href="#tasks-menu-col">columns</a> provide information on each task, and each column can be hidden or moved, allowing you to control what information is shown.  

<p><b>A single left-click on a task</b> in the list, <i>anywhere except in the Status column</i>, will open a popup dialog showing the task's stats, a progress bar, and an output monitor.  For internal tasks (copy, move, etc), the output monitor is used to show errors.  For exec tasks, the output monitor shows the combined stdout and stderr output of the command as its produced.

<p><b>A single left-click on the Status</b> of a task, or <b>a middle-click anywhere on a listed task</b> will change its <a href="#tasks-queue">state</a> (running, queued, or paused).  Click repeatedly to achieve the desired state.

<p><b>A right-click on a task</b> shows the Task Manager's <a href="#tasks-menu">menu</a>, which allows you to stop, pause, queue, and resume tasks, and also contains <a href="#tasks-menu-col">options</a> for the Task Manager.  (These same options may also be accessed via the main menu bar's View|Tasks submenu.)



<!-- @Tasks @Queue -->
<p>Each task listed in the Task Manager may be in one of three states: <i>running</i>, <i>paused</i>, or <i>queued</i>.

<p>A running task is currently executing - files are being copied, or an executable is running, etc.

<p>A paused task has been halted.  For internal tasks such as copy and move, the task thread is halted until you resume the task.  For exec tasks (eg a custom command running an executable, or SpaceFM running udevil to unmount a device), the process has been sent a SIGSTOP signal as described in <a href="#tasks-menu-pause">Pause</a>.

<p>A queued task is also halted.  The only difference is that the Task Manager will automatically resume running a queued task when other tasks complete, whereas a paused task will never resume automatically.

<p>A task's state (running, paused, or queued) can be changed by the user, and in some cases may be changed automatically.

<p>Simply, the queue is used to prevent all tasks from running simultaneously, which can impact performance.  For example, copying two sets of files to the same drive simultaneously is often slower than first copying one set, then the other (due to drive seeking and other issues).  Thus it may be desirable to queue the second task, so it will remain halted until the first task is completed.

<p>If option <a href="#tasks-menu-new">View|Tasks|Queue|Queue New Tasks</a> is checked (the default), new tasks are automatically queued when initiated, rather than run immediately.  SpaceFM will automatically determine when to resume the queued tasks, depending on option <a href="#tasks-menu-smart">View|Tasks|Queue|Smart Queue</a>.  Or, you can always manually <a href="#tasks-menu-resume">Resume</a>, <a href="#tasks-menu-pause">Pause</a> or <a href="#tasks-menu-stop">Stop</a> a task to remove it from the queue.



<!-- @Tasks @Menu -->
<p>The Task Manager's context menu allows you to control tasks and set Task Manager options.  The menu is opened by right-clicking on the list.  The options found on this menu are also available in the main menu bar's View|Tasks submenu (convenient if the Task Manager is hidden).

<p>The context menu contains the following items:

<!-- # Stop -->
Stop is used to stop the selected task.  If the task is internal (such as copying files), SpaceFM will terminate the task thread, and the task will be removed from the Task Manager.

<p>If the task is an exec task (eg a custom command running an executable, or SpaceFM running udevil to unmount a device), the process, <i>and all its child processes</i>, are sent a SIGTERM signal.  This will usually cause the processes to terminate, but not always.  So SpaceFM will also send a SIGKILL signal to all the processes several seconds later.  An exec task will not be removed from the Task Manager until its process terminates.  This means that if a process is hung and cannot be stopped with SIGKILL, selecting Stop may have no effect.

<p>If the command was run as another user, such as root, selecting Stop will cause a prompt for the user's password (or root's password depending on your configured su program) to open.  This password is required to send the SIGTERM and SIGKILL signals to the process running as another user.  (You can see the exact commands being issued by running SpaceFM from a terminal and observing its stdout output.)

<p>Paused and queued tasks may also be stopped.

<p>You can also stop a task by clicking the Stop button in the task's <a href="#tasks-dlg">popup dialog</a>.

<!-- # Pause -->
Pause temporarily halts a task, putting it into a <a href="#tasks-queue">paused state</a>.  It will remain in the paused state until you <a href="#tasks-menu-resume">Resume</a>, <a href="#tasks-menu-queue">Queue</a> or <a href="#tasks-menu-stop">Stop</a> it, and will never be automatically resumed or queued while paused.

<p>If the task is internal (such as copying files), SpaceFM will suspend the task thread.  Any files currently being read or written will remain open as long as the task is paused.

<p>If the task is an exec task, the process, <i>and all its child processes</i>, are sent a SIGSTOP signal.  This is similar to pressing Ctrl+S in a terminal while a command is running; it will often cause the process to temporarily halt execution.  In some cases, a process will not halt on a SIGSTOP signal, but the Task Manager will still list it as being in a 'paused' state until you <a href="#tasks-menu-resume">Resume</a> the task.

<p>If the command was run as another user, such as root, selecting Pause will cause a prompt for the user's password (or root's password depending on your configured su program) to open.  This password is required to send the SIGSTOP signal to the process running as another user.  (You can see the exact commands being issued by running SpaceFM from a terminal and observing its stdout output.)

<p>If you <a href="#designmode-designmenu-icon">change the menu icon</a> for Pause, the new icon will also be used as the 'paused' icon in the task list.

<p>You can also pause a task by clicking the Pause button in the task's <a href="#tasks-dlg">popup dialog</a>, left-clicking on the Status of a task in the Task Manager list, or by middle-clicking on a task in the list.

<!-- # Queue -->
Selecting Queue will change the selected task's state to <a href="#tasks-queue">queued</a>.  In this state, the task is halted, but will resume automatically when other tasks complete.

<p>Note that selecting Queue on a running task may seem to have no effect.  This is because the task may be queued, but then may automatically be removed from the queue and resumed by the Task Manager.  There is no way to force a task to stay in the queue (but you can <a href="#tasks-menu-pause">Pause</a> it).

<p>If you <a href="#designmode-designmenu-icon">change the menu icon</a> for Queue, the new icon will also be used as the 'queued' icon in the task list.

<p>You can also queue a task by clicking the Queue button in the task's <a href="#tasks-dlg">popup dialog</a>, left-clicking on the Status of a task in the Task Manager list, or by middle-clicking on a task in the list.

<!-- # Resume -->
Resume starts the selected task, changing its state to <a href="#tasks-queue">running</a>.  If it was in the queue it will be removed from the queue and resumed, regardless of how it conflicts with other running tasks.

<p>If the task is an exec task, the process, <i>and all its child processes</i>, are sent a SIGCONT signal.  This is similar to pressing Ctrl+Q in a terminal after a command has been halted with Ctrl+S.  If the original SIGSTOP halted the execution, SIGCONT should resume it.  If SIGSTOP did not halt execution, SIGCONT will generally have no effect, except that the Task Manager will now list the task as 'running'.

<p>If the command was run as another user, such as root, selecting Resume will cause a prompt for the user's password (or root's password depending on your configured su program) to open.  This password is required to send the SIGCONT signal to the process running as another user.  (You can see the exact commands being issued by running SpaceFM from a terminal and observing its stdout output.)

<p>You can also resume a task by clicking the Resume button in the task's <a href="#tasks-dlg">popup dialog</a>, left-clicking on the Status of a task in the Task Manager list, or by middle-clicking on a task in the list.  Tasks may also be resumed automatically by the Task Manager if they are queued.

<!-- # Show Output #showout -->
The Show Output menu item will only appear if a <a href="#pophandler">custom popup handler</a> has been set for the selected task.  Show Output will raise the normal popup dialog for the task, showing any stdout/stderr output.  This is particularly useful for debugging.

<p>Note that any custom menu items added directly after Show Output will also only appear for tasks with a custom popup handler.


<!-- # All Tasks #all -->
The All Tasks submenu is used to place all listed tasks into the selected state.  The Stop, Pause, Queue, and Resume menu items in this submenu have the same effect as detailed above, except that all tasks are affected.

<p>Selecting All Tasks|Queue will place all tasks in the 'queued' state momentarily, but note that one or more of the tasks may then be automatically removed from the queue and resumed.

<!-- # Show Manager #show -->
The Task Manager has two display modes: Show and Auto-Hide.  If option Show Manager is selected, the Task Manager is always visible, even when no tasks are running.  The size of the Task Manager may be adjusted by dragging the pane separator above it.

<p>This option is also available via the main menu bar's View|Tasks submenu.  You may also associate a key shortcut with it.

<!-- # Auto-Hide Manager #auto -->
If option Auto-Hide Manager is selected (the default), the Task Manager will become visible at the bottom of the window when any tasks are running, and will be hidden when the last task completes.  This is a window space-saving feature.

<p>Although there is no option to hide the Task Manager while tasks are listed, you can effectively hide it if desired by dragging the pane separator to the very bottom of the window.  However, if you do so you should enable option <a href="#tasks-menu-popall">View|Tasks|Popups|Popup All Tasks</a>, so that you are aware that tasks are running.  This combination of a zero-height Task Manager and Popup All Tasks makes SpaceFM behave like a conventional file manager, showing a popup dialog when performing a task, rather than showing a list of tasks.  You can also enable option <a href="#tasks-menu-poptop">View|Tasks|Popups|Stay On Top</a> if desired.

<!-- # Columns #col -->
The Columns submenu is used to select which columns are visible in the Task Manager, and to select a font for the Task Manager.  Each column provides information about the listed tasks.  The following columns are available:
<br><br>
<center><table width="95%" border=1 >
<tr>
	<th>Column</th>
	<th>Information</th>
</tr>
	<tr>
		<td>Count</td> <td>The number of items processed thus far</td>
	</tr><tr>
		<td>Folder</td>	<td>Directory containing current item</td>
	</tr><tr>
		<td>Item</td> <td>Filename of current item, or command name</td>
	</tr><tr>
		<td>To</td>	<td>The task's destination directory, eg where files are being copied <i>to</i></td>
	</tr><tr>
		<td>Progress</td> <td>A progress bar with percentage label</td>
	</tr><tr>
		<td>Total</td>	<td>The task's processed and total sizes</td>
	</tr><tr>
		<td>Started</td> <td>Time task was started</td>
	</tr><tr>
		<td>Elapsed</td>	<td>Elapsed running time of task</td>
	</tr><tr>
		<td>Current Speed</td>	<td>The current speed of the task (based on previous 2 second interval)</td>
	</tr><tr>
		<td>Current Remain</td> <td>Estimated time remaining based on Current Speed</td>
	</tr><tr>
		<td>Average Speed</td>	<td>The average speed of the task</td>
	</tr><tr>
		<td>Average Remain</td>	<td>Estimated time remaining based on Average Speed</td>
	</tr>
</table></center>

<p>The <i>current item</i> refers to the file currently being processed in the task (copied, etc).  For exec tasks, the Item column shows the name of the command in parentheses.

<p>The Status column, which shows the task icon, current state (queued or paused) and task action (copying, moving, etc.), is not included in the Columns submenu because its visibility not optional.

<p>The Reorder menu item shows a reminder: "To change the order of the columns, drag the column header to the desired location."

<p>The Font menu item allows you to set a font for the Task Manager's list columns.  Narrow fonts work well.

<p>Note:  The Columns submenu, and other Task Manager options, can also be found in the main menu bar's View|Tasks submenu.


<!-- # Popups|Popup All Tasks #popall -->
The Popups submenu is used to configure the Task Manager's behavior for opening <a href="#tasks-dlg">popup dialogs</a>.  If option Popup All Tasks is checked, a popup dialog will automatically open for any task which runs for longer than about one half second.  If the task finishes successfully, the popup will automatically close.  If errors occur, it will remain open for you to view the error messages.

<p>If option Popup All Tasks is unchecked, a popup dialog will open for an internal task only if an error occurs.  For custom commands, the popup behavior will depend on the command's <a href="#designmode-command-popup">popup settings</a>.  Note that if Popup All Tasks is checked, this overrides the command's popup settings.

<p>Popup All Tasks makes SpaceFM behave like a conventional file manager with regard to progress dialogs.  If the option is enabled, it is also feasible to effectively hide the Task Manager by dragging the pane separator to the very bottom of the window when unneeded.  You will still be aware of tasks running due to the popups.  Option <a href="#tasks-menu-poptop">Stay On Top</a> also works well with this approach.

<!-- # Popups|Stay On Top #poptop -->
If option Stay On Top is checked, any task's <a href="#tasks-dlg">popup dialog</a>, whether opened automatically or manually, will stay on top of the SpaceFM window.  However, you can still click on visible portions of the main window.  Changing this setting has no effect on dialogs which are already open.

<p>If unchecked, popup dialogs may be placed beneath the main window.

<!-- # Popups|Above Others #popabove -->
If option Above Others is checked, any task's <a href="#tasks-dlg">popup dialog</a> will be kept above all other windows when initially shown.  Note that some window managers do not support keeping windows above others, and your window manager settings may override this behavior.

<!-- # Popups|All Workspaces #popstick -->
If option All Workspaces is checked, any task's <a href="#tasks-dlg">popup dialog</a> will appear on all workspaces/desktops (will be set as sticky) when initially shown.  Note that some window managers do not support sticking windows, and your window manager settings may override this behavior.

<!-- # Popups|Detailed Stats #popdet -->
Detailed Stats affects how task stats are displayed in the 'Progress:' line of <a href="#tasks-dlg">popup dialogs</a> (seen in internal task dialogs only).

<p>If unchecked, a brief stats line is shown.  For example:
<blockquote>Progress: 204 M / 350 M  (26 M/s)  :05 remaining</blockquote>

In the above example, 204 MB of 350 MB has been processed at an average speed of 26 MB/s.  The estimated time remaining until the task finishes is 5 seconds.

<p>If option Detailed Stats is checked, more detailed stats are shown.  For example:
<blockquote>Progress: #1 (204 M / 350 M) [:08] @cur 31 M/s (:06) @avg 26 M/s (:05)</blockquote>

The additional stats include the item count (#1), the elapsed running time of the task (8 seconds), the current speed of the task (31 M/s), and the estimated time remaining at the current speed (6 seconds).

The <i>current speed</i> is measured based on the speed over the previous two second interval, whereas the average speed is based on the entire time the task has been running.  The current speed is a more accurate measure of what is happening right now, and will fluctuate more, while the average speed is a better measure of the overall performance.  The time remaining estimate based on the current speed shows how long the task will continue <i>if it continues at the current speed</i>.  The time remaining estimate based on the average speed tends to be a more accurate estimate in general.

<p>The information shown in the 'Progress:' line will match the information shown in the corresponding <a href="#tasks-menu-col">Task Manager columns</a>.

<!-- # Popups|Overwrite Option #popover -->
If Overwrite Option is checked, the popup dialogs for internal tasks will show a drop-down list which displays and allows you to change the overwrite mode of the task.  The list is not shown for exec tasks.  For more information see <a href="#tasks-dlg">Popup Dialog</a>.

<!-- # Popups|Error Option #poperropt -->
If Error Option is checked, the popup dialogs for internal tasks will show a drop-down list which displays and allows you to change the error handling mode of the task.  The list is not shown for exec tasks.  For more information see <a href="#tasks-dlg">Popup Dialog</a>.

<!-- # Popups|Font #popfont -->
The Font menu item allows you to set a font to be used in the output monitor of <a href="#tasks-dlg">popup dialogs</a>.  For example, you might choose a fixed width font to make the monitor look more like a terminal.

<p>This font may also be set by right-clicking on the output monitor of any task's popup dialog and selecting Font from the context menu.

<p>The dialog font you select will be used for new dialogs only; currently open dialogs will not be affected.  (You can close a dialog and re-open it to see the change.)

<!-- # Errors #poperr -->
The Errors submenu contains a set of radio options which control how errors in internal tasks (such as copy and move) are handled by default.  (These options have no effect on exec tasks such as custom commands.)

<p>If option <b>Stop If First</b> is selected (the default), the task will be stopped by the Task Manager if an error occurs AND that error is encountered before the task has successfully processed one file.  If an error occurs on later files in the task, the Task Manager will open a <a href="#tasks-dlg">popup dialog</a> to show the error, but subsequent actions in the task will continue to run.  For example, if there are more files to be copied, SpaceFM will attempt to copy them despite any errors on previous files.

<p>Stop If First is provided as a convenience option.  Usually if the first action of a task fails, the rest of the task will fail as well, so it might as well be stopped rather than producing a long list of errors for every file in the task.

<p>If option <b>Stop On Any</b> is instead selected, the Task Manager will stop if any error is encountered in the task, regardless of whether the error occurs on the first or later actions.

<p>If option <b>Continue</b> is selected, the Task Manager will never stop an internal task due to errors.  It will present the popup dialog on each error, and will list the errors in the output monitor, but subsequent actions in the task will continue.  For example, if a set of files is being copied, and only one file in the middle produces a copy error, all the other files will still be copied.  The popup dialog will show the error(s) for the file(s) which failed.

<p>Continue is especially useful when copying large sets of files.  If the task stops on errors, you might start the task and leave the computer, only to return to find that only a few files were copied before a single error stopped the entire task.  If the task continues on errors, you'll return to find all the files copied except those with errors.  You can then correct the problem files without having to restart and wait for the entire task again.

<p>You can also change the error mode on a per task basis if <a href="#tasks-menu-poperropt">View|Tasks|Popups|Error Option</a> is checked.


<!-- # Queue|Queue New Tasks #new -->
If option Queue New Tasks is checked (the default), new internal tasks are queued instead of being run immediately.  (exec tasks such as custom commands are never queued automatically.)  The Task Manager will then automatically resume the task when other tasks finish.  When you start new tasks while other tasks are still running, Queue New Tasks improves performance by not running all the tasks simultaneously (though some tasks may be run concurrently, depending on option <a href="#tasks-menu-smart">Smart Queue</a>).

<p>If unchecked, new tasks are always run immediately, even if other tasks are already running, and the Task Manager will never automatically queue any task.

<p>Regardless of how Queue New Tasks is set, you can always manually <a href="#tasks-menu-queue">Queue</a>, <a href="#tasks-menu-pause">Pause</a> or <a href="#tasks-menu-resume">Resume</a> any task.

<!-- # Queue|Smart Queue #smart -->
The Smart Queue option determines under what conditions the Task Manager will remove a task from the queue and resume it.  If UNchecked, the queue is simple - only one internal task is run at a time, and other tasks are queued.  (exec tasks such as custom commands are always run regardless of option Smart Queue.)  When a task finishes, the next task is removed from the queue and resumed.  If you always want SpaceFM to do only one file operation at a time, uncheck option Smart Queue.  However, this may be less efficient.

<p>If option Smart Queue is checked (the default), the Task Manager is more sophisticated in its handling of the queue to improve both performance and convenience.  In general, tasks will <i>not</i> be run concurrently, but the following exceptions may be made if Smart Queue is checked:

<p><b>Different Disks Exception</b><br>
If two or more tasks involve files on mutually exclusive disks (parent devices), the Task Manager will run them concurrently.

<p>To determine what devices a task involves, SpaceFM makes a list of all devices (and their parent devices, if the device is a partition) holding every file in the task, as well as the device of the destination directory, if applicable.  If any devices in this list are the same as the devices in another task's devices list, the two tasks conflict and will not be run concurrently.  Note that if the files of two tasks are located on different partitions on the same disk, they will conflict, and only one of the tasks will run.  Note that <i>all</i> of the devices of the task are examined when a queue decision is made, not just the device of the file currently in use by the task.

<p>The reason for this exception is that if two tasks involve mutually exclusive disks, there is usually much less of a performance loss by running them together.  On the other hand, if two tasks share files on the same disk, running them together may cause excessive drive seeking as different files are concurrently read and written.  Thus no exception is made for such tasks, and only one is resumed at a time.

<p><b>Size Exceptions</b><br>
Often while copying a set of large files, you may want to perform a quick operation on a set of small files.  Because the latter task is brief, it is reasonably efficient to allow it to run concurrently.  This way you don't have to wait for the longer task to finish before your quick task is run.

<p>When a task involves copying or moving a set of files less than 10 MB in total size, an exception is made which allows the task to run immediately, even if other tasks are running on the same devices.  An exception is also made when a task involves deleting a set of files less than 5 GB in total size.  This allows small tasks to run immediately.

<p><b>Functional Exceptions</b><br>
Internal tasks involving creating links, and changing file permissions or ownership are typically very fast as little data is written to disk.  Thus an exception is always made for these task types - they are run immediately. 

<br>
<p>Also note that you can always manually <a href="#tasks-menu-queue">Queue</a>, <a href="#tasks-menu-pause">Pause</a> or <a href="#tasks-menu-resume">Resume</a> any task, regardless of the Task Manager's queue settings.  For example, if you want a task to run immediately even though the Task Manager made no exception for it, you can <a href="#tasks-menu-resume">Resume</a> it yourself.

<p><b>HAL NOTE:</b>:  If you are using a copy of SpaceFM built with configure option --enable-hal, or a HAL-based SpaceFM package, option Smart Queue will be unavailable.

<!-- # Queue|Pause On Error #qpause -->
If option Pause On Error is checked, when an error occurs in any running task, all queued tasks will be paused.  Tasks which are already running will not be paused.  The task in which the error occurs may continue running as well, depending on its <a href="#tasks-menu-poperr">error mode</a>.

<p>The paused tasks will not resume until you manually resume them.

<p>Pause On Error is something of a paranoia setting - it ensures that if an error occurs, later tasks (which may depend on files in the task with errors) are suspended until you can examine the problem.

<!-- # Custom Menus #cust -->
As with most menus, it is also possible to add your own custom menu items and submenus to the Task Manager's context menu.  This allows you to add commands which can control or interact with running tasks.

<p>There are several <a href="#exvar">provided bash variables</a> which your commands can use to get information about the currently selected task:
<pre>
    "fm_task_type"            currently SELECTED task type (eg 'run','copy')
    "fm_task_name"            selected task name (custom menu item name)
    "fm_task_pwd"             selected task working directory ( same as %t )
    "fm_task_pid"             selected task pid               ( same as %p )
    "fm_task_command"         selected task command
</pre>

Note that the PID of the task refers to the initial process started by SpaceFM.  The actual process you want to control may be a child of this PID.

<p>For example, to add a custom command which opens the working directory of the currently selected task, use this command line:
<pre>    spacefm "$fm_task_pwd"</pre>


<!-- @Tasks @Popup Dialog #dlg -->
<p>A single left-click on a task listed in the <a href="#tasks-man">Task Manager</a> will open a popup dialog showing stats, a progress bar, and an output monitor.  Popup dialogs may also be automatically shown when errors occur, if option <a href="#tasks-menu-popall">View|Tasks|Popups|Popup All Tasks</a> is checked, or based on a custom command's <a href="#designmode-command-popup">popup settings</a>.  The popup dialog's relationship to other windows may be controlled with options <a href="#tasks-menu-poptop">View|Tasks|Popups|Stay On Top</a>, <a href="#tasks-menu-popabove">Above Others</a>, and <a href="#tasks-menu-popstick">All Workspaces</a>.

<p><b>For internal tasks</b>, the popup dialog will show the task's job ("Copy", etc), the current file being processed, the destination directory, brief or detailed <a href="#tasks-menu-popdet">stats</a>, the status of the task ("Paused", etc), a progress bar, an output monitor used to show the details of any errors which have occured, and overwrite and error mode controls.

<p>If <a href="#tasks-menu-popover">View|Tasks|Popups|Overwrite Option</a> is checked and the task is internal, the popup dialog will show a drop-down list which displays and allows you to change the overwrite mode of the task (what happens when a file being copied already exists):  <b>Ask</b> (prompt to rename, overwrite, or skip each file), <b>Overwrite All</b> (overwrite all files), <b>Skip All</b> (never overwrite files), or <b>Auto Rename</b> (assign a unique filename).  Clicking the Overwrite All, Skip All, or Auto Rename All button in an overwrite query dialog will also change the overwrite mode.  Note that the overwrite mode you set only applies to future file conflicts in the current task.

<p>If <a href="#tasks-menu-poperropt">View|Tasks|Popups|Error Option</a> is checked and the task is internal, the popup dialog will show a drop-down list which displays and allows you to change the error mode of the task:  <b>Stop If Error First</b>,<b> Stop On Any Error</b>, or <b>Continue</b>.  When the task first starts, the error mode will match the default set in <a href="#tasks-menu-poperr">View|Tasks|Errors</a>.  If you then change the error mode, it will apply to the current task only.

<p><b>For exec tasks</b>, the popup dialog will show the title of the command being run, the task's status, a pulsing progress bar, and an output monitor showing any output from the command.  The output monitor is designed to display text output to be used for monitoring the output of commands as they run, or to display a final result.  However, the output monitor is not a terminal and does not allow you to enter input.  If your command requires interaction, you will need to enable <a href="#designmode-command-terminal">Run In Terminal</a> instead.  Custom commands can also set a <a href="#pophandler">custom popup handler</a> to replace the normal popup dialog.

<p>To close the dialog, press the Close button or close the window.  You can always re-open the dialog by clicking on the task in the Task Manager.

<p>To permanently stop a task, click the Stop button.  This is equivalent to selecting <a href="#tasks-menu-stop">Stop</a> in the Task Manager menu.

<p>The third button in the dialog will change depending on the <a href="#tasks-menu-queue">state</a> of the task.  If the task is running, the button will be a Pause button; if the task is paused, the button will become a Queue button; and if the task is queued, the button will become a Resume button.  Pressing this button is equivalent to selecting <a href="#tasks-menu-pause">Pause</a>, <a href="#tasks-menu-queue">Queue</a>, or <a href="#tasks-menu-resume">Resume</a> in the Task Manager's context menu.



<!-- @Design Mode @Introduction -->

<p>SpaceFM's Design Mode allows you to change the name, shortcut key and icon of menu and toolbar items, access help for a menu item's function, and set menu items to be disabled or hidden based on your context rules.  In addition, you may add, copy, and move custom menu items to any position in most menus, and save your custom menu items as plugins.  All of this is controlled from the <i>Design Menu</i>.

<p>To open the Design Menu, simply right-click on a menu item.  The Design Menu is available for most menus in SpaceFM, including in the right-click menu of the desktop.

<p>To open the Design Menu using a shortcut key, press F2 while a menu item is highlighted.  To open the Design Menu for a submenu, <b>first close the submenu</b> (by clicking on it), then right-click on the submenu name.  Or, press F2 while the submenu is highlighted.

<p>Although you cannot right-click directly on toolbar items, Design Mode can be used to customise toolbars via their config menus, as detailed in the <a href="#designmode-toolbars">Toolbars section</a>.

<p>While Design Mode works in almost all menus, a good place to practice is the Tools menu, which is reserved for your custom menu items.

<p>When working with Design Mode, it is important to distinguish between two types of menu items: built-in and custom.  Built-in items, such as Rename on the file list context menu, are part of the SpaceFM program, whereas custom items are items you have added.  Design Mode can be used on both types of items, but in different ways.  For example, custom items can be removed, while built-in items cannot (although they can be hidden).  You will note that some of the Design Menu's functions will be disabled or enabled depending on the type of menu item.

<p>Custom menu items in SpaceFM are like word processor macros - they allow you to automate tasks.  You might create a quick custom item just for today's use and delete it when you're done, while other items may become a regular part of your file manager use.

<p>Custom menu items come in several varieties: a Bookmark (which opens a folder, group of folders, URLs, or mounts a device), an Application (which opens an application), a Command (which runs a program or command line), a Separator (a line separating items in a menu), and a Submenu (a menu containing custom items).  The Design Menu allows you to quickly create, move, copy, and remove custom items.


<!-- @Design Mode @Design Menu -->

<p>When you right-click on a menu item, or press F2 while a menu item is highlighted, you will be presented with a menu which gives you extensive control over how the item is displayed and performs.

<p>TIP: For help with a menu item in the Design Menu itself, highlight the Design Menu item and press F1.

<!-- # Show #show -->
The Show item will only be visible in the Design Menu when it is opened from a <a href="#designmode-toolbars">toolbar config menu</a>.  Checking the Show option will show this item in the toolbar, and unchecking it will hide it.

<p>When a toolbar item is shown, an asterisk will appear next to its name in the toolbar config menu.

<!-- # Cut -->
The next items on the Design Menu, including Cut, Copy, and Paste, allow you to move and copy custom menu items.  Menu items are cut, copied, and pasted in a similar way to how you cut, copy, and paste files or text, except that instead of the main clipboard, the design clipboard is used.

<p>Cut cuts the current menu item onto the design clipboard.  This will not affect the contents of your main (text &amp; files) clipboard.  You will not observe any change in the menu after cutting an item - until you paste it.  You cannot cut built-in menu items, only custom ones.  You can cut and copy submenus, which copies all the items within the submenu recursively.

<p>You can also cut a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press Ctrl+X, <b>or</b> use the mouse shortcut Alt + Left-or-Right-Click.

<!-- # Copy -->
Similarly, Copy copies the current menu item onto the design clipboard.  Again, you will not observe any immediate change to the menu after copying an item.  You cannot copy built-in menu items, only custom ones.

<p>You can also copy a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press Ctrl+C, <b>or</b> use the mouse shortcut Ctrl + Left-or-Right-Click.

<!-- # Paste -->
If you previously cut or copied a menu item onto the design clipboard, the Paste item in the Design Menu will be enabled for use.  Determine where in what menu you want to paste the item, right-click on an existing item to open the Design Menu, and select Paste.  The menu item will be copied or moved from its original menu location and will be placed <i>after</i> the item you clicked on.

<p>For example, to move a custom menu item named 'Test' from the Tools menu to the file list's context menu:  Open the Tools menu and right-click on 'Test' to open the Design Menu.  Select Cut.  Now right-click on the file list and right-click on a menu item, such as 'Rename'.  Select Paste in the Design Menu.  Right-click again on the file list and you will see your 'Test' command has been moved from the Tools menu and has been placed immediately after the 'Rename' item.

<p>When copying a custom menu item, note that everything contained in the item is copied, including any <a href="#designmode-command-script">command script</a>, extra files you added to the <a href="#designmode-command-browse-files">command</a> or <a href="#designmode-command-browse-data">data</a> directories, settings, etc.

<p>You can also copy plugins from the Plugins menu (although you cannot cut them).  When a plugin, which is root-installed and -protected, is copied, the copy is no longer protected by root.  The copy is now a custom menu item which you can alter in any way.  Copying a plugin provides a means of changing and customising it.  It can also then be exported and reinstalled as a plugin.  See the <a href="#plugins">Plugins</a> section for details.

<p>Paste, Cut, and Copy can also be used on the separators between menu items.  To move a custom item to directly after a separator, copy the item to the Design Menu, right-click on a separator, and select Paste.  You can also cut, copy, and paste the separators themselves, providing they are not built-in.

<p>You can also paste a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press Ctrl+V, <b>or</b> use the mouse shortcut Shift + Left-or-Right-Click.

<!-- # Remove -->
Remove is used to remove any custom menu item.  It cannot be used on built-in items.  When used on a <a href="#plugins">plugin</a>, Remove will uninstall the plugin (root password required).

<p>Unless you have unchecked option <i>View|Preferences|Interface|Confirm delete/remove</i>, you will be presented with a confirmation dialog before the item is removed.

<p>IMPORTANT:  When a custom menu item is removed, all files and settings are deleted, including any extra files you added to the <a href="#designmode-command-browse-files">command directory</a>, any files stored in the command's <a href="#designmode-command-browse-data">data directory</a>, and the <a href="#designmode-command-script">command script</a>.  When a plugin is uninstalled using Remove, the plugin is removed for all users, and all settings, files and <a href="#plugins-creationandfiles-data">plugin-data</a> for the plugin are deleted.

<p>WHEN REMOVING A SUBMENU, all commands and submenus contained within it are deleted as described above.

<p>Note that a submenu in SpaceFM can never be empty.  As a result, if you remove the last item from a submenu, a new custom menu item named "New Command" will automatically be added to it.

<p>You can also remove a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press the Delete key, <b>or</b> use the mouse shortcut Ctrl + Shift + Middle-Click.

<!-- # Export -->
The Export item, which is only available for custom menu items, will open a save dialog, allowing you to save the custom item into a plugin file.  This is how plugins are created for SpaceFM - you create a custom menu item, then simply export it.

<p>Once your item has been exported to a plugin file, the file can then be used to import the item back into either the Plugins menu or another menu, or can be shared with other users of SpaceFM.  Exporting also provides a mechanism for backing up custom items - the plugin file acts as a backup copy of your item which can always be imported into any SpaceFM session.

<p>When using export on a plugin, a new plugin file is created - generally this creates a copy of the original plugin (unless you modified the installed plugin files as root).

<p>You can also export a group of custom items into one plugin file by exporting a custom submenu, which means the plugin file will contain all items and submenus contained in the submenu.  This provides way to share multiple related plugins in a single plugin file.

<p>For more information on plugins, please see the <a href="#plugins">Plugins</a> section.

<!-- # New|Bookmark #bookmark -->
The New submenu of the Design Menu allows you to add a new custom menu item of a particular type: Bookmark, Application, Command, Submenu, or Separator.

<p>New|Bookmark adds a new custom menu item of type Bookmark after the current menu item.  You will be prompted to select a single target folder, and the Bookmark menu item will be added.  To make further changes to your Bookmark item, right-click on it and select Properties.  A Bookmark item's <a href="#designmode-props-target">target</a> may be a single folder to be opened when you activate the item, or it can be a semicolon-separated list of target folders, URLs, or devices.

<p>Bookmarks in SpaceFM may be placed into any menu, not just the <a href="#gui-book">Bookmarks menu</a>.

<!-- # New|Application #app -->
New|Application adds a new custom menu item of type Application after the current menu item.  Initially, you will be prompted to select an application from a list of applications installed on your system, and the Application menu item will be added.  To make further changes to your Application item, right-click on it and select Properties.  An Application item's <a href="#designmode-props-target">target</a> may be a .desktop file or an executable file, as detailed in <a href="#designmode-props">Menu Item Properties</a>.

<!-- # New|Command #new -->
New|Command adds a new custom menu item of type Command after the current menu item.  You will be prompted to enter a name for the menu item.  Next, the <a href="#designmode-props">Menu Item Properties</a> dialog will open to the <a href="#designmode-props-command">Command page</a>, allowing you to enter your command line(s) to be run, or to edit a command script.

<p>The command line accepts anything you would normally enter in a bash command line.  It can be as simple as a program's name you want to run when this menu item is selected, or may include multiple lines and variables.  For more information, please see the <a href="#designmode-props-command">Command page</a>.

<p>For example, right-click on a menu item and select New|Command.  Enter 'Current Time' for the menu item name.  For the command line, enter:
<pre>    date</pre>

<p>And click OK.  When you click the new 'Current Time' menu item, a dialog will open showing you the current date and time.

<p>You can also add a new Command menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item where you want to insert the new Command item, and press the Insert key, <b>or</b> use the mouse shortcut Ctrl + Shift + Left-or-Right-Click.

<!-- # New|Submenu #submenu -->
New|Submenu adds a new submenu into the menu after the current menu item.  You will be prompted for the new submenu's name.  Because a submenu in SpaceFM can never be empty, a new Command item named "New Command" will automatically be added to the new submenu.

<!-- # New|Separator #separator -->
New|Separator adds a new separator line into the menu after the current menu item.  Design Mode works on separators too - right-click on a separator to open its Design Menu, which allows you to remove it, change its context rules, or paste items after it.

<!-- # New|Import #import -->
The New|Import submenu allows you to import a plugin file or URL, inserting it as a new menu item after the current menu item.  This is similar to using <a href="#plugins-import">Plugins|Import</a>, except that the new menu item is inserted immediately rather than copied to the design clipboard.

<p>When imported into other menus, a plugin loses root protection and becomes a normal custom menu item.


<!-- # Help -->
Help opens contextual help for a menu item.  For built-in items, the SpaceFM user's manual will be opened in your browser.  If no help is currently available, Help will be disabled.  [Note: Because the user's manual is still incomplete, not all menu items will have help available.]

<p>Your browser may be customised in Help|Options|Browser, and a custom location for the user's manual can be set in Help|Options|Manual Location.

<p>For custom menu items, including plugins, Help will open the plain text README file for the item in your text editor.  If no README file exists for a custom menu item, selecting Help will create one for you to edit.  This file may also be named 'README.mkd' or 'README.txt'.

<p>You can also open help for a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press F1, <b>or</b> use the mouse shortcut Alt + Middle-Click.  F1 may also be used from within the Design Menu itself to show help for a Design Menu item.

<!-- # Key Shortcut #key -->
Key Shortcut opens a dialog which allows you to bind any shortcut key to the current menu item, and to change or unset an existing shortcut key.  When you select Key Shortcut, a dialog will open asking you to press your key combination (for example Ctrl+G), and the keycode will be displayed.  If the key combination is already in use, you will be told what function the key is currently assigned to and be given the option to replace the current assignment.  Once you have pressed the desired key combination, click the Set button.  Or, to unset the current key assignment, leaving no key assigned to this menu item, click the Unset button.  The Key Shortcut option can be used on built-in and custom items, but cannot be used on a submenu.

<p>After you have set a key combination, when you reopen the menu the new key shortcut will be displayed in the menu.

<p><b>TIP: To use only the keyboard in the Set Key dialog</b>, press a key combination and then press Enter to click the Set button.  Or, to click Unset, press the Escape key twice.  To cancel, simply close the dialog (usually Alt-F4).

<p>NOTE: Due to SpaceFM's literal use of keycodes, <b>turning Caps Lock on or changing your keyboard layout</b> may cause some key shortcuts to not respond.  For example, pressing Ctrl+C with Caps Lock on will <i>not</i> activate 'Copy' because the 'C' key returns a different code than with Caps Lock off.

<p>You can also change the key for a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press Ctrl+K, <b>or</b> use the mouse shortcut Ctrl + Middle-Click.

<!-- # Edit Command #cedit -->
Appearing only for custom menu items of type <a href="#designmode-designmenu-new">Command</a> where the command is set to a command line, Edit Command opens the Menu Item Properties dialog to the Command page.

<p>You can also edit an item's command line using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press F4 or Ctrl+E, <b>or</b> use the mouse shortcut Middle-Click.

<!-- # Edit Script #edit -->
Appearing only for custom menu items of type <a href="#designmode-designmenu-new">Command</a> where the command is set to a script, Edit Script opens the command script in your configured editor.

<p>You can also edit an item's script using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press F4 or Ctrl+E, <b>or</b> use the mouse shortcut Middle-Click.

<!-- # Properties #prop -->
Properties opens the <a href="#designmode-props">Menu Item Properties</a> dialog for the current menu item, allowing you to change properties for the item as detailed in Menu Item Properties below.

<p>You can also open Properties for a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu. Highlight the menu item and press F3, or use the mouse shortcut Ctrl + Alt + Middle-Click.




<!-- @Design Mode @Properties #props -->
<p>The Menu Item Properties dialog allows you to view and change the properties of built-in or custom menu items.  To open the dialog, right-click on a menu item and select Properties, or highlight the menu item and press F3.

<!-- # Type -->
The Menu Item page of the <a href="#designmode-props">Menu Item Properties</a> dialog provides basic settings for the menu item.

<p>The Type drop-down list shows the current type of the menu item:  Built-In Command, <a href="#designmode-designmenu-bookmark">Bookmark</a>, <a href="#designmode-designmenu-app">Application</a>, <a href="#designmode-designmenu-new">Command</a>, <a href="#designmode-designmenu-submenu">Submenu</a>, or <a href="#designmode-designmenu-separator">Separator.</a>  If the type is Bookmark, Application or Command, you can change the type by selecting another type from the list.

<p>A menu item's type determines what properties you can view and change, and how the menu item appears and behaves.

<!-- # Name -->
The Name entry allows you to change a menu item's name as it appears in the menu.  Precede a character with an underscore (_) to underline that character as a shortcut key (mnemonic) if desired.  [Note: In GTK >= 3.10, you must press the Alt key to see the mnemonics underlined.]  You can change the name of both built-in and custom menu items.  You cannot change the name of plugins in the Plugins menu.

<p>For menu items of type Bookmark, the Name entry may be left empty, in which case the target of the Bookmark will be displayed as its menu item name.

<p>For menu items of type Application, the Name entry may also be left empty, in which case the application's name (derived from the .desktop file's Name= key), or the executable's name will be displayed as its menu item name.

<!-- # Key -->
The Key button shows the current key shortcut set for this menu item, if any.  Clicking the button will open the Set Key dialog which allows you to set a key shortcut.  Clicking the button is equivalent to selecting <a href="#designmode-designmenu-key">Key Shortcut</a> directly from the Design Menu.

<p>You can also change the key for a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press Ctrl+K, <b>or</b> use the mouse shortcut Ctrl + Middle-Click.

<!-- # Icon -->
The Icon entry allows you to set or change an icon for a menu item.  Enter an icon name such as 'folder', a stock item name such as 'GTK_STOCK_OPEN' or 'gtk-open', or an absolute path to an icon file.

<p><b>For best results, use an icon name</b> or stock name so that the icon can be automatically sized.  When using an absolute path, the icon may not be sized correctly.  Due to various issues, not all icons may work.  If an icon fails to load, you will see a broken icon image instead.  If successful, the icon will appear in the menu next to the menu item, and will also be used in the task list when a command is run.

<p>To remove an icon, simply clear the text box where the icon name is entered and click OK.  (For plugins, clearing the box will show the default icon for the plugin, if any.)

<p>To browse the available icons on your system, open /usr/share/icons/.  When you enter an icon name, GTK will search there for an appropriate icon, and will also search ~/.icons/ and ~/.local/share/icons/.

<p>For menu items of type Bookmark, if no icon is specified, the default icon is used, set by right-clicking on the Bookmarks side pane and selecting <a href="#gui-book-side">Settings|Bookmark Icon</a>.

<p>For menu items of type Application, if no icon is specified, the application's icon (derived from the .desktop file's Icon= key) will be displayed as the menu item icon.

<p>You can also change the icon for a menu item using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the <a href="#designmode-props">Menu Item Properties</a> dialog.  Highlight the menu item and press Ctrl+I, <b>or</b> use the mouse shortcut Shift + Middle-Click.

<!-- # Target -->
The Target(s) entry and associated Browse button will only appear if a menu item is of type <a href="#designmode-designmenu-bookmark">Bookmark</a> or <a href="#designmode-designmenu-app">Application</a>.  This entry allows you to control what is opened when the menu item is activated.

<p><b>Bookmark Targets</b>
<br>For Bookmark menu items, the Targets list may contain a single folder to be opened, or may contain a semicolon-separated list of folders, URLs, and/or devices.  For example:
<pre>    /etc; /usr/bin; ftp://mirrors.kernel.org; /dev/sr0</pre>

When the above example is activated, four tabs will be opened: two containing /etc and /usr/bin; the ftp site will be mounted and opened in a third tab; and the disc in /dev/sr0 will be mounted and opened in the fourth.

<p>When the Targets list contains a single folder or URL, whether it is opened in a new tab or in the current tab is determined by the <a href="#gui-book-side">New Tab</a> setting for bookmarks, found by right-clicking on the Bookmarks side pane and selecting Settings.  If the Targets list contains multiple paths or URLs, each is opened in a new tab.

<p>Finally, the Targets list for a Bookmark may contain the path to a file, in which case the directory containing the file will be opened, and the file will be selected in the file list.  For example:
<pre>    /etc/fstab</pre>

Clicking the Browse button will allow you to select a folder which will be added to the Targets list.

Tip:  To prevent the Bookmarks side pane's <a href="#gui-book-side">Follow Dir</a> option selecting a particular bookmark automatically, prefix the targets with a semicolon and Follow Dir will ignore it (only the first target is used by Follow Dir).  For example:
<pre>    ;/etc</pre>

<p><b>Application Target</b>
<br>For Application menu items, the Target entry may contain the name of a .desktop file (spacefm.desktop), the full path of a .desktop file, the name of an executable file (binary or script, eg spacefm), or the full path of an executable file (/usr/bin/spacefm).

<p>When specifying an executable file, note that selected filenames will NOT be passed to the executable when it is run.  (To do so, use a menu item of type <a href="#designmode-designmenu-new">Command</a>.)  When specifying a .desktop file, what is passed to the command is determined by the substitution variables in the Exec= key of the .desktop file.

<p>When specifying a .desktop file, it is generally recommended to leave the Name and Icon fields empty so the .desktop file's values are used automatically.

<p>Clicking the Browse button will allow you to select an application from a list of applications installed on your system.

<p>NOTE:  When exporting a menu item, the target field will be exported with the plugin even if Bookmark or Application is no longer the selected menu item type.  Before distributing a plugin, be sure to open or extract the archive and examine all files in your text editor to be clear on what data you are sharing.


<!-- # Context -->
The Context page of the <a href="#designmode-props">Menu Item Properties</a> dialog allows you to set rules which determine when and how a menu item appears in the menu.  Context rules can be set for both built-in and custom items, including plugins and separators.  Context cannot be set for toolbar items.

<p>Context refers to the state of the entire file browser window or desktop when a menu is shown.  For example, the MIME type of the currently selected file is one subject of the context.  Another context subject is the filename of the selected file.  Another is any device that is currently selected in the <a href="#devices-list">Devices list</a>.  There are many subjects which can be used in context rules.

<p>By default, the top line of the context dialog reads "Show item if context matches any rule:", and is followed by an empty rule box.  When the rule box is empty, the item will always be shown regardless of context.

<p>You can change 'Show item if context matches any rule:' to 'Enable item if context matches any rule:'.  If the action is to 'Show', its opposite is to hide.  If the action is to 'Enable', then its opposite to disable.  Thus if we change the top line to read 'Enable item if context matches any rule:', then the menu item will be enabled or disabled depending on context, but will never be completely hidden from view in the menu.  Or, to reverse the logic, action can be set to 'Hide' or 'Disable' when any rule is matched.

<p>The 'matches any rules:' box can also be changed so that it requires all rules to be matched instead of just one.  This is like putting an AND between the rules, instead of OR.  Or you can reverse the matching logic by choosing one of the 'doesn't match' options.

<p><b>Composing Rules</b>
<br>Rather than using an arcane syntax, context rules are composed using words and phrases, which make the rules readable sentences.  To compose a new rule, use the Edit Rule box.  There are many context subjects available in the drop-down list, but "MIME Type" and "Filename" are generally the most useful.

<p>The box to the right of the subject allows you to choose a verb, or a relationship between the subject and its value.  In the case of "matches" or "doesn't match", wildcards may be used (eg "Filename matches *.jpg").  If the test pattern contains any uppercase characters, the test is case-sensitive.  For additional wildcard characters and pattern specifics, see <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13_01">IEEE Pattern Matching Notation</a>.

<p>The box below the subject and verb will contain the value to be used as a test.  You can enter custom text in this box or click the arrow at the right to select a common value.  Each subject chosen will have a different list of common values.

<p>Below the value box is a 'Value:' label, which may or may not show a value.  This label shows the subject's value in the <i>current context</i>.  When you opened the Design Menu, the file browser had a context - perhaps some files or a device were selected, the browser was in a particular directory, etc.  For example, if a file is selected when you open the properties dialog, and the subject is set to 'MIME Type', then the selected file's MIME type will appear next to 'Value:'.  If no file is selected, then 'Value:' will show nothing.  (Tip:  You can quickly copy a value into the value box by double-clicking it.)

<p>The context dialog will let you know the result of the current set of rules given the current context.  Below the rules box to the right, you will see a 'Current:' label.  For example if it reads "Current: Show", then for the current context and set of rules, this menu item will be shown in the menu.  If instead it reads "Current: Hide", then the menu item will be hidden from view for the current context - it will not appear in the menu.

<p><b>An Example Set Of Rules</b>
<br>As an example, we will add a rule which shows the current menu item when the selected file is an audio file.  Note that when determining the context, only the type and name of the <i>first</i> selected file is considered.  If multiple files are selected, this can be determined, but the type of each selected file cannot be individually tested.

<p>For this example, set the rule subject to 'MIME Type' and set the verb (the box to the right of subject) to 'begins with'.  Below these, choose 'audio/' from the drop-down list of common values.

<p>Now the words in the Edit Rule box should read 'MIME Type... begins with... audio/'.  To add this rule to the rule box above, click the Add button.  'MIME Type begins with audio/' will be added to the list of rules.  For this rule to be satisfied, the MIME type of the first selected file must begin with the text "audio/".  Thus a file of type "audio/mpeg" (an MP3 file), or of type "audio/x-wav" (a WAV file) would match this rule, but a file of type "video/x-msvideo" (an AVI video file) would not.  (You can see the MIME type of any file by right-clicking on it in the file list and selecting Properties|Info.)  In this example, our rule will only match the context if the first selected file is an audio file.

<p>Now set the top line to read 'Enable item if context matches any rule:'.  We now have a context rule set which reads 'Enable item if context matches any rule: MIME Type begins with audio/'.

<p>Click OK to accept this rule set.  Then select an audio file in the file browser's file list.  Open the menu where your item appears, and it will be enabled for use.  Next select another kind of file, such as a text or video file.  Open the menu again, and the menu item will be disabled.

<p>In order to open the Design Menu again for this menu item, you must first select an audio file (you cannot open the Design Menu on a disabled menu item).  Or you can temporarily check option <a href="#designmode-props-ignorecontext">Ignore Context</a> (see below) to access all menu items.

<p><b>Additional Features</b><br>
The context dialog includes a few more features for editing rules.  To remove a rule, click the rule, then click the Remove button.  If all rules are removed and you click OK, the item will be shown regardless of context.

<p>To change a rule in the list, click the rule, then edit the rule using the Edit Rule box.  When the rule is how you want it to appear, click the Apply button to update the rule in the list.

<p>The best way to learn to use the context rules is to practice with a file selected.  In this way you can use the 'Value:' and 'Current:' labels to see context values and observe the result of changing the rules.

<p>Some context subjects are boolean - they will equal 'true' or 'false' (these words must be in English even if the rest of the rule is translated).  For example, the rule subject 'Multiple Selected' will always equal 'true' or 'false', depending on whether more than one file is selected in the file list of the current panel.  Thus if your custom menu item is designed to work with only one selected file, you might set a context rule to disable it if the user has selected multiple files.

<p>Other context subjects, such as 'Panel Count', contain a number, and you can test whether they are equal to, less than, or greater than a value.  For example, the rule 'Panel Count is greater than 1' will only match if the user has multiple panels shown.

<p>As a more advanced use, it's also possible to use || (or) or &amp;&amp; (and) in the test value to provide a list of possibilities (use || or &amp;&amp;, but not both in the same rule).  For example, this rule:<br>
&nbsp;&nbsp;&nbsp;&nbsp;MIME Type begins with audio/ || video/

<p>causes two tests to be performed.  If the MIME Type begins with 'audio/' OR the MIME Type begins with 'video/', then the rule matches.  Likewise, the rule:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Device Properties contains dvd &amp;&amp; blank

<p>also causes two tests to be performed.  If the Device Properties value (which provides information about the currently selected device) contains the word 'dvd', AND it contains the word 'blank', then the rule matches.  This context rule would match if the currently selected device contained a blank DVD.

<p><b>Automatic Context</b>
<br>It is important to note that built-in menu items sometimes have an automatic context, which is evaluated before any rules you add.  For example, the file list's Paste menu item is disabled if the clipboard is empty.  No rule you add will cause it to be enabled in this case, although you can still add a rule to hide it.

<p>Custom menu items added directly after the Default menu item in the file list's Open context menu have an automatic pre-context - they only appear if the MIME type of the first selected file matches the MIME type when the custom item was added.  This provides an easy way to add an item with an automatic context based on MIME type, and may also be used to setup a <a href="#designmode-props-opener">file handler</a> (see below).

<p>Custom menu items added directly after <a href="#tasks-menu-showout">Show Output</a> in the Task Manager's context menu will also only appear for tasks with a custom popup handler.
    
<p>Also, custom submenus which are empty due to all of their children being hidden based on context are hidden automatically.

<p>Note:  Custom menu items when shown in the <a href="#gui-book-side">Bookmarks side pane</a> will not respond to Context rules, and will always be shown.

<p><a name="impcon"><b>Impossible Context</b></a>
<br>Note that it IS possible to set an impossible context for an item - a set of rules which will never match.  In this case the item will never be shown.  This can be used to permanently hide or disable an item you don't use.  This can also happen accidently, which is one reason why <a href="#designmode-props-ignorecontext">Ignore Context</a> (see below) is provided.  For example, the rule <b>Directory equals ""</b> will never match (because Directory is always set).

<!-- # Use As Handler For #opener -->
Visible only for non-toolbar Command or Application items, the '<i>If enabled, use as handler for</i>' drop-down list on the Context page is used to set this item as a default handler.  For example, if set to "files", and you open one or more files, if this item is shown and enabled based on its <a href="#designmode-props-context">context rules</a>, then this item will be run, rather than the default MIME application.  This option is used to define a file handler for specific file types (or based on any context rules).

<p>If set to 'files', note that <b>no files are passed to a command</b> on the command line.  You must use <a href="#exvar">variables</a> in your command line or script to pass files to it.  If the menu item is of type Application, what is passed will depend on the Exec= line of the application's .desktop file.

<p>If set to 'devices', clicking on a device in the Devices list will cause the item to be run rather than the applicable device handler.  Variables %v, "$fm_device", or other variables may be used in your command.

<p>If more than one item is set as a handler and each is enabled, multiple items will be run each time files or devices are opened.

<p>As noted above, custom menu items added directly after the Open|Default menu item have an automatic pre-context - they only appear if the MIME file type of the first selected file matches the MIME type when the custom item was added.  This provides an easy way to set a custom handler for a given MIME type.  Simply select a file of the desired type, right-click on it and add your custom item directly after the Open|Default menu item.  Next, select option '<i>use as handler for files</i>'.  Your custom item will be used to open files when the MIME type matches.  Or, you can set additional context rules to determine when your handler is used.

<p>'<i>Use as handler for</i>' currently has no effect on files or devices opened from the SpaceFM desktop.  Also, when imported or installed, plugins lose their 'Use as handler for' setting (by design - you can add it back after import if desired).

<p>Ignore Context (see below) has no effect on the handler being context-enabled - its context will be tested even if global option Ignore Context is checked.


<!-- # Ignore Context -->
The '<i>Ignore Context / Show All (global setting)</i>' option, if checked, causes all <a href="#designmode-props-context">context rules</a> to be ignored, and all menu items shown regardless of context.  This is a global setting - it disables context rules in all windows of the current instance.

<p>If you need to change the context of an item you have disabled or hidden, you can either select the appropriate file to create a context where the item is shown and enabled, or you can open the Menu Item Properties dialog for any other item and check option '<i>Ignore Context</i>'.  This will allow you to then access the Design Menu of all items and change their context rules.  When you are finished, you can uncheck option '<i>Ignore Context</i>'.

<p>Note that <i>Ignore Context</i> does not affect the automatic context of built-in items - for example, even with <i>Ignore Context</i> checked, the file list's Paste menu item will always be disabled if the clipboard is empty.
<br>

<!-- # Command -->
Shown only for menu items of type Command, the Command page of the <a href="#designmode-props">Menu Item Properties</a> dialog allows you to set command line(s) to be run by this menu item, or edit a command script, depending on which radio button is selected: Command Line or Script.

<p><b>Command Line</b>
<br>When Command Line is selected, the command is executed as one or more bash command lines.  At its simplest, the command line may simply be the name of a program to run, but any valid bash line may be used, as the command lines are inserted into a temporary bash script when run.

<p>You may use the following substitution variables in command lines:
<center><table width="70%">
	<tr>
		<td>%F</td> <td>selected files</td>
	</tr><tr>
		<td>%f</td> <td>first selected file</td>
	</tr><tr>
		<td>%N</td>	<td>selected filenames</td>
	</tr><tr>
		<td>%n</td> <td>first selected filename</td>
	</tr><tr>
		<td>%d</td>	<td>current directory</td>
	</tr><tr>
		<td>%v</td>	<td>selected device (eg /dev/sda1)</td>
	</tr><tr>
		<td>%m</td>	<td>device mount point (eg /media/dvd)</td>
	</tr><tr>
		<td>%l</td> <td>device label</td>
	</tr><tr>
		<td>%b</td>	<td>selected bookmark</td>
	</tr><tr>
		<td>%t</td>	<td>selected task directory</td>
	</tr><tr>
		<td>%p</td> <td>task pid</td>
	</tr><tr>
		<td>%a</td>	<td>menu item value</td>
	</tr>
</table></center>

<p>For example, to calculate the MD5 sum of all selected filenames, use this command line:
<pre>    md5sum %N</pre>

<p>Before your command is run, the substitution variables will be replaced with their current values.  Do NOT place quotes around substitution variables - they will be quoted automatically when required.

<p>Bash variables, described below, may also be used in command lines (bash variables SHOULD in general be "double quoted").

<p>To experiment with variables, use the echo command to simply print their values.  For example, the following command line will print the current directory:
<pre>    echo %d</pre>

<p>Command lines may also contain bash scripts containing multiple commands.  For example, this command line will print the current time, once per second, for ten seconds, then stop:
<pre>    while (( x < 10 )); do date; sleep 1; (( x++ )); done</pre>

<p>Environment variables can also be included.  For example, to run claws-mail using a custom DISPLAY variable in a command line:
<pre>    DISPLAY=:1 claws-mail</pre>

<p><b>Open In Editor</b>
<br>The Open In Editor button will examine the first part of the command line.  If the first part is a text file (a script), it will be opened in your editor.

<p>NOTE:  When exporting a Command menu item, the value of the command line will be exported with the plugin even if Command Line is no longer the selected command type, or if the menu item type is changed.  Before distributing a plugin, be sure to open or extract the archive and examine all files in your text editor to be clear on what data you are sharing.

<p><a name="designmode-command-script"><b>Command Script</b></a>
<br>When Script is selected on the Command page, a default bash script will be created for the command.  Similar to command lines, bash commands may be entered in the script, or open it in your editor and save it.  There is no need to organize your scripts, because you can always use <a href="#designmode-props">Properties</a> from the Design Menu to access the script of any Command menu item.

<p>At its simplest, a command script is simply a list of commands that could be entered in a terminal.  The script executes each command in sequence, allowing you to automate common command-line tasks.  You can also use tests and loops in scripts to make them more capable.  For more information on writing scripts, see the <a href="http://www.tldp.org/LDP/abs/html/index.html">Bash Scripting Guide</a>.

<p>Command scripts can also evolve into small, full-featured applications using <a href="#dialog">SpaceFM Dialog</a> to show custom dialogs from within the script, and <a href="#sockets">socket commands</a> to manipulate elements of the SpaceFM window.  Your script can also replace the default task <a  href="#tasks-dlg">popup dialog</a> by setting a <a href="#pophandler">custom popup handler</a>.

<p>The substitution variables used above in command lines may NOT be used in a command script.  Instead, bash variables are preloaded for your use (these variables may be used in command lines or a script).

<p><a name="exvar">When you select Script</a>, a <a href="#exvar">default bash script</a> is generated as shown below:
<pre>
#!/bin/bash
$fm_import    # import file manager variables (scroll down for info)
#
# Enter your commands here:     ( then save this file )



exit $?
# Example variables available for use: (imported by $fm_import)
# These variables represent the state of the file manager when command is run.
# These variables can also be used in command lines and in the <a href="#gui-pathbar-cmd">Path Bar</a>.

# "${fm_files[@]}"          selected files              ( same as %F )
# "$fm_file"                first selected file         ( same as %f )
# "${fm_files[2]}"          third selected file

# "${fm_filenames[@]}"      selected filenames          ( same as %N )
# "$fm_filename"            first selected filename     ( same as %n )

# "$fm_pwd"                 current directory           ( same as %d )
# "${fm_pwd_tab[4]}"        current directory of tab 4
# $fm_panel                 current panel number (1-4)
# $fm_tab                   current tab number

# "${fm_panel3_files[@]}"   selected files in panel 3
# "${fm_pwd_panel[3]}"      current directory in panel 3
# "${fm_pwd_panel3_tab[2]}" current directory in panel 3 tab 2
# ${fm_tab_panel[3]}        current tab number in panel 3

# "${fm_desktop_files[@]}"  selected files on desktop (when run from desktop)
# "$fm_desktop_pwd"         desktop directory (eg '/home/user/Desktop')

# "$fm_device"              selected device (eg /dev/sr0)  ( same as %v )
# "$fm_device_udi"          device ID
# "$fm_device_mount_point"  device mount point if mounted (eg /media/dvd) (%m)
# "$fm_device_label"        device volume label            ( same as %l )
# "$fm_device_fstype"       device fs_type (eg vfat)
# "$fm_device_size"         device volume size in bytes
# "$fm_device_display_name" device display name
# "$fm_device_icon"         icon currently shown for this device
# $fm_device_is_mounted     device is mounted (0=no or 1=yes)
# $fm_device_is_optical     device is an optical drive (0 or 1)
# $fm_device_is_table       a partition table (usually a whole device)
# $fm_device_is_floppy      device is a floppy drive (0 or 1)
# $fm_device_is_removable   device appears to be removable (0 or 1)
# $fm_device_is_audiocd     optical device contains an audio CD (0 or 1)
# $fm_device_is_dvd         optical device contains a DVD (0 or 1)
# $fm_device_is_blank       device contains blank media (0 or 1)
# $fm_device_is_mountable   device APPEARS to be mountable (0 or 1)
# $fm_device_nopolicy       policy_noauto set (no automount) (0 or 1)

# "$fm_panel3_device"       panel 3 selected device (eg /dev/sdd1)
# "$fm_panel3_device_udi"   panel 3 device ID
# ...                       (all these are the same as above for each panel)

# "fm_bookmark"             selected bookmark directory     ( same as %b )
# "fm_panel3_bookmark"      panel 3 selected bookmark directory

# "fm_task_type"            currently SELECTED task type (eg 'run','copy')
# "fm_task_name"            selected task name (custom menu item name)
# "fm_task_pwd"             selected task working directory ( same as %t )
# "fm_task_pid"             selected task pid               ( same as %p )
# "fm_task_command"         selected task command
# "fm_task_id"              selected task id
# "fm_task_window"          selected task window id

# "$fm_command"             current command
# "$fm_value"               menu item value             ( same as %a )
# "$fm_user"                original user who ran this command
# "$fm_my_task"             current task's id  (see '<a href="#sockets-invoc-help">spacefm -s help</a>')
# "$fm_my_window"           current task's window id
# "$fm_cmd_name"            menu name of current command
# "$fm_cmd_dir"             command files directory (for read only)
# "$fm_cmd_data"            command data directory (must create)
#                                 To create:   mkdir -p "$fm_cmd_data"
# "$fm_plugin_dir"          top plugin directory
# tmp="$(fm_new_tmp)"       makes new temp directory (destroy when done)
#                                 To destroy:  rm -rf "$tmp"
# fm_edit "FILE"            open FILE in user's configured editor

# $fm_import                command to import above variables (this
#                           variable is exported so you can use it in any
#                           script run from this script)


# Script Example 1:

#   # show MD5 sums of selected files
#   md5sum "${fm_files[@]}"


# Script Example 2:

#   # Show a confirmation dialog using <a href="#dialog">SpaceFM Dialog</a>:
#   # http://ignorantguru.github.io/spacefm/spacefm-manual-en.html#dialog
#   # Use QUOTED eval to read variables output by SpaceFM Dialog:
#   eval "`spacefm -g --label "Are you sure?" --button yes --button no`"
#   if [[ "$dialog_pressed" == "button1" ]]; then
#       echo "User pressed Yes - take some action"
#   else
#       echo "User did NOT press Yes - abort"
#   fi


# Script Example 3:

#   # Build list of filenames in panel 4:
#   i=0
#   for f in "${fm_panel4_files[@]}"; do
#       panel4_names[$i]="$(basename "$f")"
#       (( i++ ))
#   done
#   echo "${panel4_names[@]}"


# Script Example 4:

#   # Copy selected files to panel 2
#      # make sure panel 2 is visible ?
#      # and files are selected ?
#      # and current panel isn't 2 ?
#   if [ "${fm_pwd_panel[2]}" != "" ] \
#               &amp;&amp; [ "${fm_files[0]}" != "" ] \
#               &amp;&amp; [ "$fm_panel" != 2 ]; then
#       cp "${fm_files[@]}" "${fm_pwd_panel[2]}"
#   else
#       echo "Can't copy to panel 2"
#       exit 1    # shows error if 'Popup Error' enabled
#   fi


# Script Example 5:

#   # Keep current time in task manager list Item column
#   # See http://ignorantguru.github.io/spacefm/spacefm-manual-en.html<a href="#sockets">#sockets</a>
#   while (( 1 )); do
#       sleep 0.7
#       spacefm -s <a href="#sockets-methods-set-task">set-task</a> $fm_my_task item "$(date)"
#   done
</pre>

<b>Or, if you would like to use another script as your default</b>, save it as <a href="#programfiles-home-defscript">~/.config/spacefm/scripts/default-script</a>.  It is recommended that you include the example variables shown above at the end of your default script.

<p>For example, to calculate the MD5 sum of all selected filenames using a command script, you would use this line in the script:
<pre>    md5sum "${fm_filenames[@]}"</pre>

<p><a name="scriptdir"><b>Script Directories</b></a>
<br>If your script requires additional files to work, they should be placed in the <a href="#designmode-command-browse-files">command directory</a>.  You can refer to this directory in your script as "$fm_cmd_dir".  Files in this directory should not be modified by the script.

<p>If your script needs to save changing, persistent data to the user's home folder (to keep track of user preferences, for example), the <a href="#designmode-command-browse-data">data directory</a> should be used ("$fm_cmd_data").  Because this directory may not already exist, always run this command before using it:
<pre>    mkdir -p "$fm_cmd_data"</pre>

<p>If your script needs a temporary directory to work in, you can create one automatically using this convenience function:
<pre>    tmp="$(fm_new_tmp)"</pre>

<p>Your new, empty temporary directory will be created, and its path will be placed in $tmp by the above command.  Before the end of your script, be sure to clean up by destroying the temporary directory:
<pre>    rm -rf "$tmp"</pre>

<p>When you export a Command menu item, the command script and any files in the command directory are included in the plugin file.  When you remove a command, all of these files AND the data directory are deleted!

<p><b>Open In Editor &amp; Root Editor</b>
<br>The Open In Editor button will save and open the command script in your editor.  Simply edit the script and save it in your editor.  The Root Editor button, if shown, can be used to open a root-owned script in root's editor.

<p>You can also open the command script in your editor directly from the Design Menu with <a href="#designmode-designmenu-edit">Edit Script</a> or using a <a href="#designmode-shortcuts">design mode shortcut</a> instead of the Design Menu.  Highlight the menu item and press F4 or Ctrl+E, <b>or</b> use the mouse shortcut Middle-Click.

<!-- # Run Options #opts -->
Shown only for menu items of type Command, the Options page of the <a href="#designmode-props">Menu Item Properties</a> dialog allows you to set additional options which determine how your command behaves.  The Run Options section determines how SpaceFM will run your command when the menu item is activated.

<p><a name="designmode-command-task"><b>Run As Task</b></a><br>
Run As Task</a>, which is enabled by default for new commands, changes several aspects of how your command is run.  If Run As Task is UNchecked, the command is run <i>asynchronously</i> - it is run and forgotten by SpaceFM.  This is useful for running a program such as Firefox, for example.  SpaceFM doesn't need to wait for Firefox to finish or monitor its output - it can be run and forgotten.  For commands which simply start applications or produce no output, you may want to uncheck Run As Task.

<p>If Run As Task is checked, then the command is run <i>synchronously</i> - as a child process of SpaceFM.  SpaceFM's <a href="#tasks-man">Task Manager</a> will monitor the task, and if the task runs for longer than about one half second, the Task Manager will auto-show and the task will be listed.  When the task finishes, it will be removed from the list.  This can be used to monitor a task and to know when it has completed.  (When a command is run from the desktop menu, no Task Manager is shown for the task, but a popup may be shown automatically.)

<p>In addition, any output from the task (stdout and stderr), will be collected in an <a href="#tasks-dlg">output monitor</a>.  To raise this monitor, click on the task in the Task Manager.  (The output monitor can also be set to raise automatically on certain events - see <a href="#designmode-command-popup">Popup</a> options below for details.)

<p>SpaceFM's output monitor is designed to display text output to be used for monitoring the output of commands as they run, or to display a final result.  However, the output monitor is not a terminal and does not allow you to enter input.  If your command requires interaction, you will need to use <a href="#designmode-command-terminal">Run In Terminal</a> instead.

<p>To stop a task prematurely, raise the output monitor and click the Stop button, or right-click on the task in the Task Manager and select <a href="#tasks-menu-stop">Stop</a>.  When SpaceFM stops a task, it sends the process and all its child processes a SIGTERM signal, followed several seconds later by SIGKILL signals.  If the process was run as another user, you will be prompted to enter the user's password (or root's password) again to stop the task.

<p>When the <a href="#designmode-command-terminal">Run In Terminal</a> option is checked, the Run As Task option will be unchecked automatically as a convenience.  Although not normally useful, it is possible to use these options together (just check Run As Task again after checking Run In Terminal).  When both are checked, the terminal window itself is run as a task, the output monitor will generally be empty, and errors may not be detected.  Mostly this is useful only for monitoring when the command has finished (when the terminal window closes, it will be removed from the Task Manager).  Note that some terminal emulators cannot be run as a task by SpaceFM because the emulator does not start a new instance.

<p><a name="designmode-command-popup"><b>Popup Task</b></a><br>
The Popup Task/Error/Output and Scroll options are only enabled if <a href="#designmode-command-task">Run As Task</a> is checked.  If Popup Task is checked, the <a href="#tasks-dlg">popup dialog</a> for the task will be raised as soon as the task is added to the Task Manager, even if no output has occured.  The output monitor will not be shown if the task completes in less than about one half second.

<p>Use Popup Task if you want a popup anytime the task runs for more than a moment.  When the task finishes, the popup will remain, allowing you to review any output.  You can also close the monitor prematurely while the task is still running by clicking the Close button - the task will continue running in the <a href="#tasks-man">Task Manager</a>.

<p>Note that the global Task Manager setting <a href="#tasks-menu-popall">Popup All Tasks</a>, if checked, takes predecence - the task will popup even if the command's Popup Task option is unchecked.  (However, unlike Popup Task, Popup All Tasks will not cause the popup to remain when the command has finished, unless an error occurs.)

<p>By default, Popup Task is unchecked in new commands.

<p><a name="designmode-command-poperr"><b>Popup Error</b></a><br>
If Popup Error is checked and the exit status of your command is not zero, a <a href="#tasks-dlg">popup dialog</a> will be raised to show the error.  Popup Error only has an effect at the moment the command finishes.  If unchecked, the exit status is ignored.

<p>Popup Error provides a convenient way to get feedback on the success of your command.  When the command finishes successfully it will simply be removed from the Task Manager.  However, if an error occurs then the popup will be raised.

<p>Even if your command does not produce a usuable exit status, you can terminate your command line or script with a non-zero exit status to trigger the error popup.  For example:
<pre>    if [ ! -e file.output ]; then exit 1; fi</pre>
(If the file 'file.output' does not exist, then exit with exit status 1, triggering an error popup if Popup Error is checked.)

<p>To see another example, scroll to the end of a command script:
<pre>    # Script Example 3:

    # Copy selected files to panel 2
      # make sure panel 2 is visible ?
      # and files are selected ?
      # and current panel isn't 2 ?
    if [ "${fm_pwd_panel[2]}" != "" ] \
                &amp;&amp; [ "${fm_files[0]}" != "" ] \
                &amp;&amp; [ "$fm_panel" != 2 ]; then
        cp "${fm_files[@]}" "${fm_pwd_panel[2]}"
    else
        echo "Can't copy to panel 2"
        exit 1    # shows error if 'Popup Error' enabled
    fi</pre>

<p>By default, Popup Error is checked in new commands.

<p><a name="designmode-command-popout"><b>Popup Output</b></a><br>
If Popup Output is checked, a <a href="#tasks-dlg">popup dialog</a> will be shown the first time the command produces output (even if the task runs so quickly that it is not shown in the <a href="#tasks-man">Task Manager</a>).  Note that if you close the popup dialog while the command is still running, further output will NOT reopen it, but you can open it again by clicking on the task.

<p>Popup Output can be used to alert you when your task has produced output.  By default, it is checked in new commands.

<p><a name="designmode-command-scroll"><b>Scroll Output</b></a><br>
The Scroll Output option, which is checked by default for new commands, determines the auto-scroll behavior of the <a href="#tasks-dlg">output monitor</a>.  If checked, the monitor will automatically scroll down to the end of the output (unless the user has moved the scrollbar up from the bottom position).  If unchecked, the output will not automatically scroll to the end.

<p>With some commands, it's useful to read the output from the top and scroll down manually.  For example, if you right-click on a device in the Devices list and select Properties, you will see a non-auto-scrolling output monitor - the cursor stays at the very beginning of the output so you can read it.

<p>With other commands, you're most interested in the end of the output, so you want the output monitor to behave like a terminal and scroll to the end as new output is added.  For example, errors usually appear at the end, so if you want to know why the command stopped prematurely, you're most interested in the end of the output.  When you want the output monitor to behave like a terminal in this regard, check Scroll Output.

<p>Even if Scroll Output is checked, you can always manually move the scrollbar up to inhibit auto-scrolling.

<p><a name="designmode-command-terminal"><b>Run In Terminal</b></a><br>
If your command is a command-line program which produces much output, or you need to be able to interact with it (eg enter a password), check the Run In Terminal option on the Options page.

<p>Each time your command is run, a terminal will be opened and the command will be run within it.  The terminal program used is configured globally in View|Preferences|Advanced|Terminal.

<p>When you check the Run In Terminal option, the <a href="#designmode-command-task">Run As Task</a> option will be unchecked automatically as a convenience.  (If you do want both Run In Terminal and Run As Task, you can then check Run As Task as well.  However, normally it is not useful to run the terminal window as a task, as nothing will be shown in the output monitor.)

<p><a name="designmode-command-keep"><b>Keep Terminal Open</b></a><br>
Enabled by default when using <a href="#designmode-command-terminal">Run In Terminal</a>, Keep Terminal Open will cause the terminal to stay open even after the command or program has finished.  This is useful for programs which produce some output and then exit.  Without Keep Terminal Open, the terminal window would close before you had a chance to read the output.

<p>When Keep Terminal Open is enabled, after the command finishes you will be presented with a message like:
<pre><i>&nbsp;&nbsp;[ Finished ]  Press Enter to close or s + Enter for a shell:</i></pre>

<p>To close the window, simply press Enter.  If you want to enter an interactive bash shell, press s then Enter.  When finished with the shell, type 'exit'.

<p>With other programs or commands, it is not useful for the terminal to be held open after the command has finished.  For these commands, uncheck Keep Terminal Open.

<p><a name="designmode-command-user"><b>Run As User</b></a><br>
If a username is entered in the Run As User field, when the command is run, your configured terminal or graphical su program will be used to run the command as this username, instead of as the current SpaceFM user.  Depending on the su program used, you will be prompted to enter either the user's password or root's password.

<p>To run a command as root, "root" may be entered as the Run As User username.  However, <b>running commands as root in this way is generally NOT recommended</b>.  Because the command line or script is generally saved with normal user permissions, you are running a command which is not protected by root, as root.  This may compromise your system security at the root level.

<p>To run commands more safely as root, consider <a href="#designmode-designmenu-export">exporting the command</a> and <a href="#plugins-install">installing it as a plugin</a>.  Plugins enjoy root protection from modification, so when they are run as root, you have more assurance that they have not been tampered with.

<p>Another option is to run SpaceFM itself as root when needed (select File|Root Window).  In this way, all commands and settings are stored in root's home (/root/.config/spacefm), and are protected by root.  Yet running SpaceFM as root puts much power at your fingertips - accidentally deleting a file or folder may render your system unusable!  When run as root, everything you do in the file browser is done as root, including opening applications.  At the very least, be sure to have an up-to-date system backup if running SpaceFM as root.  It is your responsibility to evaluate this option for your purposes.

<p>When running a custom command as another non-root user, depending on the permissions of your SpaceFM config and scripts directories, this user may not have permission to access the command directory, including the command script.  To avoid this limitation, you can use a command line, or use a script which is in a mutually accessible directory.

<p>To run a command as the current user, simply leave the Run As User field empty.

<!-- # Style -->
The Style section of the <a href="#designmode-props-opts">Options page</a> of the <a href="#designmode-props">Menu Item Properties</a> dialog allows you to choose whether the item acts as a normal menu item, a checkbox, a confirmation dialog, or an input dialog.

<p><a name="designmode-style-normal"><b>Normal</b></a><br>
If your menu item's style is set to Normal, it will be displayed as a normal menu item, with an optional icon to the left, and a key shortcut to the right.  When clicked, your command will be run immediately.  Normal is the default style for new commands.

<p><a name="designmode-style-checkbox"><b>Checkbox</b></a><br>
If your menu item's style is set to Checkbox, it will be displayed as a checkbox menu item with a checkbox to the left, and a key shortcut to the right.  No icon will be displayed.  The checkbox will contain or not contain a checkmark.  Each time the user clicks the menu item, the checkbox will be toggled (if checked it will uncheck; if unchecked it will check), just like the checkbox menu items you are accustomed to.  After the checkbox is toggled, your command will be run.

<p>Your command can read the value of the checkbox using the variable <i>$fm_value</i> (or %a in command lines).  This will equal 1 if checked, or 0 if unchecked.  This allows your command to take different actions depending on the state of the checkbox.

<p>For example, add a new Command menu item called 'Checker'.  Then open the Properties dialog for the new item and select style Checkbox.  Enter or paste this command line on the Command page:
<pre>    if [ $fm_value -eq 1 ]; then echo "Box is checked"; else echo "Box is unchecked"; fi</pre>

<p>Now when you click your menu item, you will be told if the box is checked or unchecked - each time you click the item, it will change.

<p><a name="designmode-style-confirm"><b>Confirmation</b></a><br>
If your command's style is set to Confirmation, it will be displayed as a normal menu item with an optional icon to the left, and a key shortcut to the right.  When the item is clicked, the user will be presented with a confirmation dialog with OK and Cancel buttons.  If the user clicks OK, your command will then be run.  If the user clicks Cancel, the command will not be run.  There is also a Help button in this dialog which opens the README file for this command.

<p>To set or change the message which appears in the dialog, set your message in the Confirmation/Input Message entry on the Options page.

<p>Alternatively, to show a dialog while your script is running, or to easily create custom dialogs, see <a href="#dialog">SpaceFM Dialog</a>.

<p><a name="designmode-style-input"><b>Input</b></a><br>
If your menu item's style is set to Input, it will be displayed as a normal menu item with an optional icon to the left, and a key shortcut to the right.  When the item is clicked, the user will be prompted to enter text.  If the user clicks OK, your command will then be run.  If the user clicks Cancel, the command will not be run.  There is also a Help button in this dialog which opens the README file for this command.

<p>Your custom command can read the text entered by the user using the variable <i>$fm_value</i> (or %a in command lines).  The last text entered in the box will be remembered and will be the default entry next time the item is clicked.

<p>For example, add a new menu item called 'Your Name'.  Then open the Properties dialog for the new item and select style Input.  Enter 'Please enter your name:' as the message.  Enter or paste this command line on the Command page:
<pre>    echo "Your name is $fm_value."</pre>

<p>When you click the menu item, you will be asked for your name, and if you click OK, told your name.

<p>Alternatively, to show a dialog while your script is running, or to easily create custom dialogs, see <a href="#dialog">SpaceFM Dialog</a>.

<p>NOTE:  When exporting a command, the last value entered in the input dialog will be exported with the plugin, even if Input is no longer the selected style.  Before distributing a plugin, be sure to open or extract the archive and examine all files in your text editor to be clear on what data you are sharing.

<!-- # Open In Browser #open -->
The Open In Browser drop-down list is located at the bottom of the Options page of the <a href="#designmode-props">Menu Item Properties</a> dialog.  Each Command menu item has <a href="#scriptdir">several directories</a> where associated files are stored, and Open In Browser allows you to conveniently open these directories.  Simply select a directory and it will be opened.  This can be used to browse a plugin's files as a security check before running the plugin.  When designing more complex scripts, this facility can be used to help manage associated files.

<p><a name="designmode-command-browse-files"><b>Command Dir  $fm_cmd_dir</b></a><br>
Opens the <i>command directory</i> ($fm_cmd_dir).  The command directory contains the command script if any (exec.sh), as well as other files you may have added for use by the command.  The command directory's path will typically be:<br>
&nbsp;&nbsp;&nbsp;&nbsp;~/.config/spacefm/scripts/cstm_00000000/

<p>Or for a plugin:<br>
&nbsp;&nbsp;&nbsp;&nbsp;/usr/share/spacefm/plugins/PLUGIN-FILENAME/cstm_00000000/<br>
(/usr/local may also be used depending on install location)

<p>While you may modify files in the command directory when creating and maintaining your command, the command script should not modify files in this directory while the command is running.  The reason is that if you later install the command as a plugin, it will probably no longer have write access to this directory.

<p>When exporting a Command menu item, all files in the command directory are included in the plugin file.  There are several special files:  'exec.sh' is the command script, if any.  'icon' is a custom icon file for the command or plugin - it will automatically be shown if no icon is set.  You can also include a 'README' file in this directory which describes your command or plugin.

<p>All files in the command directory are deleted when the menu item or plugin is removed!

<p><a name="designmode-command-browse-data"><b>Data Dir  $fm_cmd_data</b></a><br>
Command menu items may also have an associated <i>data directory</i> ($fm_cmd_data), which may or may not exist.  The data directory is used to store persistent settings or data used by the command or plugin.  The data directory's path for both normal menu items and plugins will typically be:<br>
&nbsp;&nbsp;&nbsp;&nbsp;~/.config/spacefm/plugin-data/cstm_00000000/

<p>This directory must be created on demand, so if you plan to use it in a script, first make sure it exists:
<pre>    mkdir -p "$fm_cmd_data"</pre>

<p>SpaceFM does not automatically store any files in this directory - it is entirely up to you or the plugin creator how it is used.  To see what persistent data a plugin is storing in your home folder, examine the Data Dir.

<p>All files in the data directory are deleted when the menu item or plugin is removed!

<p><a name="designmode-command-browse-plugin"><b>Plugin Dir  $fm_plugin_dir</b></a><br>
Plugin Dir will only be listed for <a href="#plugins">plugins</a>.  It opens the top level of a plugin's directories ($fm_plugin_dir), so you can browse all its files (except its <a href="#designmode-command-browse-data">data directory</a>, which is stored in the user's home folder).  The plugin directory's path will typically be:<br>
&nbsp;&nbsp;&nbsp;&nbsp;/usr/share/spacefm/plugins/PLUGIN-FILENAME/<br>
(/usr/local may also be used depending on install location)

<p>Plugins may contain multiple menu items (a submenu plugin), so this directory may have several command directories within it, but will at least contain one command directory as well as a 'plugin' file which defines the contents of the plugin.  Review the contents of this file, but it should NOT be edited.

<p>Before using a plugin obtained from another user, browse Plugin Dir to make sure you understand what each command does.  Keep in mind that plugins can do anything on your system which the current user is permitted to do.

<p>The plugin directory contained a mirror copy of the contents of the <a href="#plugins-creationandfiles-file">plugin archive file</a> (eg Example.spacefm-plugin.tar.gz) when the plugin was installed.  Its contents will not change unless the directory contents are modified by the root user.


<!-- @Design Mode @Toolbars -->

<p>SpaceFM includes two primary toolbars: the main Toolbar (which is divided into a Left Toolbar, <a href="#gui-pathbar">Path Bar</a>, and Right Toolbar) and a Side Toolbar.  To show or hide the Toolbar or Side Toolbar, right-click on the file list and check or uncheck View|Toolbar or View|Side Toolbar.

<p>Toolbars can also be customised using <a href="#designmode">Design Mode</a>.  Although you cannot right-click directly on a toolbar icon, each toolbar has a config menu for the purpose of customisation.  Making changes to a toolbar's config menu will automatically change the items in the toolbar.

<p>To access a toolbar's config menu, click the leftmost icon on the toolbar (at the far left of the panel).  The 'Left Toolbar' config menu is used to customise the toolbar to the left of the <a href="#gui-pathbar">Path Bar</a>, and 'Right Toolbar' is used to customise the toolbar to the right.  The 'Side Toolbar' menu configures the Side Toolbar.

<p>In these menus, Design Mode works as always - use right-click or F2 to open the Design Menu for any highlighted item, or simply left-click the item.  But there are a few differences in these menus.

<p>Toolbar config menus show <i>all</i> available tool items, with an asterisk (*) next to the name of currently shown items, and no asterisk next to the name of hidden items.  When opening the Design Menu on a toolbar config menu item, the topmost item will be <a href="#designmode-designmenu-show">Show</a>.  If checked, the tool item will be shown in the toolbar.  If unchecked, the tool item will be hidden.

<p>You can add custom menu items to these menus (and thus to the toolbars), but you cannot add submenus.  (There are two special built-in submenus in each toolbar config menu:  Back Menu and Forward Menu.  If shown, these will display not only a back/forward icon, but also a drop-down list showing path history for the current browser tab.)

<p>Menu items can also be <a href="#designmode-designmenu-paste">pasted</a> and <a href="#designmode-designmenu-import">imported</a> to the toolbar config menus.


<!-- @Design Mode @Shortcuts -->

<p>In addition to right-clicking on a menu item and using the <a href="#designmode-designmenu">Design Menu</a>, design mode keyboard and mouse shortcuts are also available.  These shortcuts are NOT required - all you really need to know is 'right-click opens the Design Menu'.

<p>To use these shortcuts, highlight the menu item (hover your mouse cursor over it, or use the keyboard arrows to highlight the menu item), then use the key or mouse combo shown below.  These shortcuts are only available for use when a menu is open.

<br><br><br>
<table border=1 cellpadding="5"><caption><b>Design Mode Shortcuts</b></caption>
<tr>
	<th>Action</th>
	<th>Key Combo</th>
	<th>Mouse Combo</th>
</tr>
<tr>
	<td>Design Menu</td>
	<td>F2</td>
	<td>Right</td>
</tr>
<tr>
	<td>Cut</td>
	<td>Ctrl + X</td>
	<td>Alt + Left-or-Right</td>
</tr>
<tr>
	<td>Copy</td>
	<td>Ctrl + C</td>
	<td>Ctrl + Left-or-Right</td>
</tr>
<tr>
	<td>Paste</td>
	<td>Ctrl + V</td>
	<td>Shift + Left-or-Right</td>
</tr>
<tr>
	<td>New Command</td>
	<td>Insert</td>
	<td>Ctrl + Shift + Left-or-Right</td>
</tr>
<tr>
	<td>Edit Command</td>
	<td>F4 or Ctrl + E</td>
	<td>Middle</td>
</tr>
<tr>
	<td>Help</td>
	<td>F1</td>
	<td>Alt + Middle</td>
</tr>
<tr>
	<td>Set Key</td>
	<td>Ctrl + K</td>
	<td>Ctrl + Middle</td>
</tr>
<tr>
	<td>Set Icon</td>
	<td>Ctrl + I</td>
	<td>Shift + Middle</td>
</tr>
<tr>
	<td>Remove</td>
	<td>Delete</td>
	<td>Ctrl + Shift + Middle</td>
</tr>
<tr>
	<td>Properties</td>
	<td>F3</td>
	<td>Ctrl + Alt + Middle</td>
</tr>
</table>
<br>

<p>These shortcuts will also work after the Design Menu has been shown.

<p><b>The F1 keyboard shortcut is special</b> in that it can also be used to show help on items in the Design Menu itself.  Highlight a Design Menu item (such as Export) and press F1.

<p>If the shortcut action is not available for the current menu item (for example, performing Remove on a built-in menu item), the Design Menu will be opened instead.

<p>NOTE:  Some window managers may be configured to use some of these mouse combos for other purposes.  For these to work within SpaceFM, you may need to disable them in your window manager.


<!-- @Design Mode @MIME Menu #mime -->

<p>When you right-click on a file in the file list, the Open submenu shows applications associated with the (first selected) file's MIME type (eg text/plain).  If you right-click on one of these listed applications, or press F2 while the menu item is highlighted, you will be presented with a menu which allows you to configure MIME associations and definitions for this file type.

<p>TIP: For help with a menu item in the MIME menu itself, highlight the MIME menu item and press F1.

<p>IMPORTANT:  Changes made with this menu may affect any programs on your system which use the MIME database, not just SpaceFM.  However, some programs use other means for determining file types, or some combination of several methods, so not all MIME changes made in SpaceFM will be reflected in all programs.

<p>For more elaborate MIME adjustments, consider using a dedicated MIME editor.

<!-- # How MIME Works #mimeworks -->
SpaceFM uses freedesktop.org's <a href="http://freedesktop.org/wiki/Specifications/shared-mime-info-spec">shared-mime-info</a> database to determine file types, display file type names, determine and adjust associated applications, and determine and adjust the default application for a type.  (Also note that you can create <a href="#handlers-fil">file handlers</a> to bypass MIME associations.)

<p>It helps to know some basics about how MIME works so you can better control how your system handles file types.

<p>MIME knows what applications are installed on your system by examining <a href="http://freedesktop.org/wiki/Specifications/desktop-entry-spec">.desktop files</a>.  When an application is installed, it will usually install one or more .desktop files for itself to /usr/share/applications or /usr/local/share/applications.  These .desktop files determine the display name of the application (which may differ from the executable's name), translated display names, the command used to execute the application, an icon for the application, what MIME file types the application can open, and other specifics.

<p>If you would like to change anything in an application's .desktop file, the correct way to do so is to copy the desktop file to ~/.local/share/applications in your home folder, and make changes in the copy.  (Changes made directly in /usr/share/applications may be lost when the software is upgraded.)  You can also add your own custom .desktop files to run programs or scripts.  When MIME looks for a desktop file, first it looks in ~/.local/share/applications, then in /usr/local/share/applications, and then in /usr/share/applications, using the first copy it finds.  Thus copies in your home folder always take precedence, and will not be modified when software is upgraded.

<p>Anytime .desktop files are created or changed, the MIME desktop database needs to be updated.  A user's database can be updated by the user running:
<pre>    update-desktop-database ~/.local/share/applications</pre>

This command examines all the desktop files and will create files named 'mimeinfo.cache' which contain all the relevant information for fast access.  The mimeinfo.cache files should never be edited directly.

<p>To determine what applications are associated with a given MIME type (what applications can be used to open files of that type), SpaceFM and many other programs will build a list of applications by examining the mimeinfo.cache files in ~/.local/share/applications, /usr/local/share/applications, and /usr/share/applications.

<a name="mimeappslist"><p></a>Sometimes a distro, admin, or user may want to associate additional applications with a MIME type, or remove unwanted associations.  Information about added and removed associations are placed in <a href="http://freedesktop.org/wiki/Specifications/mime-actions-spec">mimeapps.list files</a> located in the applications directories.  ~/.local/share/applications/mimeapps.list in the user's home folder takes precedence.  Distros and admins may also use files named 'defaults.list' to associate applications, although modification of these files by the user is now deprecated - change mimeapps.list instead.  (SpaceFM versions >0.7.7 will use mimeapps.list first if present, and will only modify mimeapps.list.)

<p>The first application listed for a given MIME type in these files, for which a corresponding .desktop file can be found, is considered the 'default application' for this MIME type.  For example, when you click on a file in SpaceFM, the default application is used to open the file (with some exceptions).

<p>To define MIME types, <a href="http://freedesktop.org/wiki/Specifications/AddingMIMETutor">xml files</a> are used.  These may determine a file type using a filename glob (eg *.txt), or may base determination on a file's contents.  freedesktop supplies basic definitions, and additional ones may be added in /usr/share/mime/packages.  Any definitions placed in Overrides.xml will override other definitions.  Users can add xml files to add custom MIME types or to change existing definitions.  These are usually placed in ~/.local/share/mime/packages.  After adding or changing these files, run:
<pre>    update-mime-database ~/.local/share/mime</pre>

Or to update the system-wide database:
<pre>    sudo update-mime-database</pre>

<p>At startup, SpaceFM reads and caches these xml files to know how to recognize all the file types on your system.  Because they are cached, you may need to restart SpaceFM after changing MIME type definitions.

<p>SpaceFM's MIME menu makes it easy to find and edit all the files needed to customise your MIME database, and in some cases will create and edit the files for you.  One example is the 'Choose...' menu item on the file list context menu's Open submenu, which lets you choose or set a default application for a MIME type.  Choosing an application will cause SpaceFM to edit your mimeapps.list file, setting the application as the default.

<p>For other adjustments, see the MIME menu items below.

<!-- # Set As Default #set -->
Selecting Set As Default will set the selected application as the default application for the selected file's MIME type.  In SpaceFM this will move the application to the top of the Open submenu.

<p>Specifically, SpaceFM will edit your <a href="#mimeappslist">~/.local/share/applications/mimeapps.list</a> file, adding the application's .desktop file to the beginning of the list for the given MIME type in [Added Associations], and will remove it from [Removed Associations] if present.

<!-- # Remove -->
Selecting Remove will remove the selected application's association with the selected file's MIME type <i>for the current user</i>.  It will no longer appear in the Open submenu for this file type.

<p>Specifically, SpaceFM will edit your <a href="#mimeappslist">~/.local/share/applications/mimeapps.list</a> file, removing the application's .desktop file for the given MIME type in [Added Associations], and will add it to [Removed Associations] for the given MIME type.

<p>To restore an association that you have removed, use <a href="#designmode-mime-add">Add...</a>

<P>NOTE:  When compiling the list of applications to appear in the Open submenu for a text file, SpaceFM will include applications associated with the MIME type (eg text/html) <b>and</b> applications associated with text/plain.  If you select Remove on an application, it will be removed as an associated application for the MIME type (eg text/html), but will NOT be removed as an associated application for text/plain (unless the MIME type is text/plain).  Thus using Remove may not remove the application from the Open submenu for this type, unless you also remove it from text/plain.  Text files are the only files with this behavior.

<!-- # Add... #add -->
Selecting Add... will open the same dialog as the 'Choose...' item on the Open submenu, allowing you to select an application or enter a command to be associated with this MIME type.  The application won't be made the default unless you check option 'Set as default' in the dialog.  The application or command will then appear as an associated application in the Open submenu for this MIME type.

<p>Specifically, SpaceFM will edit your <a href="#mimeappslist">~/.local/share/applications/mimeapps.list</a> file, adding the application's .desktop file to the list for the given MIME type in [Added Associations], and will remove it from [Removed Associations] if present.  If you entered a command instead of choosing an application from the list, a custom desktop file will be created for your command in ~/.local/share/applications/.

<!-- # application.desktop #appdesktop -->
The next item on the MIME menu will be the name of the .desktop file for the selected application (eg spacefm.desktop).  Selecting this item will open the copy of the desktop file located in ~/.local/share/applications/ using your text editor, allowing you to customise the .desktop file.  For example, you can change the application's name (how it appears in the menu), the icon as it appears in the menu, or the command run when the application is selected.  Edit the file and save it.

<p>If "(*copy)" appears next to the .desktop filename on the menu, this means that no copy of the desktop file currently exists in ~/.local/share/applications/.  If you select it, SpaceFM will automatically copy the desktop file from /usr/share/applications/ to ~/.local/share/applications/, and will then open the copy in your text editor.  The copy in ~/.local/share/applications/ always takes precedence over other locations.

<!-- # mimeapps.list #mimeappslist -->
Selecting mimeapps.list will simply open <a href="#mimeappslist">~/.local/share/applications/mimeapps.list</a> in your text editor, allowing you to examine added and removed associations, and edit them.

<p>If you edit this file, be careful to use its default formatting.  While SpaceFM doesn't mind spaces in the lists, other programs may not be so forgiving.  Any changes you make to this file will immediately take effect.

<!-- # applications/ #appdir -->
Selecting applications/ will open the ~/.local/share/applications/ folder in a new tab.  This folder contains your user copies of .desktop files as well as your <a href="#mimeappslist">mimeapps.list</a> file.  (See <a href="#designmode-mime-mimeworks">How MIME Works</a> above.)

<!-- # mime-type.xml #xml -->
The next item on the MIME menu will be the name of an xml file which can be used to redefine this MIME type (eg text-plain.xml) for the current user.  Selecting this item will open the file located in ~/.local/share/mime/packages/ using your text editor, allowing you to customise the MIME type definition.  For example, you can change what filename extensions (globs) are used, or change the name of the file type as it appears in the Type column of the file list.  Edit the file and save it.  You may then need to run 'update-mime-database ~/.local/share/mime' and/or restart SpaceFM for the changes to take effect.  (SpaceFM will run update-mime-database for you if you opened the file using this menu item.)

<p>If "(*new)" appears next to the xml filename on the menu, this means that the xml file doesn't currently exist in ~/.local/share/mime/packages/.  If you select it, SpaceFM will automatically create the xml file using the definition in /usr/share/mime as a template (if present), and will then open the new xml file in your text editor.  The copy in ~/.local/share/mime/packages/ always takes precedence over other locations.

<p>You can also use this menu item simply to see the MIME type of the selected file.  For example, if the name of this menu item is "application-zip.xml", then you know the MIME type is "application/zip".

<!-- # mime/packages/ #mimedir -->
Selecting mime/packages/ will open the ~/.local/share/mime/packages/ folder in a new tab.  This folder contains your custom xml files used to redefine MIME types (see <a href="#designmode-mime-xml">mime-type.xml</a> above).  After adding, editing, or removing files from this folder, you may then need to run 'update-mime-database ~/.local/share/mime' and/or restart SpaceFM for the changes to take effect.

<!-- # usr/ #usr -->
The usr/ submenu gives you access to files and folders in /usr/share/applications/ and /usr/share/mime/packages/ (or in some cases, /usr/local/share/...).

<p>For example, to see the original .desktop file for an application, select the .desktop file in the usr/ submenu.  It will be opened in your editor, but can only be edited by root.  (Normally it is useless to edit this copy, as a software upgrade may overwrite it.)

<p>Likewise, to see the system-wide MIME type definition for the current MIME type, select the xml file in the /usr submenu.

<p>The Overrides.xml file, if present, will be opened as root to allow you to edit it.  This is one place where you can define system-wide changes to MIME types.  (Or you can copy your custom xml files to /usr/share/mime/packages/).  When making changes here you must run 'sudo update-mime-database' and restart SpaceFM.






<!-- @Plugins @Introduction -->

<p>Like any plugin, a SpaceFM plugin extends the features of the file manager.  What's different about SpaceFM plugins is how readily they're created.  Any custom menu item can be turned into a plugin simply by exporting it to a plugin file.  SpaceFM plugins use an open format which can include additional files, and can also store persistent data between sessions.  SpaceFM plugins can do anything a bash script can do - which means just about anything.

<p>Eventually, some plugins will be included with SpaceFM.  Additionally, user-contributed plugins can be shared and obtained in the <a href="https://github.com/IgnorantGuru/spacefm/wiki/plugins/">SpaceFM Wiki</a>.

<p><b>It is your responsibility to evaluate the safety and applicability to your purposes of all plugins.</b>


<!-- @Plugins @Install -->

<p>When a plugin is installed, it is added to the Plugins menu where it gains root protection (it cannot be modified by normal users) and becomes accessible to all users of SpaceFM on your system.  Installing a plugin helps protect the plugin's contents from tampering, but it also limits what you can change.

<p>To install a plugin using a <a href="#plugins-creationandfiles-file">plugin file</a>, use Plugins|Install|File.  You will be prompted to choose a file, and you will need to enter the root password for installation.  You can also install a plugin directly from a URL using Plugins|Install|URL (be sure to examine their contents before running commands within the plugin).  wget is required when installing from URL (this program is already installed on most Linux distributions).  Remember that installing a plugin as root does NOT mean it is run as root.  The files for the plugin are merely copied to /usr/<i>?local?</i>/share/spacefm/plugins as root.

<p>When installed or imported, plugins lose any key shortcut which was saved with the plugin, and also lose their <a href="#designmode-props-opener">Use as handler for</a> context setting.  These settings must be manually added after installation/import if desired.

<p>Installed plugins are available via the Plugins menu.  SpaceFM will allow you to set a key shortcut for a plugin, change its icon, and change Run In Terminal and Run As Task options for the plugin.  You cannot change the type of a plugin, and unless you do so as root, you cannot edit the command script.  You can temporarily edit the command line or custom target of a plugin, but your changes will not be saved - they will be valid only for the current session by the current user.

<p>To see the help file for a plugin command, use <a href="#designmode-designmenu-help">Help</a> on the Design Menu, or highlight the menu item and press F1.

<p>When you make <a href="#designmode">Design Mode</a> changes to a plugin, you are not actually altering the plugin itself.  SpaceFM creates a skin for the plugin which holds your custom key shortcut, icon, etc.  Thus these changes made to a plugin by one user will not be seen by other users on the system.  This skin is retained in the SpaceFM <a href="#programfiles-home-session">session file</a> until the plugin is <a href="#designmode-designmenu-remove">removed</a>.

<p>If you want to make deeper changes to a plugin, you can copy it using <a href="#designmode-designmenu-import">Import</a> on the Design Menu, and <a href="#designmode-designmenu-paste">Paste</a> the copy into another menu.  The copy will be exactly like the plugin, except that its files will no longer be owned by root.  Thus you can make any changes to a copied plugin, just as with any custom menu item.  You can also <a href="#designmode-designmenu-export">export</a> the copy, then install it as a plugin again, either with a new name, or overwriting the old plugin.

<p>You can also <a href="#designmode-designmenu-export">export</a> an installed plugin.  Unless you made changes to the plugin directory as root, the exported plugin file will essentially be a copy of the original plugin file.

<p>NOTE:  Plugins created with SpaceFM versions 0.7.0 and later may not work correctly with prior versions due to changes in the file structure of plugins and commands.

<!-- @Plugins @Import -->

<p>Instead of installing a plugin, you can import it into any SpaceFM menu which supports design mode.  When imported in this way, the plugin loses root protection and becomes a normal custom menu item.

<p>To do so, use Plugins|Import|File to import a plugin file, or Plugins|Import|URL to import directly from URL.  No root password is required.  The plugin will be copied to the <a href="#designmode-designmenu-cut">design clipboard</a>.  You may then use <a href="#designmode-designmenu-paste">Paste</a> on the Design Menu to paste the item into any location in any supported menu.  As with any custom menu items, you cannot paste the item into some parts of the Plugins menu and the file browser's Open menu.

<p>If option Plugins|Import|Verbose is checked, after the plugin has been copied to the design clipboard, you'll see a message reminding you what to do next.

<p>When installed or imported, plugins lose any key shortcut which was saved with the plugin, and also lose their <a href="#designmode-props-opener">Use as handler for</a> context setting.  These settings must be manually added after installation/import if desired.

<p>Alternatively, you can use <a href="#designmode-designmenu-import">New|Import</a> on the Design Menu to import and paste a plugin in one step.

<p>Note: Exported bookmarks in a "spacefm-bookmarks" plugin file cannot be installed or imported via the Plugins menu, but can be imported into other menus.

<!-- @Plugins @Uninstall -->

<p>To uninstall a plugin, use <a href="#designmode-designmenu-remove">Remove</a> on the Design Menu.  You will be prompted for the root password, and all files and settings associated with the plugin will be removed.

<p>If the installed plugin is a <a href="#designmode-designmenu-submenu">submenu</a> plugin, you can only remove the top submenu of the plugin.  You cannot remove individual items from within it.

<!-- @Plugins @Creation And Files -->

<p>The best way to create a plugin, whether for your own use or for others, is to <a href="#designmode-designmenu-new">create a custom command</a>.  Develop the command to work the way you want, and set any Design Mode options for how the command is best run.  When you're ready to create the plugin, simply use <a href="#designmode-designmenu-export">Export</a> on the <a href="#designmode-designmenu">Design Menu</a> to save the command to a plugin file.

<p>A plugin may also contain multiple related commands and submenus of commands.  To create such a plugin, simply export a <a href="#designmode-designmenu-submenu">submenu</a>.

<p>Exporting commands as plugins also provides a way to back up commands.  By exporting it to a plugin file, your custom menu item becomes portable and self-contained - you can always use the plugin file to import it back into any SpaceFM session, either as a normal custom menu item, or as an installed plugin.

<!-- # Plugin File #file -->
The SpaceFM plugin file uses a simple and open format.  The plugin file is simply a tar.gz archive.  This allows you to open any plugin file and examine its contents using your text editor.  With the possible exception of any extra files included within the plugin, all files are plain text files.  When creating plugins, try to honor this design by using open, accessible text file formats.

<p>A plugin file, such as Example.spacefm-plugin.tar.gz, contains a single file named 'plugin' which SpaceFM uses to define the contents of the plugin.  This file is plain text and can be viewed in your editor, but should NOT be edited.  In addition, plugin files contain one or more command directories, one for each command in the plugin.  Plugins may be a single command, or they may be a single submenu which contains an unlimited number of commands and submenus.  Thus a set of commands with related functions can be distributed as a single submenu plugin.  (To create a submenu plugin, simply export a <a href="#designmode-designmenu-submenu">submenu</a>.)

<p>TIP:  If you have a larger plugin, you can manually convert it to tar.xz format and SpaceFM will accept it (only tar.gz or tar.xz).

<!-- # Extra Files #extra -->
Additional files required by your plugin can be added to the command directory, which may be opened using <a href="#designmode-props-open">Open In Browser</a> on the Options page of the Menu Item Properties dialog.  When the command is <a href="#designmode-designmenu-export">exported</a>, these files will be included in the <a href="#plugins-creationandfiles-file">plugin file</a>.  The <a href="#designmode-command-script">command script</a> (exec.sh) is located in the command directory.  Files in the command directory should be considered read-only (once your plugin is <a href="#plugins-install">installed</a>, your script will probably not have permission to modify them).

<p>You may also add a file named 'icon'.  SpaceFM will automatically display this icon for the plugin if no other icon is <a href="#designmode-props-icon">set in the Menu Item Properties</a>.  Small icons work best, as your icon may not be resized.  If you don't want to include a custom 'icon' file, you can also simply set a standard icon for the command using the Design Menu.  Users can also override your default icon in this way.  Keep in mind that the user may be using a different icon theme than you are, so try to stick with common icon names.  Using an absolute path for the icon is not recommended.

<p>In addition, adding a README file to the command directory is recommended.  This file will be created automatically if you select <a href="#designmode-designmenu-help">Help</a> from the Design Menu.  This file explains what your plugin does, how to use it, and may include an email address, website, license terms, etc.

<p>If multiple commands in your plugin need to access shared files, it is possible to place them in the top level of the plugin file, the plugin directory.  SpaceFM won't do this for you automatically when exporting a command, but you can add them using an archive application after the plugin file has been created.  Or, if your plugin is already installed and you added files to its plugin directory, these files WILL be included in the plugin file when the plugin is exported again.  Your scripts can access this directory using "$fm_plugin_dir".  To browse it, use <a href="#designmode-props-open">Open In Browser</a> on the Options page of the Menu Item Properties dialog.  <b>One limitation of using this directory</b> is that if a user copies commands from within your plugin submenu to another menu, the files in the plugin directory will NOT be included.  Thus, it may be better to include all of a command's required files in its command directory instead.  In this way, each command is complete when copied elsewhere.  Or, if multiple commands needs to access the same files, consider creating a config directory in the user's home directory (eg ~/.config/spacefm-plugin-myexample) for your plugin.

<!-- # Data Files #data -->
If necessary, your plugin can maintain changing, persistent data files in the user's home folder to store user preferences and other changing data.  Your script should store these files only in the data directory ("$fm_cmd_data", accessed via <a href="#designmode-props-open">Open In Browser</a> on the Options page of the Menu Item Properties dialog).  Data files are NOT included when the command or plugin is exported, and they are deleted when the menu item or plugin is removed.  Each command or plugin has its own data directory.  If you need to populate the data directory with initial files, consider making your script copy them from the command directory when it is first run.  Because it is located in the user's home folder, you should always document what files you are storing in the data directory.  Most plugins do not require any data files.

<p>Remember that the data directory may not exist, so make sure your script always creates it before attempting to use it.  Place this command in the initial part of your script:
<pre>    mkdir -p "$fm_cmd_data"</pre>

<p>Before distributing a plugin, be sure to open or extract the archive and examine all files in your text editor to be clear on what data you are sharing.  For example, some entries may be included in the plugin file even if they are currently disabled in the command.


<!-- @Handlers @Introduction -->
<p>Handlers are sets of commands which tell SpaceFM how to perform a function, such as opening a file, mounting a device, or creating/extracting an archive.  In some cases your handlers replace SpaceFM's default behavior.  Handlers come in several varieties: <a href="#handlers-dev">Devices</a>, <a href="#handlers-pro">Protocols</a>, <a href="#handlers-arc">Archives</a>, and <a href="#handlers-fil">Files</a>.



<!-- @Handlers @Devices #dev -->
<a name="devices-settings-mcmd"><p>Device</a> <a name="devices-settings-ucmd">handlers</a> <!-- backwards compat links --> tell SpaceFM how to mount, unmount, and show properties for specific filesystems or devices.  Anytime SpaceFM or the SpaceFM daemon mounts or unmounts a device (manually or automatically), or shows the properties of a device, it uses a handler to determine what commands to run.  By adding custom device handlers, SpaceFM can be made to mount and unmount virtually any type of device or filesystem.

<p>To configure device handlers, right-click in the Devices list and select Settings|Device Handlers.  The list at the left of the Device Handlers configuration window lists all device handlers.  (Enlarge this window to see the handler commands more clearly.)  Click on a handler's name to see its contents.  The order of the list is important: Starting from the top, the first handler which matches the current device will be used.  You can reorder the list by dragging entries, or using the Up &amp; Down buttons.  In this way, you determine what handlers have preference.  The "Default" handler is usually listed last, and is used if no other handlers apply.

<p>The right side of the window shows the selected handler's contents.  If Enable Handler is unchecked, this handler will never be used.  The Name contains the common name for the handler, which appears in the list and in debug messages.  Next comes a Whitelist and Blacklist: these determine when this handler will be used.  Finally, the Mount, Unmount, and Properties boxes contain scripted commands which will be run by the handler to mount, unmount, or list properties of a device.

<p><b>TIP:</b>  If you just want to change the mount program that SpaceFM uses to mount removable drives (such as udevil, pmount, or udisks), open Device Handlers and click the Default handler.  Example Mount and Unmount commands are shown for each mount program.  Just enable the section you want to use by removing the appropriate comment marks (#).


<!-- # Whitelist #white -->
A handler's whitelist is a space-separated list of elements.  In general, if any element in the list matches the device properties, then this handler may be used for this device.  If a list element is prefixed with a plus sign '+', that element is <i>required</i> to match.  Any element in the list may contain wildcards (an asterisk '*' to represent multiple characters, or a question mark '?' to represent single characters).  

<p>The following device whitelist elements are recognized:
<pre>
    FSTYPE (eg ext3)
    dev=DEVICE (/dev/sdd1)
    id=UDI
    label=VOLUME_LABEL (include spaces as underscores)
    point=MOUNT_POINT
    audiocd=0 or 1
    optical=0 or 1
    removable=0 or 1
    mountable=0 or 1
</pre>

The simplest whitelist simply contains a filesystem type, such as "ext3".  Thus anytime you mount a device with that filesystem, the handler may be used.

<p>If you want a handler to apply to several filesystem types, just list them:
<pre>    ext3 ext4</pre>

For more complex situations, you can add more elements to narrow or control when a handler will be used.  For example, consider the following whitelist:
<pre>    +ext3 +dev=/dev/sdd* +label=My_Volume_Label</pre>

First, the elements are prefixed with plug signs, so all are required to match, or the handler will not be used.  First, the filesystem type MUST be ext3 for this handler to be used.  Second, the device file must begin with "/dev/sdd" (eg /dev/sdd1).  Finally, the volume label on the device must be "My Volume Label" (or "My_Volume_Label").  Note that spaces in the label are converted to underscores for testing.

<p>To see what handler SpaceFM has selected to mount a device, and see the commands being issued, start the <code>spacefm</code> program in a terminal window, and observe debugging output in the terminal while SpaceFM is running.  For example, mounting a USB stick you may see:
<pre>    Selected Device Handler 'Default': MOUNT [*]</pre>

This tells you that the 'Default' device handler was used, and the action being performed is MOUNT.  The portion(s) of the handler's whitelist which matched will be enclosed in square brackets [ ].

<!-- # Blacklist #black -->
A handler's blacklist is a space-separated list of elements.  If any element in the list matches the device properties, this handler will never be used for this device.

<p>For example, consider the following Whitelist/Blacklist combination:
<pre>
    Whitelist: vfat
    Blacklist: dev=/dev/sde1 label=Ignored_Volume_Label
</pre>

In this example, the handler applies to any vfat filesystem.  However, if the device file is /dev/sde1, OR the volume label on the device is "Ignored Volume Label" (or "Ignored_Volume_Label"), the handler will not be used.

<!-- # Mount -->
The Mount text box contains the commands which will be run if this handler is selected to mount a device (manually or automatically).  The commands are run as a bash script, and may contain any valid bash syntax (version 4, or any greater version of bash you have installed).  If the Run In Terminal box is checked, the script will be run in your configured terminal emulator window (which may allow the user to enter information).  You can also edit the commands in your configured editor by clicking on 'Edit' in the upper-right corner, or press Alt-Enter while the cursor is in the box (remember to save the script in your editor when finished).

<p>Several variables will be replaced before your commands are run:
<pre>
    %v  device
    %o  volume-specific mount options (use in mount command only)
    %t  filesystem type being mounted (eg vfat)
    %a  create auto mount point
</pre>

%v will be replaced with the device file (eg /dev/sdd1).  %o, if included, will be replaced with volume-specific mount options (these are set in <a href="#devices-settings-opts">Mount Options</a>).  Or, you can omit %o and simply include the options you desire in the command.

<p>Finally, the presence of %a will cause SpaceFM to create a new directory to be used as a mount point for the mount (eg ~/.cache/spacefm/mountpoint), and %a will be replaced with the directory path.  When the device is unmounted, this mount point will be removed.  Or, if you wish to create your own mount point, or if your mount program automatically creates one in /media (such as udevil), then you may omit %a.

<p>In addition to the above variables, SpaceFM's exported <a href="#exvar">bash variables</a> may be used, as well as the substitution variables defined in <a href="#designmode-props-command">Command Line</a>.

<p>Example Mount commands (enable only one section by removing #):
<pre>
    # # udevil:
    #     udevil mount -o '%o' %v
    #
    # # pmount: (does not accept mount options)
    #     pmount %v
    #
    # # udisks v2:
    #     udisksctl mount -b %v -o '%o'
    #
    # # udisks v1: (enable all three lines!)
    #     fm_udisks=`udisks --mount %v --mount-options '%o' 2>&1`
    #     echo "$fm_udisks"
    #     [[ "$fm_udisks" = "${fm_udisks/ount failed:/}" ]]
</pre>

(Note:  Because udisks v1 does not return a proper error status on error, the above lines examine the output and set the exit status if appropriate, which triggers an error popup in SpaceFM.)

<p>If a handler's Mount command is empty (or contains only blank lines and comments), that handler will not be used.  If no handler is found with a non-empty Mount command, SpaceFM will automatically attempt to use udevil, pmount, udisks2, or udisks1 to mount the device (it will use whatever is installed, in this order of preference).

<p>NOTE:  Custom menu items, added with <a href="#designmode-designmenu-new">New|Command</a>, may also be set as primitive device handlers via their <a href="#designmode-props-opener">Use as handler for</a> option.  When a device is clicked, if the menu item is enabled based on the current browser context, this menu item's command will be run rather than any other configured device handler.  In addition, device events may be configured to trigger actions based on socket event <a href="#sockets-events-device">evt_device</a>.

<!-- # Unmount -->
The Unmount text box contains the commands which will be run if this handler is selected to unmount a device (manually or automatically).  The commands are run as a bash script, and may contain any valid bash syntax (version 4, or any greater version of bash you have installed).  If the Run In Terminal box is checked, the script will be run in your configured terminal emulator window.

<p>Several variables will be replaced before your commands are run:
<pre>
    %v  device
    %a  current mount point
</pre>

%v will be replaced with the device file (eg /dev/sdd1).  %a will be replaced with the directory which is the mount point of the device.

<p>In addition to the above variables, SpaceFM's exported <a href="#exvar">bash variables</a> may be used, as well as the substitution variables defined in <a href="#designmode-props-command">Command Line</a>.

<p>Example Unmount commands (enable only one section by removing #):
<pre>
    # # udevil:
    #     udevil umount %v
    #
    # # pmount:
    #     pumount %v
    #
    # # udisks v2:
    #     udisksctl unmount -b %v
    #
    # # udisks v1: (enable all three lines!)
    #     fm_udisks=`udisks --unmount %v 2>&1`
    #     echo "$fm_udisks"
    #     [[ "$fm_udisks" = "${fm_udisks/ount failed:/}" ]]
</pre>

(Note:  Because udisks v1 does not return a proper error status on error, the above lines examine the output and set the exit status if appropriate, which triggers an error popup in SpaceFM.)

<p>If a handler's Unmount command is empty (or contains only blank lines and comments), that handler will not be used.  If no handler is found with a non-empty Unmount command, SpaceFM will automatically attempt to use <a href="http://ignorantguru.github.io/udevil/">udevil</a>, pmount, udisks2, or udisks1 to unmount the device (it will use whatever is installed, in this order of preference).

<!-- # Properties -->
The Properties text box contains the commands which will be run if the user selects Properties from the right-click menu of the devices list.  This is used to show any relevant properties and status of the device.  If the Run In Terminal box is checked, the script will be run in your configured terminal emulator window, otherwise the output will be displayed in a SpaceFM popup window.

<p>If no applicable device handler has a non-empty Properties command, SpaceFM's default properties will be shown.

<!-- # Defaults Buttons #defbut -->
Each handler configuration window includes Defaults and All Defaults buttons.  Pressing Defaults will restore the current handler's values to their defaults.  The handler must be a built-in default handler for this button to be enabled.  The All Defaults button will replace any missing default handlers that have been removed from the handlers list, and will also ask if you want to overwrite all existing default handlers.  If you answer yes, all default handlers will be reset.  If you answer no, only missing handlers will be added.  Any custom handlers you have added are not affected.

<!-- @Handlers @Protocols #pro -->
<a name="gui-pathbar-protohand"><p>Protocol handlers</a> <!-- backwards compat link --> tell SpaceFM how to respond when a URL is opened or unmounted, such as mounting or unmounting a network filesystem, or showing properties for a mounted URL.  Anytime you enter a URL in SpaceFM's <a href="#gui-pathbar-proto">Path Bar</a> (eg ftp://mirrors.kernel.org), open a bookmark containing a URL, select Open URL from the file menu, or specify a URL on the command-line, a handler is used to open the URL.  This handler can run another program (such as a web browser), can mount the URL as a filesystem, or take any other action you specify.

<p>To configure protocol handlers, right-click in the Path Bar and select Protocol Handlers, or select Settings|Protocol Handlers from the Devices menu.  Like <a href="#handlers-dev">Device Handlers</a>, protocol handlers have an Enable checkbox, a whitelist and blacklist which determine when the handler is used, and command boxes. 

<!-- # Whitelist #white -->
As with device handlers, a protocol handler's whitelist is a space-separated list of elements.  In general, if any element in the list matches the protocol properties, then this handler may be used.  If a list element is prefixed with a plus sign '+', that element is <i>required</i> to match.  Any element in the list may contain wildcards (an asterisk '*' to represent multiple characters, or a question mark '?' to represent single characters).  

<P>SpaceFM recognizes a path bar entry as a protocol if it has the form PROTOCOL:// (such as ftp://).  SpaceFM recommends a <a href="#gui-pathbar-proto">standard URL format</a> regardless of protocol.  If the URL is in such a format, SpaceFM will break the URL into parts and assign them to variables ready for your use.  You can also use other URL formats (eg those specific to a mount program), but SpaceFM may not correctly assign the parts to variables.

<p>The following protocol whitelist elements are recognized:
<pre>
    PROTOCOL (eg ssh)
    url=URL (ssh://...)
    host=HOSTNAME
    user=USERNAME
    mtab_fs=FSTYPE      (mounted fs type as shown in mtab)
    mtab_url=URL        (mounted url as shown in mtab)
    point=MOUNT_POINT
</pre>

For most protocols, the whitelist will be as simple as the protocol, such as 'ftp'.  For other protocols, you might use a whitelist like:
<pre>    ssh mtab_fs=fuse.sshfs</pre>

In this case, the handler is selected if the protocol is "ssh", which will work when mounting an ssh filesystem.  However, when fuse mounts the filesystem, it uses "fuse.sshfs" as the filesystem type, which is listed in mtab (see the output of the <code>mount</code> command).  Thus this whitelist also includes "mtab_fs=fuse.sshfs", so this handler will be used for that filesystem type in mtab.  This will allow the handler to be used for both mounting ssh URLs and unmounting fuse.sshfs filesystems.

<p>Note: The whitelist mtab_fs= property also may affect what mounted protocols SpaceFM detects and lists in its Devices list.  By default, SpaceFM will list most non-block (eg fuse) filesystems which are mounted to a user-readable directory.  To have it detect and list another filesystem in the devices list, add the type with mtab_fs=FSTYPE to a protocol handler's whitelist.  This will also ensure that your protocol handler, rather than a device handler, is used to unmount and show properties for the mounted protocol.

<p>Note that some of the above fields, such as mtab_fs, mtab_url, and point, are only set when performing an unmount.  Also, any spaces in the values are replaced with underscores before being tested.

<p>To see what handler SpaceFM has selected to mount or unmount a URL, and see the commands being issued, start the <code>spacefm</code> program in a terminal window, and observe debugging output in the terminal while SpaceFM is running.  For example, mounting and unmounting an ssh URL you may see:
<pre>
    Selected Protocol Handler 'ssh': MOUNT [ssh] mtab_fs=fuse.sshfs
    Selected Protocol Handler 'ssh': UNMOUNT ssh [mtab_fs=fuse.sshfs]
</pre>

This tells you that the 'ssh' protocol handler was used for both MOUNT and UNMOUNT actions.  The whitelist of that handler is shown, and the portion(s) of the handler's whitelist which matched are enclosed in square brackets [ ].  For mounting, the URL was recognized with protocol ssh, which matched in the whitelist.  For unmounting, the mtab_fs matched the whitelist.

<p>After your protocol is mounted, the mount directory may or may not automatically open in SpaceFM (depending on whether SpaceFM can associate a new device with the protocol just mounted based on mtab, mount point, etc.)  If it does not open, you can open a mount point after a successful mount command by adding a line such as:
<pre>    [[ $? -eq 0 ]] && spacefm -t "%a"</pre>


<!-- # Blacklist #black -->
As with device handlers, a protocol handler's blacklist is a space-separated list of elements.  If any element in the list matches the protocol properties, this handler will never be used for this device.

<!-- # Mount -->
The Mount text box contains the commands which will be run if this handler is selected to handle an entered URL.  The commands are run as a bash script, and may contain any valid bash syntax (version 4, or any greater version of bash you have installed).  If the Run In Terminal box is checked, the script will be run in your configured terminal emulator window (which may allow the user to enter information, such as a password).  You can also edit the commands in your configured editor by clicking on 'Edit' in the upper-right corner, or press Alt-Enter while the cursor is in the box (remember to save the script in your editor when finished).

<p>Several variables will be replaced before your commands are run:
<pre>
    %url%     $fm_url
    %proto%   $fm_url_proto
    %host%    $fm_url_host
    %port%    $fm_url_port
    %user%    $fm_url_user
    %pass%    $fm_url_pass
    %path%    $fm_url_path
    %a        auto create mount point
</pre>

These variables will be replaced with the appropriate values taken from a standard URL, and the bash equivalents may also be used (eg %url% is the same as $fm_url).  In the case of %a, its presence will cause SpaceFM to create a new directory to be used as a mount point for the mount (eg ~/.cache/spacefm/mountpoint, and %a will be replaced with the directory path.  When the device is unmounted, this mount point will be removed.  Or, if you wish to create your own mount point, or if your mount program automatically creates one in /media (such as udevil), then you may omit %a.

<p>In addition to the above variables, SpaceFM's exported <a href="#exvar">bash variables</a> may be used, as well as the substitution variables defined in <a href="#designmode-props-command">Command Line</a>.

<p>Note that the Mount command does not need to be used to mount a protocol, it may simply open the protocol with a program of your choice.  For example, to open http:// URLs with Firefox, put "http" in the handler's whitelist, and use this Mount command:
<pre>    firefox "%url%" &</pre>

The ampersand (&amp;) tells bash to run the program and move on, without waiting for the program to finish, which is usually appropriate when starting an application.

<p>You can also open a website using a SpaceFM socket command, which will guess the user's web browser:
<pre>    spacefm -s run-task <a href="#run-task-web">web</a> "$fm_url"</pre>

<p>If a handler's Mount command is empty (or contains only blank lines and comments), that handler will not be used.  If no handler is found with a non-empty Mount command, SpaceFM will not handle the protocol, and will display an error to the user.

<!-- # Unmount -->
The Unmount text box contains the commands which will be run if this handler is selected to unmount a mounted URL, generally a network filesystem such as sshfs.

<p>Several variables will be replaced before your commands are run:
<pre>
    %url%     $fm_url
    %proto%   $fm_url_proto
    %host%    $fm_url_host
    %port%    $fm_url_port
    %user%    $fm_url_user
    %path%    $fm_url_path
    %a        current mount point
	      $fm_mtab_fs   (mounted fs type as shown mtab)
	      $fm_mtab_url  (mounted url as shown mtab)
</pre>

Not all of the variables may be filled-in, depending on the protocol.

<p>If a protocol handler's Unmount command is empty (or contains only blank lines and comments), that handler will not be used.  If no handler is found with a non-empty Unmount command, SpaceFM will not unmount the filesystem, and will display an error to the user.

<!-- # Properties -->
The Properties text box contains the commands which will be run if the user selects Properties from the right-click menu of the devices list.  This is used to show any relevant properties and status of a mounted protocol.  If the Run In Terminal box is checked, the script will be run in your configured terminal emulator window, otherwise the output will be displayed in a SpaceFM popup window.

<p>If no applicable protocol handler has a non-empty Properties command, SpaceFM's default properties will be shown.

<!-- @Handlers @Archives #arc -->
<p>SpaceFM includes a built-in facility for creating, extracting, and listing the contents of archive files (such as tar.gz or zip files).

<!-- # Open Menu #arcopen -->
SpaceFM's Open menu for archive files, accessed by right-clicking on any archive file, allows you to choose Extract, Extract To, or List Contents.  By default, choosing Extract will extract the selected archive files to folders of the same name, choosing Extract To will allow you to choose where to extract the files, or choosing List Contents will display the contents of the archive file(s).

<!-- # Archive Defaults #arcdef -->
<p>With a default configuration, opening an archive file by double-clicking it in the file list will automatically extract it to a folder of the same name.  You can change how SpaceFM opens archives by right-clicking on an archive file and using the Open|Archive Defaults submenu:

<p><b>Open With App</b><br>
Selecting Open With App will cause SpaceFM to open archive files using whatever MIME application is associated with the file type on your system.  This application will appear at the top of the Open menu, and can be changed using SpaceFM's <a href="#designmode-mime">MIME Menu</a>.  Even if you have Open With App selected as the default behavior for opening archive files, you can still manually choose Extract, Extract To, and List Contents from the Open menu to use SpaceFM's built-in archive facility.

<p><b>Extract</b><br>
Extract is the default behavior of SpaceFM.  If selected, double-clicking on an archive in the file list will automatically extract its contents to a folder.

<p><b>Extract To</b><br>
The Extract To behavor is similar to Extract - it will extract the archive contents to a folder - except that you will be able to choose the destination folder.  Also, the Extract To dialog includes Create Subfolder and Write Access options (see below).

<p><b>List Contents</b><br>
If List Contents is selected, double-clicking on an archive file will open a terminal window displaying the contents of the selected archive, but it will not be extracted.

<p>In addition, the Archive Defaults submenu includes these options:

<p><b>Create Subfolder</b><br>
If this option is selected, which is the default, then using Extract (manually or automatically on open) will create a subfolder with the same name as the archive, and will extract the contents to it.  If this option is not selected, the archive contents will be extracted to the current folder.  (Note that the Extract To dialog also contains a Create Subfolder option for that operation - that setting is remembered separately).  Note that with Create Subfolder disabled, <b>some archive programs, such as tar , may overwrite files in the current folder</b> if they have the same name as files in the archive.

<p><b>Write Access</b><br>
If this option is selected, after extraction the contents of the extraction folder will be made write-accessible to the current user.  This option is only available if the Create Subfolder option is enabled, and if the user is not root.  Because some archives (such as tar.gz files made from CDROM) contain read-only files which then require an extra step to delete, this convenience option ensures the user can delete and change the extracted files.

<p><b>Archive Handlers</b><br>
Selecting Archive Handlers opens the Archive Handlers configuration window (see below).

<!-- # Archive Handlers #archand -->
<p>Archive handlers tell SpaceFM how to create, extract, and list the contents of various kinds of archive files (eg tar.gz files).  To configure archive handlers, right-click on a known archive file and select Open|Archive Defaults|Archive Handlers. Or, right-click on any file, select New|Archive, and click the Configure button.

<p>The list at the left of the Archive Handlers configuration window lists all archive handlers.  (Enlarge this window to see the handler commands more clearly.)  Click on a handler's name to see its contents.  The order of the list is important: Starting from the top, the first handler which matches a file being extracted will be used.  You can reorder the list by dragging entries, or using the Up &amp; Down buttons.

<p>The right side of the window shows the selected handler's contents.  If Enable Handler is unchecked, this handler will never be used.  The Name contains the common name for the handler.  Next come MIME Type and Pathname text boxes: these determine when this handler will be used.  Finally, the Compress, Extract, and List boxes contain scripted commands which will be run by the handler to perform archive functions.

<p><b><u>MIME Type</u></b><br>
This text box contains a space-separated list of MIME types (such as application/x-compressed-tar), which is used to associate the handler with those file types.  Wildcards, such as asterisk '*' to represent multiple characters, and question mark '?' to represent a single character, are accepted.  A handler must have a MIME Type or a Pathname pattern (see below), or it cannot be used to extract or list the contents of archive files.

<p><b><u>Pathname</u></b><br>
This text box contains a space-separated list of pathname globs to be used in addition to MIME type to identify files compatible with this handler.  For example, a Pathname pattern of "*.tar.gz" will cause all filenames ending in ".tar.gz" to be associated with this handler.  The first pathname pattern in the list will determine the default file extension used when creating archives with this handler.  Note that the full pathname of the file (eg /home/user/archive.tar.gz) is tested against the pattern, so for advanced uses the pattern may contain directory parts (eg /home/user/*.tar.gz) to control how archives in specific locations are handled.

<p><b><u>Compress</u></b><br>
The Compress text box contains the commands which will be run if this handler is selected to create an archive (or a single compressed file, etc.)  The command(s) are run as a bash script, and may contain any valid bash syntax (version 4, or any greater version of bash you have installed).  If the Run In Terminal box is checked, the script will be run in your configured terminal emulator window (which may allow the user to enter information, such as a password).  You can also edit the commands in your configured editor by clicking on 'Edit' in the upper-right corner, or press Alt-Enter while the cursor is in the box (remember to save the script in your editor when finished).

<p>Several variables will be replaced before your commands are run:
<pre>
    %n: First selected filename/dir to archive
    %N: All selected filenames/dirs to archive, or (with %O) a single filename
    %o: Resulting single archive file
    %O: Resulting archive per source file/directory (use changes %N meaning)
</pre>

When creating an archive, the user first selects one or more files or directories to be included.  These are passed to your command via the %n or %N variables, which are replaced with quoted filenames.  How these are used will depend on the type of archive you are creating from the selected files: a single archive containing all files, or an archive per source file/directory.

<p><b>If you want to create a single archive containing all selected items</b>, use %o to represent the name of the resulting archive file (which will be chosen by the user at run time).  With %o, you will generally use %N to include the list of all selected files.  (Or if you only use %n, only the first selected file will be included in your archive.)  For example, to create a tar archive, you would use this Compress command:
<pre>    tar -cvf %o %N</pre>

Other kinds of archiving programs, such as compressing files with GZip, <b>can only operate on one file at a time</b>.  In this case, you will use the %O variable (a capital 'O' instead of lowercase) to indicate to SpaceFM that you want your Compress command run multiple times, once for <i>each</i> selected file or directory.  In this case, %N will be replaced with a single filename each time the command is run.  (If %N is not included, the command will only be run once.  If you use %n with %O, it will only be replaced with the first selected file the first time the command is run, and will then be empty "" on any subsequent runs.)  For example, to compress all selected files with GZip, use this command:
<pre>    gzip -c %N > %O</pre>

When SpaceFM sees the above command containing %O, it will know to run the gzip command once for each file, and will replace %N with a single filename on each run.  It will also replace %O with a different output archive filename on each run, creating multiple files (in this case with the .gz extension).

<p>Note: To include a literal '%N' or other string in your command without it being interpreted as a variable, use double percent signs (%%N).

<p>In addition to the above variables, or instead of them, SpaceFM's exported <a href="#exvar">bash variables</a> may be used.

<p><b>To create an archive using your handler</b>, select files to be archived in SpaceFM's file list, right-click, and select New|Archive.  Select your handler in the Format list.  You can also edit the Compress command in this dialog, and the updated command will be saved to your handler.

<p><b>To test your handler commands</b>, run the <code>spacefm</code> program in a terminal, and observe the output as SpaceFM is working on archives.  This will show you the handlers chosen, and the commands exactly as they are issued.

<p>When running any commands in a terminal, SpaceFM will add a query at the end to keep the terminal open if it sees a non-zero error status from the last command run, or when listing archive contents.  If you need to keep the terminal open for other purposes, you can include these lines in your command:
<pre>
    echo -n '[ Finished ]  Press Enter to close:'
    read
</pre>

<p>To trap any errors in commands containing multiple lines, you can use the built-in error trap after each line:
<pre>    tar -cvf %o %N <b>|| fm_handle_err</b></pre>
 

<p><b><u>Extract</u></b><br>
The Extract text box contains the commands which will be run if this handler is selected to extract an archive (or uncompress a single compressed file, etc.)

<p>Several variables will be replaced before your commands are run:
<pre>
    %x: Archive file to extract
    %g: Unique extraction target filename with optional subfolder
    %G: Unique extraction target filename, never with subfolder
</pre>

In most cases, you will only need the %x variable to represent the file being extracted, as SpaceFM automatically runs your command in the directory to which files should be extracted.  For example, the Extract command for a tar file is simply:
<pre>  tar -xvf %x</pre>

In some cases, such as uncompressing a file with GZip, you will want SpaceFM to give you a single non-existing filename to be used as the extraction target.  For this purpose you may use %g or %G.  %g will cause SpaceFM to substitute a single non-existing filename based on the archive name.  If the user has selected the Create Subfolder option, a subfolder will also be created for the file.  However, in cases like GZip, it is often unnecessary to create a subfolder for just one file.  In this case use %G, which will be substituted with a single non-existing filename in the main extraction directory, and no subfolder will be created (even if the user has option Create Subfolder enabled).  For example, when decompressing a GZipped file, rather than create a subfolder for the single output file, SpaceFM simply uncompresses the file to the selected directory.  It uses this Extract command to do so:
<pre>    gzip -cd %x > %G</pre>

<p>In addition to the above variables, or instead of them, SpaceFM's exported <a href="#exvar">bash variables</a> may be used.

<p><b><u>List</u></b><br>
The List text box contains the commands which will be run if this handler is selected to list the contents of an archive file.  It recognizes only the %x variable which is replaced with the archive filename, and SpaceFM's exported <a href="#exvar">bash variables</a> may also be used.


<!-- @Handlers @Files #fil -->
<p>SpaceFM determines how to open files (for example when you double-click on a file) based on several methods.  By default, most files are opened with their <b>associated MIME application</b> on your system.  SpaceFM's <a href="#designmode-mime">MIME Menu</a> may be used to change the application associated with a file type on your system.

<p>In addition, <b>custom menu items</b> which have their context option <a href="#designmode-props-opener">Use as handler for:</a> set to 'files' may be used to open files .  When the menu item is enabled (based on the current browser context), the menu item's command will be run to open the file(s), rather than any MIME-associated application or other handler.  To add a custrom menu item of this kind, simply right-click on almost any existing menu item and select <a href="#designmode-designmenu-new">New|Command</a>.  On the <a href="#designmode-props-context">Context</a> page of the <a href="#designmode-props">Menu Item Properties</a> dialog, set 'Use as handler for: files'.  Also be sure to add context rules which determine when this handler will be active (or it will open all types of files).

<p>In addition, dedicated file handlers may be configured via the File Handlers configuration window described below.

<!-- # File Handlers #filhand -->
<p>File handlers tell SpaceFM how to open specific types of files, or can perform any other action.  These handlers work independently of the MIME associations on your system.  To configure file handlers, right-click on any file and select Open|Handlers.

<p>The list at the left of the File Handlers configuration window lists all file handlers.  (Enlarge this window to see the handler commands more clearly.)  Click on a handler's name to see its contents.  The order of the list is important: Starting from the top, the first handler which matches a file being opened will be used.  You can reorder the list by dragging entries, or using the Up &amp; Down buttons.

<p>The right side of the window shows the selected handler's contents.  If option 'Enable as a default opener' is checked, this handler will automatically run if you double-click on a file of its type.  Or, if the option is unchecked, the handler will only run if you manually select it from the Open menu.

<p>The Name and Icon text boxes are used to specify the common name and icon name for the handler, which will appear in the menu and Task Manager.  Next come MIME Type and Pathname text boxes: these determine for what files this handler may be used.  Finally, the Open Command box contains scripted commands which will be run by the handler to open the file(s), or perform any other function.

<p><b><u>MIME Type</u></b><br>
This text box contains a space-separated list of MIME types (such as text/plain), which is used to associate the handler with those file types.  Wildcards, such as asterisk '*' to represent multiple characters, and question mark '?' to represent a single character, are accepted.  For example, a MIME type of "video/*" will specify all video files.  A handler must have a MIME Type or a Pathname pattern (see below), or it will not be used.

<p><b><u>Pathname</u></b><br>
This text box contains a space-separated list of pathname globs to be used in addition to MIME type to identify files compatible with this handler.  For example, a Pathname pattern of "*.avi" will cause all AVI video files to be associated with this handler.  Note that the full pathname of the file (eg /home/user/videos/movie.avi) is tested against the pattern, so for advanced uses the pattern may contain directory parts (eg /home/user/videos/*.avi) to control how files in specific locations are handled.

<p><b><u>Open Command</u></b><br>
This text box contains the commands which will be run if this handler is selected to open one or more files.  The command(s) are run as a bash script, and may contain any valid bash syntax (version 4, or any greater version of bash you have installed).  If the Run In Terminal box is checked, the script will be run in your configured terminal emulator window (which may allow the user to enter information).  You can also edit the commands in your configured editor by clicking on 'Edit' in the upper-right corner, or press Alt-Enter while the cursor is in the box (remember to save the script in your editor when finished).

<p>Several variables will be replaced before your commands are run:
<center><table width="70%">
	<tr>
		<td>%F</td> <td>selected files</td>
	</tr><tr>
		<td>%f</td> <td>first selected file</td>
	</tr><tr>
		<td>%N</td>	<td>selected filenames</td>
	</tr><tr>
		<td>%n</td> <td>first selected filename</td>
	</tr><tr>
		<td>%d</td>	<td>current directory</td>
	</tr><tr>
		<td>%v</td>	<td>selected device (eg /dev/sda1)</td>
	</tr><tr>
		<td>%m</td>	<td>device mount point (eg /media/dvd)</td>
	</tr><tr>
		<td>%a</td>	<td>auto create mount point</td>
	</tr>
</table></center>

<p>The presence of %a will cause SpaceFM to create a new directory to be used as a mount point (eg ~/.cache/spacefm/mountpoint, and %a will be replaced with the directory path.  This can be used to mount files (eg iso files).  When the device is unmounted, this mount point will be removed.  For example, this command will mount an iso file using fuseoiso and open the mount point directory in SpaceFM:
<pre>    fuseiso %f %a && spacefm %a &amp;</pre>

<p>In addition to the above variables, SpaceFM's exported <a href="#exvar">bash variables</a> may be used, as well as all the substitution variables defined in <a href="#designmode-props-command">Command Line</a>.

<p>If the command ends with a non-zero error status, a popup will be shown.  When starting applications, it is best to add an ampersand (&amp;) to the end of the command, which tells bash to run the program and continue.  This will prevent it being shown in the task manager.  For example:
<pre>    geany %F &amp;</pre>

<p>When running your commands in a terminal, if you need to keep the terminal open after your command finishes, you can include these lines at the end of your command:
<pre>
    echo -n '[ Finished ]  Press Enter to close:'
    read
</pre>

<p><b>To test your handler commands</b>, run the <code>spacefm</code> program in a terminal, and observe the output as SpaceFM is opening files.  This will show you the handlers chosen, and the commands exactly as they are issued.


<!-- @Dialog @Introduction -->

<p>SpaceFM Dialog is a built-in feature of SpaceFM which allows you to easily create and control custom GTK dialogs.  Typically such dialogs are shown from scripts to gather information from the user.  SpaceFM Dialog allows scripts to easily use much of the power of GTK - a dialog can be as simple as a single message prompt or as complex as a mini-app with lists, editors, and other widgets.

<p>Dialog elements can have associated commands which are run when the user takes an action (such as pressing a button ), and internal commands can be used to modify the dialog elements while the dialog is running.  When SpaceFM Dialog exits, it writes variables to stdout which can be evaluated directly in bash, or easily parsed in other languages.

<p>Although SpaceFM Dialog is relatively easy to use, this portion of the manual assumes you have a basic understanding of command lines and scripts.  If you don't, try some of the examples and also consult the <a href="http://www.tldp.org/LDP/abs/html/index.html">Bash Scripting Guide</a> for reference.

<p><b>All of the example commands in this section can be pasted as-is into your terminal for a demonstration.</b>


<!-- @Dialog @Invocation -->
<p>SpaceFM Dialog runs as a separate instance, whether other instances of SpaceFM are running or not.  This means you can use SpaceFM Dialog from within custom command scripts in SpaceFM, or in other scripts which run independently.

<!-- # Help Reference #help -->
<p>To see SpaceFM Dialog's help reference, run:
<pre><b>$ spacefm -g help</b>
SpaceFM Dialog creates a custom GTK dialog based on the GUI elements you
specify on the command line, features run-time internal/external commands which
can modify elements, and outputs evaluatable/parsable results.
Usage:
    spacefm --dialog|-g {ELEMENT [OPTIONS] [ARGUMENTS...]} ...
Example:
    spacefm -g --label "A message" --button ok

<a href="#dialog-simple">ELEMENT</a>:       OPTIONS &amp; ARGUMENTS:
--------       --------------------
<a href="#dialog-simple-title">--title</a>        TEXT|@FILE
               Set window title
<a href="#dialog-simple-wicon">--window-icon</a>  ICON|@FILE
               Set window icon
<a href="#dialog-simple-label">--label</a>        [--wrap|--nowrap] LABEL|@FILE
               Add a text label
<a href="#dialog-simple-button">--button</a>       LABEL[:ICON]|STOCK|@FILE [COMMAND...]
               Add STOCK dialog button, or LABEL button with ICON
<a href="#dialog-simple-freebutton">--free-button</a>  LABEL[:ICON]|STOCK|@FILE [COMMAND...]
               Add STOCK button, or LABEL button with ICON anywhere
<a href="#dialog-simple-input">--input</a>        [--select START[:END]] [TEXT|@FILE [COMMAND...]]
               Add a text entry
<a href="#dialog-simple-inputl">--input-large</a>  [--select START[:END]] [TEXT|@FILE [COMMAND...]]
               Add a large text entry
<a href="#dialog-simple-password">--password</a>     [TEXT|@FILE [COMMAND...]]
               Add a password entry
<a href="#dialog-simple-viewer">--viewer</a>       [--scroll] FILE|PIPE [SAVEFILE]
               Add a file or pipe viewer
<a href="#dialog-simple-editor">--editor</a>       [FILE [SAVEFILE]]
               Add multi-line text editor
<a href="#dialog-simple-check">--check</a>        LABEL [VALUE|@FILE [COMMAND...]]
               Add a checkbox option
<a href="#dialog-simple-radio">--radio</a>        LABEL [VALUE|@FILE [COMMAND...]]
               Add a radio option
<a href="#dialog-simple-icon">--icon</a>         ICON|@FILE [COMMAND...]
               Add an icon
<a href="#dialog-simple-image">--image</a>        FILE|@FILE [COMMAND...]
               Add an image
<a href="#dialog-simple-progress">--progress</a>     [VALUE|pulse|@FILE]
               Add a progress bar
<a href="#dialog-simple-hsep">--hsep</a>         ( no arguments )
               Add a horizontal line separator
<a href="#dialog-simple-vsep">--vsep</a>         ( no arguments )
               Add a vertical line separator
<a href="#dialog-simple-timeout">--timeout</a>      [DELAY|@FILE]
               Automatically close window after DELAY seconds
<a href="#dialog-lists-drop">--drop</a>         {TEXT... --}|@FILE [DEFAULT|+N|@FILE [COMMAND...]]
               Add a drop-down list.  COMMAND run when clicked.
<a href="#dialog-lists-combo">--combo</a>        {TEXT... --}|@FILE [DEFAULT|+N|@FILE [COMMAND...]]
               Add a combo list.  COMMAND run when Enter pressed.
<a href="#dialog-lists-list">--list</a>         {[^HEAD[:TYPE]] [--colwidth=W] TEXT... --}|@FILE [COMMAND...]]
               Add a list box.  COMMAND run when double-clicked.
<a href="#dialog-lists-mlist">--mlist</a>        {[^HEAD[:TYPE]] [--colwidth=W] TEXT... --}|@FILE [COMMAND...]]
               Add a list box with multiple selections
<a href="#dialog-lists-chooser">--chooser</a>      [CHOOSER-OPTIONS] [DIR|FILE|@FILE [COMMAND...]]
               Options: [--save] [--dir] [--multi] [--filter F[:F...]]
<a href="#dialog-nonvis-prefix">--prefix</a>       NAME|@FILE
               Set base variable name  (Default: "dialog")
<a href="#dialog-nonvis-winsize">--window-size</a>  "WIDTHxHEIGHT [PAD]"|@FILE
               Set minimum width, height, padding (-1 = don't change)
<a href="#dialog-nonvis-hbox">--hbox</a>         [--compact] [PAD|@FILE]
               Add following widgets to a horizontal box
<a href="#dialog-nonvis-vbox">--vbox</a>         [--compact] [PAD|@FILE]
               Add following widgets to a vertical box
<a href="#dialog-nonvis-closebox">--close-box</a>
               Close the current box of widgets
<a href="#dialog-nonvis-keypress">--keypress</a>     KEYCODE MODIFIER COMMAND...
               Run COMMAND when a key combination is pressed
<a href="#dialog-nonvis-winclose">--window-close</a> COMMAND...
               Run COMMAND on window close attempt
<a href="#dialog-nonvis-command">--command</a>      FILE|PIPE [COMMAND...]
               Read commands from FILE or PIPE.  COMMAND for init.

The following arguments may be used as shown above:
    STOCK    ok|cancel|close|open|yes|no|apply|delete|edit|help|save|stop
    ICON     An icon name, eg:  gtk-open
    @FILE    A text file from which to read a value.  In some cases this file
             is monitored, so writing a new value to the file will update the
             element.  In other cases, the file specifies an initial value.
    SAVEFILE A <a href="#dialog-simple-viewer">viewer</a>'s or <a href="#dialog-simple-editor">editor</a>'s contents are saved to this file.
    <a href="#dialog-cmd">COMMAND</a>  An <a href="#dialog-int">internal command</a> or executable followed by arguments. Separate
             multiple commands with a -- argument.
             The following <a href="#dialog-cmd-sub">substitutions</a> may be used in COMMANDs:
                 %n           Name of the current element
                 %v           Value of the current element
                 %NAME        Value of element named NAME (eg: %input1)
                 %(command)   stdout from a bash command line
                 %%           %
    LABEL    The following escape sequences in LABEL are unescaped:
                 \n   newline
                 \t   tab
                 \"   "
                 \\   \
             In <a href="#dialog-simple-label">--label</a> elements only, if the first character in LABEL is a
             tilde (~), pango markup may be used.  For example:
                 --label '~This is plain. &lt;b&gt;This is bold.&lt;/b&gt;'

In addition to the OPTIONS listed above, --compact or --expand options may be
added to any element.  Also, a --font option may be used with most element
types to change the element's font and font size.  For example:
    --input --font "Times New Roman 16" "Default Text"

<a href="#dialog-int">INTERNAL COMMANDS</a>:
    <a href="#dialog-int-noop">noop</a>       ( any arguments )
               No operation - does nothing but evaluate arguments
    <a href="#dialog-int-close">close</a>      [REVERSE]
               Close the dialog
    <a href="#dialog-int-press">press</a>      BUTTON-NAME
               Press button named BUTTON-NAME
    <a href="#dialog-int-set">set</a>        NAME VALUE
               Set element NAME to VALUE
    <a href="#dialog-int-select">select</a>     NAME [VALUE]
               Select item VALUE (or first/all) in element NAME
    <a href="#dialog-int-unselect">unselect</a>   NAME [VALUE]
               Unselect item VALUE (or all) in element NAME
    <a href="#dialog-int-focus">focus</a>      [NAME [REVERSE]]
               Focus element NAME
    <a href="#dialog-int-hide">hide</a>       NAME [REVERSE]
               Hide element NAME
    <a href="#dialog-int-show">show</a>       [NAME [REVERSE]]
               Show element NAME if previously hidden
    <a href="#dialog-int-disable">disable</a>    NAME [REVERSE]
               Disable element NAME
    <a href="#dialog-int-enable">enable</a>     NAME [REVERSE]
               Enable element NAME if previously disabled
    <a href="#dialog-int-source">source</a>     FILE
               Save files and write source output to FILE
</pre>

<!-- # Usage #usage -->
The command line accepts any number of elements:
<pre>
    spacefm -g ELEMENT [OPTIONS] [ARGUMENTS] \
	       ELEMENT [OPTIONS] [ARGUMENTS] \
	       ELEMENT [OPTIONS] [ARGUMENTS] \
	       ...</pre>
where each ELEMENT has its own options and arguments.  An element represents one piece of the dialog.  It may be a widget, such as a label or button, or it may be an invisible element which controls how the dialog looks or behaves.

<p>For example, to show a dialog with a message label and an OK button, run this command:
<pre>    spacefm -g --label "This is a message." \
	       --button ok</pre>

Note: The forward slash (\) at the end of a line tells the terminal that the command is continued on the next line.  You can select both lines above, copy them, and paste them into a terminal to run the above example;  it is not necessary to copy and paste each line individually.  In this manual, SpaceFM Dialog commands are always shown with at most one element on each line for clarity.  These multi-line commands can also be pasted directly into scripts.

<p>OPTIONS may include options specific to the element type.  In addition, most elements accept a --font FONTNAME option to specify a font for the widget's text.  Also, all elements accept --compact or --expand options to force how an element is packed into the current box.


<!-- # Evaluating The Output #eval -->
When the above command is run, a message dialog will be shown.  When the OK button is pressed, the dialog will close and the following output will be written to the terminal:
<pre><i>    #!/bin/bash
    # SpaceFM Dialog source output - execute this output to set variables
    # Example:  eval "`spacefm --dialog --label "Message" --button ok`"

    dialog_label1='This is a message.'
    dialog_pressed='button1'
    dialog_pressed_index='0'
    dialog_pressed_label='ok'
    dialog_button1='ok'
    dialog_windowsize='450x100'</i></pre>

The above source output, written to stdout, is produced by the dialog to allow you to easily use element values in your script.  (To get this output while the dialog is still running, use <a href="#dialog-int-source">source</a>.) If using bash or another compatible shell, you can automatically evaluate this output to set the variables.  For example, you can run:
<pre>    <b>eval "`</b>spacefm -g --label "This is a message." \
	              --button ok<b>`"</b></pre>
Using this method, you will no longer see the output in the terminal when the dialog closes.  Instead, the output is fed into eval, which reads the variable values.  A command enclosed in backticks (`), <i>not to be confused with apostrophes</i> ('), evaluates to a string containing the stdout output of the command.  This output is then double-quoted (") and passed to eval, which interprets it (sets the variables).  (<b>Be sure to double-quote the backticks</b> as shown above or some data may be lost!)

<p>After running the above command, we can see the value is set:
<pre>    echo "$dialog_pressed"
    <i>button1</i></pre>

If you would like the output to also be written in the terminal, you can use the following method instead:
<pre>
    <b>out="`</b>spacefm -g --label "This is a message." \
    	             --button ok<b>`"</b>
    eval "$out"   # read
    echo "$out"   # display</pre>
The above commands place spacefm's output into the variable 'out', then pass that value to eval to set the variables, then echo writes the output to the terminal for you to see.

<p>Yet another method is to write the output to a file, then source the file.  For example:
<pre>
    spacefm -g --label "This is a message." \
	       --button ok <b>&gt; /tmp/outputfile</b>
    source /tmp/outputfile  # read
    cat /tmp/outputfile     # display
    rm /tmp/outputfile      # cleanup</pre>

<p>In general, anytime you need to use the dialog's variables in your script, you will want to <b>use one of the above methods</b> to evaluate the dialog's output.  Or, if your shell doesn't support eval, you can parse the output manually.



<!-- @Dialog @Simple Elements #simple -->
<p>Elements tell SpaceFM Dialog how to build your dialog.  Each element is similar to a command line - it includes an element followed by arguments.  When SpaceFM Dialog sees a new element on the command line, it knows the arguments for the previous element have ended.

<p>Most visible elements (widgets) are stacked vertically in the dialog (in a vbox), while buttons are packed horizontally at the bottom of the dialog:
<ul>
    ELEMENT1<br>
    ELEMENT2<br>
    ELEMENT3<br>
    BUTTON1 BUTTON2<br>
</ul>

The following elements may be used to create dialogs:

<!-- # --title #title -->
Usage: <code><b>--title TEXT|@FILE</b></code>

<p>The --title element sets the title of the dialog window ("SpaceFM Dialog" is the default title if no --title element is used).  For example:
<pre>    spacefm -g --title "A Window Title"</pre>

<b>--title also accepts a file instead of a string</b>.  For example:
<pre>    echo "A Window Title" > /tmp/dialog-title
    spacefm -g --title <b>@</b>/tmp/dialog-title</pre>

The "at" sign (@) indicates that a file path is being specified, and that SpaceFM Dialog should read the value from the first line of the file /tmp/dialog-title.  The file is also watched for changes.  This method allows you to later change the window title.  As the dialog is running, in another terminal run:
<pre>    echo "Another Window Title" > /tmp/dialog-title</pre>
and the dialog window's title will change to reflect the new value.  Thus using @FILE is one method which allows you to dynamically change the dialog as its running (commands being another method).

<p>In <a href="#dialog-cmd">commands</a>, the value of a title element (%title1) is the title's TEXT.  Also note that even if no --title element has been added to the dialog, you can later use the <a href="#dialog-int-set">set</a> command to set 'title' (no numeric suffix).
<br><br>

<!-- # --window-icon #wicon -->
Usage: <code><b>--window-icon ICON|@FILE</b></code>

<p>The --window-icon element sets the dialog window's icon ("spacefm-48-pyramid-blue" is the default icon if no --window-icon element is used).  For example:
<pre>    spacefm -g --window-icon gtk-open</pre>

<b>--window-icon also accepts a file instead of a string</b>.  For example:
<pre>    echo "gtk-open" > /tmp/dialog-wicon
    spacefm -g --window-icon <b>@</b>/tmp/dialog-wicon</pre>

The icon name will be read from the first line of the file /tmp/dialog-wicon.  The file is also watched for changes, allowing you to later change the window icon.  As the dialog is running, in another terminal run:
<pre>    echo "gtk-save" > /tmp/dialog-wicon</pre>
and the dialog window's icon will change to reflect the new value.

<p>In <a href="#dialog-cmd">commands</a>, the value of a window-icon (%windowicon1) is the icon name (ICON).  Also note that even if no --window-icon element has been added to the dialog, you can later use the <a href="#dialog-int-set">set</a> command to set 'windowicon' (no numeric suffix).

<p>See also: <a href="#dialog-nonvis-winsize">--window-size</a>
<br><br>

<!-- # --label #label -->
Usage: <code><b>--label [--wrap|--nowrap] LABEL|@FILE</b></code>

<p>The --label element adds a GTK label widget to the dialog, which is used to display one or more lines of text, such as a message for the user or a label for an input box.  For example:
<pre>    spacefm -g --label "The process is complete."</pre>

<b>--label also accepts a file instead of a string</b>.  For example:
<pre>    echo "The process is complete." > /tmp/dialog-label
    spacefm -g --label <b>@</b>/tmp/dialog-label</pre>

The label's text will be read from the file /tmp/dialog-label (which may contain multiple lines).  The file is also watched for changes, allowing you to later change the label's text.  As the dialog is running, in another terminal run:
<pre>    echo "Another processs is complete." > /tmp/dialog-label</pre>
and the text in the dialog window will change to reflect the new value in the file.

<p><b>As with most elements, you can add multiple --label elements to a dialog</b>.

<p><b>Some escape sequences are unescaped when LABEL is read</b>:
<center><table width="30%">
	<tr>
		<td>\n</td> <td>newline</td>
	</tr><tr>
		<td>\t</td> <td>tab</td>
	</tr><tr>
		<td>\"</td> <td>"</td>
	</tr><tr>
		<td>\\</td> <td>\</td>
	</tr>
</table></center>

<p>For example, to create a label with two lines:
<pre>    spacefm -g --label "This is line 1.<b>\n</b>This is line 2."</pre>

<p>Note that you can also set a label to multiple lines by specifying a @FILE which contains multiple lines, in which case \n is not needed (but may be used in files too).

<p><b>Labels can also include Pango markup text</b>, which can be used to italicize, bold, and otherwise stylize portions of text.  The --label element (only) recognizes the prefix character tilde (~) to indicate that your text is Pango markup.  For example:
<pre>    spacefm -g --label "<b>~</b>This is plain.  &lt;b&gt;This is bold.&lt;/b&gt;"</pre>

<p><b>Labels accept a --wrap or --nowrap option</b> to specify if the text in the label is to be wrapped to multiple lines.  If neither option is specified, the GTK2 default is to always wrap, and the GTK3 default is to wrap unless the label is packed into an <a href="#dialog-nonvis-hbox">--hbox</a> element.

<p>Like most elements, <b>--label also accepts a --font option</b> to change the font and font size of the text:
<pre>    spacefm -g --label <b>--font "Times New Roman 16"</b> "The process is complete."</pre>

Note that the --font option must come <i>directly after</i> the --label element.  In general it is best to use the default font unless your script is only intended for your own use.

<p>In <a href="#dialog-cmd">commands</a>, the value of a label (eg %label1) is the text of the label.
<br><br>


<!-- # --button #button -->
Usage: <code><b>--button LABEL[:ICON]|STOCK|@FILE [COMMAND...]</b></code>

<p>The --button element adds a button to the dialog.  All buttons are packed horizontally at the bottom of the dialog, in the order in which they are added (to add a button in the upper part of the dialog, use a <a href="#dialog-simple-freebutton">--free-button</a> instead).  Most dialogs should include at least an "OK" button.

<p>The easiest way to add a complete button is to use a STOCK name, which may be any one of:<br>
<b>&nbsp;&nbsp;&nbsp;ok|cancel|close|open|yes|no|apply|delete|edit|help|save|stop</b> <i>(in lowercase)</i>
<p><b>For example, to add a stock OK button:</b>
<pre>    spacefm -g --button ok</pre>
The button will include the stock gtk-ok icon on it (taken from your icon theme), and an "OK" label.

<p>If you don't want to use a stock button, <b>you can include a custom button label</b> instead:
<pre>    spacefm -g --button _Update</pre>
The underscore (_), which is optional, indicates that 'U' is to be shown as the shortcut key for this button (Alt-U).  Also note that a button label may contain multiple lines if desired.

<p><b>You can also add an icon to your button</b> using a colon:
<pre>    spacefm -g --button _Update<b>:gtk-apply</b></pre>

<b>--button also accepts a file instead of a string</b>.  For example:
<pre>    echo "_Update:gtk-apply" > /tmp/dialog-button
    spacefm -g --button <b>@</b>/tmp/dialog-button</pre>

The button's label and icon will be read from the first line of the file /tmp/dialog-button.  The file is also watched for changes, allowing you to later change the button's appearance.  As the dialog is running, in another terminal run:
<pre>    echo "close" > /tmp/dialog-button</pre>
and the button in the dialog window will change to reflect the new value in the file.

<p><b>When the user presses a button</b>, the dialog window will close if no COMMAND has been associated with the button.  The output will include several variables to allow your script to determine what button was pressed.  For example:
<pre><i>    dialog_pressed='button1'
    dialog_pressed_index='0'
    dialog_pressed_label='_Update:gtk-apply'</i></pre>

The first, "$dialog_pressed", contains the name of the button which was pressed to close the window, in this case "button1" (the first button added).  "$dialog_pressed_index" contains the index of the button.  Buttons are indexed left to right, starting from 0, so the first button you add has index 0, the second index 1, etc.  Finally, "$dialog_pressed_label" contains the "LABEL[:ICON]" used to create the button.  Thus your script can evaluate what button was pressed and take an action, as shown in the example script below:
<pre>    #!/bin/bash
    # <b>This script shows a Yes/No dialog</b>
    # Use QUOTED eval to read variables output by SpaceFM Dialog:
    eval "`spacefm -g --label "Are you sure?" --button yes --button no`"
    if [[ "$dialog_pressed" == "button1" ]]; then
        echo "User pressed Yes - take some action"
    else
        echo "User did NOT press Yes - abort"
    fi
</pre>

<p><b>Note: The stock 'cancel' button has a special function.</b>  If it is used to close the dialog (no COMMAND has been associated with the button), element @FILE values will NOT be saved.  In this case, the element values written to stdout may not match the values stored in @FILEs.  You can perform a <a href="#dialog-int-source">source</a> command first if you do want values to be written for @FILEs when Cancel is clicked.  [Note:  In SpaceFM 0.9.3 and prior, element @FILE values WERE saved when the user pressed Cancel.]

<p><b>Note:  If the window is closed by the user pressing the X in the top-right corner</b>, or by pressing Alt-F4, "$dialog_pressed" will be empty (no button was pressed) and "$dialog_pressed_index" will be -2.  Also, element @FILE values will NOT be saved, as if the user clicked a Cancel button.

<p><b>If a <a href="#dialog-cmd">command</a> is added to a button</b>, then the dialog will not necessarily close when the button is pressed.  Instead, the COMMAND(s) will be run.  The value of a button (eg %v, %button1, etc) is the "LABEL[:ICON]" used to create the button.

<p><b>The following example creates a dialog with a label and a button.</b>  When the button is pressed, the label is set to the current date.
<pre>
    spacefm -g --label \
	       --button 'Get Date' set label1 '%(date)'</pre>
<br>

<!-- # --free-button #freebutton -->
Usage: <code><b>--free-button LABEL[:ICON]|STOCK|@FILE [COMMAND...]</b></code>

<p>A --free-button element is similar to a <a href="#dialog-simple-button">--button</a>, except that it is packed into the top area of the dialog like any other widget, instead of being placed in the horizontal row of buttons at the bottom.

<p>Like a --button, if the user presses a --free-button that has no COMMAND, the dialog window will be closed.  The value of "$dialog_pressed_index" will always be -1 for a --free-button.
<br><br>

<!-- # --input #input -->
Usage: <code><b>--input [--select START[:END]] [TEXT|@FILE [COMMAND...]]</b></code>

<p>An --input element adds a GTK entry widget to the dialog, which allows the user to enter text in a single-line box.  This can be as simple as:
<pre>   spacefm -g --input</pre>

If you would like the box to already have default text in it when the dialog is first shown, add your text on the command line:
<pre>   spacefm -g --input <b>"Some default text"</b></pre>

<b>--input also accepts a file instead of a string</b>.  For example:
<pre>    echo "Some default text" > /tmp/dialog-input
    spacefm -g --input <b>@</b>/tmp/dialog-input</pre>

The input's default text will be read from the first line of the file.  The file is also watched for changes, allowing you to later change the input's contents.  As the dialog is running, in another terminal run:
<pre>    echo "Some other text" > /tmp/dialog-input</pre>
and the text in the input box will change to reflect the value in the file.

<p><b>Also, when the dialog is closed, the text in the input will be saved to the file</b>.  This method can be used to have the dialog remember the last text entered.  The next time the dialog is run, assuming the file hasn't been deleted, the input will show the text from the previous dialog.

<p><b>A portion of the text may be selected when the dialog first opens</b> using the --select option.  By default, all of the text is selected.  If you only want to select a portion, use a command like:
<pre>   spacefm -g --input <b>--select 3:6</b> "Some default text"</pre>

Note that the --select option must come <i>directly after</i> the --input element.  The first number (START) is the first character to select, and the second number (:END), if included, is the last.  So "--select 3:6" will select characters 3 thru 6.  Note that counting starts from zero: the first chracter has index 0, the second 1, etc.  If END is negative or omitted, text will be selected from START through the end of the text.

<p><b>--input also accepts a --font option</b> to change the font and font size of the text:
<pre>    spacefm -g --input <b>--font "Times New Roman 16"</b> "Some default text"</pre>

<b>When the user presses Enter in an input box</b>, one of several things may happen.  If no COMMAND is associated with the input, then the right-most button at the bottom of the dialog will be automatically pressed.  If the dialog has no buttons, nothing will happen.

<p>Or, if a <a href="#dialog-cmd">command</a> is added to the input, the COMMAND(s) will be run and no button will be automatically pressed.  The value of an input (eg %v, %input1, etc) is the text in the box when the command is run.

<p>In SpaceFM Dialog's output, the value of an input can be read from, for example, "$dialog_input1".

<p><b>The following example creates a dialog with an input and a label.</b>  When Enter is pressed in the input box, the text of the input is copied to the label.
<pre>
    spacefm -g --label "Enter some text and press Enter:" \
               --input "" set label2 %v \
	       --label \
	       --button close</pre>
<br>


<!-- # --input-large #inputl -->
Usage: <code><b>--input-large [--select START[:END]] [TEXT|@FILE [COMMAND...]]</b></code>

<p>An --input-large element works identically to an <a href="#dialog-simple-input">--input</a>, except that the text box is larger.  It still contains a single line of text, but the text may be wrapped to several display lines.  Such boxes are useful for editing long lines, such as a file path.
<br><br>


<!-- # --password #password -->
Usage: <code><b>--password [TEXT|@FILE [COMMAND...]]</b></code>

<p>A --password element, used to enter a password, is similar to an <a href="#dialog-simple-input">--input</a>, except that the text is hidden.  Also, the options --select and --font have no effect on a --password element.
<br><br>



<!-- # --viewer #viewer -->
Usage: <code><b>--viewer [--scroll] FILE|PIPE [SAVEFILE]</b></code>

<p>A --viewer element adds a read-only multi-line text box to the dialog, and may be used to view the contents of a file or the data written to a pipe.  By writing text to a temporary file, a viewer can also be used to show the user larger amounts of text which won't fit in a --label.  A vertical scroll bar will automatically appear when the text exceeds the size of the box.

<p><b>To view the static or changing contents of a regular file:</b>
<pre>    spacefm -g --viewer /etc/fstab</pre>

Anytime the contents of the file changes, the viewer will be updated.  If you always want the viewer to scroll to the end of the file (except when the user pulls the scroll handle up), include the --scroll option:
<pre>    spacefm -g --viewer <b>--scroll</b> /etc/fstab</pre>

<p><b>A --viewer may also be used to monitor data written to a pipe.</b>  This can be used to show the user changing information.  For example:
<pre>    # First, create a pipe:
    mkfifo /tmp/dialog-pipe
    # Next, monitor the pipe:
    spacefm -g --viewer /tmp/dialog-pipe
</pre>

When you write text to the pipe, it will be added to the viewer box.  For example, while the dialog is running, in another terminal run:
<pre>    echo "some text to a pipe" > /tmp/dialog-pipe</pre>

Or:
<pre>    # Press Ctrl-C to cancel:
    while (( 1 )); do date > /tmp/dialog-pipe; sleep 1; done</pre>

<b>When the dialog is closed, the contents of the viewer are lost unless a SAVEFILE is also specified:</b>
<pre>    spacefm -g --viewer /tmp/dialog-pipe <b>/tmp/dialog-pipe-contents</b></pre>

<p>In <a href="#dialog-cmd">commands</a>, the value of a viewer (eg %viewer1) is the path of the file being viewed.  To change the file being viewed, use <a href="#dialog-int-set">set</a> (eg 'set viewer1 /etc/mtab').  Also note that the contents of the viewer are also saved to SAVEFILE whenever the internal command <a href="#dialog-int-source">source</a> is run.

<p><b>The following example creates a dialog with a <a href="#dialog-lists-chooser">file chooser</a> and a viewer.</b>  When the user double-clicks a text file in the chooser, the file's contents are displayed.
<pre>    spacefm -g --label "Double-click a file to view:" \
               --chooser --filter text/plain . set viewer1 %v \
               --viewer \
	       --button close</pre>
<br>


<!-- # --editor #editor -->
Usage: <code><b>--editor [FILE [SAVEFILE]]</b></code>

<p>Similar to a <a href="#dialog-simple-viewer">--viewer</a>, an --editor element adds a multi-line text box to the dialog.  Unlike a viewer, the user is able to edit the text in the box.  To create an empty editor:
<pre>    spacefm -g --editor</pre>

Or, to load a text file into the editor:
<pre>    spacefm -g --editor <b>/etc/fstab</b></pre>

<b>When the dialog is closed, the contents of the editor are lost unless a SAVEFILE is also specified:</b>
<pre>    spacefm -g --editor /etc/fstab <b>/tmp/fstab-edited</b></pre>

When the above dialog is closed, the contents of the editor will be automatically saved to /tmp/fstab-edited.  Your script can then use this file to replace the original if the user pressed the appropriate button, etc.

<p>Note:  It is possible to set FILE and SAVEFILE to the same path, in which case the original file will automatically be overwritten when the dialog is closed, <i>regardless of what button is pressed</i>!

<p>In <a href="#dialog-cmd">commands</a>, the value of an editor (eg %editor1) is the path of the file last loaded.  To load a file into the editor, use <a href="#dialog-int-set">set</a> (eg 'set editor1 /etc/mtab').  Also note that the contents of the editor are also saved to SAVEFILE whenever the internal command <a href="#dialog-int-source">source</a> is run.

<p><b>The following example creates a dialog with a file chooser and an editor.</b>  When the user double-clicks a text file in the chooser, the file's contents are displayed in the editor.  If the user clicks the Save button, the editor's contents are saved to a temporary file (they are also saved when the dialog closes).

<pre>    spacefm -g --label "Double-click a file to edit a copy:" \
               --chooser --filter text/plain . set editor1 %v \
               --editor "" /tmp/dialog-copy \
	       --label \
	       --button save source /dev/null -- \
	                     set label2 "Copy saved to /tmp/dialog-copy" \
	       --button close</pre>
<br>


<!-- # --check #check -->
Usage: <code><b>--check LABEL [VALUE|@FILE [COMMAND...]]</b></code>

<p>A --check element adds a checkbox and associated label to the dialog, allowing the user to check or uncheck the option.  The value of the checkbox can be read from a variable when the dialog closes, or it can be used by internal commands while the dialog is running.  For example:
<pre>    spacefm -g --check "Option One"</pre>

By default, the checkbox will not have a check in it.  To set a default value for the checkbox, specify "false" or "0" (unchecked), or "true" or "1" (checked).  For example:
<pre>    spacefm -g --check "Option One" <b>1</b></pre>

<b>--check also accepts a file instead of a string</b> for the VALUE (but not for the LABEL).  For example:
<pre>    echo 1 > /tmp/dialog-check
    spacefm -g --check "Option One" <b>@</b>/tmp/dialog-check</pre>

The checkbox's default value will be read from the first line of the file.  The file is also watched for changes, allowing you to later change the state of the checkbox.  As the dialog is running, in another terminal run:
<pre>    echo 0 > /tmp/dialog-check</pre>
and the checkbox state will change to reflect the value in the file.

<p><b>Also, when the dialog is closed, the state of the checkbox will be saved to the file</b>.  This method can be used to have the dialog remember the state.  The next time the dialog is run, assuming the file hasn't been deleted, the checkbox will have the same state as when the previous dialog was closed.

<p>If a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run whenever the checkbox changes state, either due to the user clicking it, its @FILE value changing, or its value being set with an internal command.  (The command is NOT run when the state is set to a default VALUE during dialog creation.)

<p>In commands, the value of a --check element (eg %check1) will equal 1 or 0, reflecting whether the box is checked or not.  If internal command <a href="#dialog-int-set">set</a> is used on a --check and the value is not "0", "false", "1", or "true", the check's LABEL is set to the value (eg "set check1 "A new option label"), instead of the state being changed.

<p>In SpaceFM Dialog's output, the value of a check can be read from, for example, "$dialog_check1".

<p><b>The following example creates a dialog with a check and a label.</b>  If the checkbox is checked, the label is shown, otherwise it is hidden.
<pre>
    spacefm -g --check "Show text" 1 show label1 %v \
               --label "Some text"
</pre>

The check's value in the above command works as a reversal in the <a href="#dialog-int-show">show</a> command - if %v is "0" then label1 is hidden, otherwise it is shown.
<br><br>



<!-- # --radio #radio -->
Usage: <code><b>--radio LABEL [VALUE|@FILE [COMMAND...]]</b></code>

<p>A --radio element is similar to a <a href="#dialog-simple-check">--check</a>, adding a radio button and associated label to the dialog, allowing the user to select or unselect the option.  However, only one of a set of radio buttons may be selected at a given time - selecting one will unselect the others in the set.  To add a --radio element:
<pre>    spacefm -g --radio "Apples"</pre>

By default, the first --radio element of a set will be selected.  To select another --radio element, include a default VALUE, specifying "false" or "0" (unselected), or "true" or "1" (selected).  For example:
<pre>    spacefm -g --radio "Apples" <b>1</b></pre>

Remember that only one --radio can be selected, so the last --radio element you add with a 1 VALUE will be selected.

<p>Consecutive --radio elements are part of the same set, until a visible non-radio element is added.  For example, these elements will be part of a set:
<pre>
    spacefm -g --radio "Apples"    \
	       --radio "Oranges" 1 \
	       --radio "Pears"</pre>

In the above example, Oranges will be selected by default.

<p>As with --check elements, a @FILE may be substituted for VALUE, causing SpaceFM Dialog to read the value from the first line of the file.  The state will be updated if the file is changed.  The value will also be written to the file when the dialog closes.

<p><b>To have a dialog remember the selection of a radio set, you must specify a different file for <i>each element</i>.</b>  For example:
<pre>
    spacefm -g --radio "Apples"  <b>@</b>/tmp/dialog-radio<b>1</b> \
	       --radio "Oranges" <b>@</b>/tmp/dialog-radio<b>2</b> \
	       --radio "Pears"	 <b>@</b>/tmp/dialog-radio<b>3</b></pre>

The files do not need to be created (they will be created automatically), unless you want to select an option other than the first.  If you run the above command multiple times, you will note that your selection is remembered from the previously closed dialog.

<p>If a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run whenever the radio button is selected (but not when it is unselected), either due to the user clicking it, its @FILE value changing, or its value being set with an internal command.  (The command is NOT run when the state is set to a default VALUE during dialog creation.)

<p>In commands, the value of a --radio element (eg %radio1) will equal 1 or 0.  If internal command <a href="#dialog-int-set">set</a> is used on a --radio and the value is not "0", "false", "1", or "true", the radio's LABEL is set to the value (eg "set radio1 "A new option label"), instead of the state being changed.

<p>In SpaceFM Dialog's output, the value of each --radio in a set can be read from, for example, "$dialog_radio1", "$dialog_radio2", etc.
<br><br>



<!-- # --icon #icon -->
Usage: <code><b>--icon ICON|@FILE [COMMAND...]</b></code>

<p>An --icon element packs a dialog-sized icon into the dialog.  ICON specifies an icon name (not a path - to use a path use <a href="#dialog-simple-image">--image</a> instead).  The icon is selected using your current icon theme.  For example:
<pre>    spacefm -g --icon gtk-open</pre>

<b>--icon also accepts a file instead of a string</b>.  For example:
<pre>    echo "gtk-open" > /tmp/dialog-icon
    spacefm -g --icon <b>@</b>/tmp/dialog-icon</pre>

In this case, the icon name is read from the first line of the file /tmp/dialog-icon.  This file is also watched, so when its contents change, the icon will change.  As the dialog is running, in another terminal run:
<pre>    echo "gtk-close" > /tmp/dialog-icon</pre>
and the icon will change to reflect the value in the file.

<p>If a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run whenever the icon is clicked.  For example:
<pre>    spacefm -g --icon gtk-open <b>bash -c 'echo "# %n clicked %v" &gt;&amp;2'</b></pre>

When you run the above command and click the icon in the dialog, a message will be written to the terminal showing what mouse button was pressed and the location of the click.  Both values are in the element's value (%v).  Note that the location is relative to the upper-left corner of the event box holding the icon, not necessarily the corner of the icon itself (pack the icon into a compact <a href="#dialog-nonvis-vbox">--vbox</a> for the latter).

<p>In commands, the value of an --icon element (eg %icon1) when referenced from another element will equal the icon name, while the current --icon element's value (%v) will equal the mouse button and click location.  If internal command <a href="#dialog-int-set">set</a> is used on an --icon, the icon name is changed.
<br><br>

<!-- # --image #image -->
Usage: <code><b>--image FILE|@FILE [COMMAND...]</b></code>

<p>An --image element packs an image into the dialog.  If FILE isn't found or can't be loaded, the resulting image will display a 'broken image' icon.  If the file contains an animation, the image will contain an animation.  Not all image formats are supported.  For example:
<pre>    spacefm -g --image ~/example-image.jpg</pre>

<b>--image also accepts a file instead of a string</b>.  For example:
<pre>    echo "~/example-image.jpg" > /tmp/dialog-image
    spacefm -g --image <b>@</b>/tmp/dialog-image</pre>

In this case, the image FILE path is read from the first line of the file /tmp/dialog-image.  This file is also watched, so when its contents change, the image will change.  As the dialog is running, in another terminal run:
<pre>    echo "~/another-image.jpg" > /tmp/dialog-image</pre>
and the image will change to reflect the value in the file.

<p><b>Images are not resized</b>.  They are displayed at their full size, so only small images can be comfortably packed into a dialog.  [Resizing options may be added soon - check this manual for updates.]

<p>If a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run whenever the image is clicked.  For example:
<pre>    spacefm -g --image ~/example-image.jpg <b>bash -c 'echo "# %n clicked %v" &gt;&amp;2'</b></pre>

When you run the above command and click the image in the dialog, a message will be written to stderr of the terminal showing what mouse button was pressed and the location of the click (bash -c is required to send the output to stderr instead of stdout).  Both values are in the element's value (%v).  Note that the location is relative to the upper-left corner of the event box holding the image, not necessarily the corner of the image itself (pack the image into a compact <a href="#dialog-nonvis-vbox">--vbox</a> for the latter).

<p>In commands, the value of an --image element (eg %image1) when referenced from another element will equal the image FILE path, while the current --image element's value (%v) will equal the mouse button and click location.  If internal command <a href="#dialog-int-set">set</a> is used on an --image, the image path is changed.
<br><br>

<!-- # --progress #progress -->
Usage: <code><b>--progress [VALUE|pulse|@FILE]</b></code>

<p>A --progress element adds a progress bar to the dialog.  For example:
<pre>    spacefm -g --progress</pre>

By default, the progress bar will pulse automatically.  You can also specify an initial VALUE (eg '100' or 'pulse').  To update the progress bar, it is most convenient to specify @FILE so the progress bar's value is read from FILE.  For example:
<pre>    spacefm -g --progress <b>@</b>/tmp/dialog-progress</pre>

The file is watched for changes.  To later update the value of the progress bar:
<pre>    echo 50 > /tmp/dialog-progress</pre>

Or, the progress bar will advance one pulse step each time you run:
<pre>    echo pulse > /tmp/dialog-progress</pre>

Or, the progress bar will pulsate automatically if you run:
<pre>    echo auto-pulse > /tmp/dialog-progress</pre>

Or, you can set additional text to appear in the progress bar:
<pre>    echo "25 % copying" > /tmp/dialog-progress</pre>

Or, you can set just the progress bar length with no text in the bar (note the space):
<pre>    echo "75 " > /tmp/dialog-progress</pre>

Or, you can set just the progress bar text, which will not change the bar length:
<pre>    echo "text" > /tmp/dialog-progress</pre>

<p>In <a href="#dialog-cmd">commands</a>, the value of a --progress element can be set using the internal <a href="#dialog-int-set">set</a> command (eg 'set progress1 "35 %"' or 'set progress1 pulse').
<br><br>


<!-- # --hsep #hsep -->
Usage: <code><b>--hsep</b></code>

<p>An --hsep element adds a horizontal line separator to the dialog.  The line will extend the full width of whatever box the widget is packed into.
<br><br>

<!-- # --vsep #vsep -->
Usage: <code><b>--vsep</b></code>

<p>A --vsep element adds a vertical line separator to the dialog.  The line will extend to the full height of whatever box the widget is packed into.
<br><br>


<!-- # --timeout #timeout -->
Usage: <code><b>--timeout [DELAY|@FILE]</b></code>

<p>A --timeout element adds a Pause button to the dialog, which causes the dialog window to close automatically after DELAY seconds, unless the Pause button has been pressed.

<p>In <a href="#dialog-cmd">commands</a>, the timeout value can be changed while the dialog is running with '<a href="#dialog-int-set">set</a> timeout1 VALUE'.

<p>In SpaceFM Dialog's output, if the window closes due to the timeout, "$dialog_pressed" will equal "timeout1", and "$dialog_pressed_index" will equal -3.  (The timeout button is not indexed with the other buttons.)
<br><br>


<!-- @Dialog @List Elements #lists -->

<!-- # --drop #drop -->
Usage: <code><b>--drop {TEXT... --}|@FILE [DEFAULT|+N|@FILE [COMMAND...]]</b></code>

<p>A --drop element adds a drop-down list to the dialog, allowing the user to select a single option or item in the list.

<p>The contents of the list can be passed to SpaceFM Dialog as arguments on the command line or as a file.  To pass the list on the command line:
<pre>    spacefm -g --drop "Item One" "Item Two" "Item Three" --</pre>

Especially if there are any arguments following the list, <b>be sure to end the list with a '--' argument</b> as shown above.  By default, the list will have no item selected.

<p><b>To select a default item</b>, add it to the command line after '--':
<pre>    spacefm -g --drop "Item One" "Item Two" "Item Three" -- <b>"Item Two"</b></pre>

<b>Or, pass the index of the default item with a plus sign (+)</b> (indexing starts counting from zero):
<pre>    spacefm -g --drop "Item One" "Item Two" "Item Three" -- <b>+1</b></pre>

<b>To instead read the list from the lines of a text file:</b>
<pre>
    # First, create a text file containing multiple lines of text:
    echo -e "Item One\nItem Two\nItem Three" > /tmp/dialog-drop
    # Tell spacefm to load the drop list from a file:
    spacefm -g --drop <b>@</b>/tmp/dialog-drop</pre>

To specify a default item, add the default item value or index number.  For example:
<pre>
    spacefm -g --drop @/tmp/dialog-drop <b>+1</b></pre>

The file /tmp/dialog-drop in the above example will be watched.  When its contents change, the list contents will be updated to reflect the new list in the file.

<p><b>The default value, as an item value or a +N index, may also be read from the contents of a file:</b>
<pre>
    echo "Item Two" > /tmp/dialog-dropdef
    spacefm -g --drop @/tmp/dialog-drop <b>@</b>/tmp/dialog-dropdef</pre>

The file /tmp/dialog-dropdef in the above example will NOT be watched - changing its contents while the dialog is running will have no effect.  However, when the dialog closes, the currently selected item in the list will be written to the file.  This will cause the dialog to remember the selected value between sessions.  If you run the above spacefm command multiple times, you will note that your selection is remembered from the previously closed dialog.

<p>If a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run whenever the list selection changes.  (The command is NOT run when the default item is set during dialog creation.)  To include a COMMAND, be sure to include a DEFAULT value on the command line, or "" for no default.

<p>In commands, the value of a --drop element (eg %drop1) will equal the currently selected item in the list.  If internal command <a href="#dialog-int-set">set</a> is used on a --drop element, the command will set a new file to read the list from.  Or, if the set value is not a file, will select an item in the list.  The internal <a href="#dialog-int-select">select</a> command can also be used to select an item in the list.

<p>In SpaceFM Dialog's output, the selected item of a --drop element can be read from, for example, "$dialog_drop1", and its index from "$dialog_drop1_index".  (An index of -1 indicates no item is selected.)
<br><br>


<!-- # --combo #combo -->
Usage: <code><b>--combo {TEXT... --}|@FILE [DEFAULT|+N|@FILE [COMMAND...]]</b></code>

<p>A --combo element is similar to a <a href="#dialog-lists-drop">--drop</a> element, except that it adds a text entry box, so the user can either select an item from the list, or enter custom text.

<p>The list is created the same way as a --drop list, either with arguments on the command line, or reading the list from a file.  However, the DEFAULT value will be set in the text entry box even if it isn't in the list.

<p><b>When the user presses Enter in the text entry box</b>, one of several things may happen.  If no COMMAND is associated with the input, then the right-most button at the bottom of the dialog will be automatically pressed.  If the dialog has no buttons, nothing will happen.

<p>Or, if a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run when the user presses Enter in the text entry box, and no button will be automatically pressed.  To include a COMMAND, be sure to include a DEFAULT value on the command line, or "" for no default.

<p>In commands, the value of a --combo element (eg %combo1) will equal the text in the entry box.  If internal command <a href="#dialog-int-set">set</a> is used on a --combo element, the command will set a new file to read the list from.  Or, if the set value is not a file, will set the text in the entry box.  The internal <a href="#dialog-int-select">select</a> command can also be used to set the text in the box, and the <a href="#dialog-int-unselect">unselect</a> command will clear the text.

<p>In SpaceFM Dialog's output, the entry box text of a --combo element can be read from, for example, "$dialog_combo1", and its index from "$dialog_combo1_index".  The index will be set only if the user selects an item from the list, otherwise it will be -1 (even if the text in the entry box equals an item in the list).
<br><br>


<!-- # --list #list -->
Usage: <code><b>--list {[^HEAD[:TYPE]] [--colwidth=W] TEXT... --}|@FILE [COMMAND...]]</b></code>

<p>A --list element adds a list box to the dialog, which includes a scroll bar when the list is long, and allows the user to select a single item or no item in the list.  The list is created similarly to a <a href="#dialog-lists-drop">--drop</a> or <a href="#dialog-lists-combo">--combo</a> list, either with arguments on the command line, or reading the list from a file.  However, no default item may be selected on the command line, and several additional, optional components may be added.

<p>To create a simple list:
<pre>
    spacefm -g --list "Item One" "Item Two" "Item Three" --</pre>

<b>Or, in a script, you can create an array</b> and populate the list from the array.  For example:
<pre>
    #!/bin/bash
    # <b>This script creates a list from an array</b>

    alist=( "Item One" "Item Two" "Item Three" )
    eval "`spacefm -g --list "${alist[@]}" -- --button ok`"
    if (( dialog_list1_index != -1 )); then
        echo "Item selected: $dialog_list1"
        echo "Index selected: $dialog_list1_index = ${alist[dialog_list1_index]}"
    else
        echo "No item selected."
    fi
</pre>
The above method has the advantage that the list indices match your array indices.

<p><b>Or, create a text file and read the list from it:</b>
<pre>
    # First, create a text file containing multiple lines of text:
    echo -e "Item One\nItem Two\nItem Three" > /tmp/dialog-list
    # Tell spacefm to load the list from a file:
    spacefm -g --list <b>@</b>/tmp/dialog-list</pre>

The file /tmp/dialog-list in the above example will be watched.  When its contents change, the list contents will be updated to reflect the new list in the file.

<p><b>Lists can also contain multiple columns</b>.  Column headers are used to both set the column header label, and to define when a new column begins.  A column header is an argument that begins with a caret (^).  For example:
<pre>    spacefm -g --list ^Letter A B C ^Number 1 2 3 --</pre>

The above command will create a list with three rows and two columns, where "Letter" and "Number" are column headers.  By adding column headers, the list also becomes sortable - the user can click on a column header to sort by that column (and click again for a descending vs. ascending sort).

<p><b>You can also set a column width</b> if desired.  Include a --colwidth=WIDTH option anywhere after the start of a column.  (Columns have a minimum width of 50.)  For example:
<pre>    spacefm -g --list ^Letter A B C ^Number --colwidth=200 1 2 3 --</pre>

<p><b>Usually it's easier to create a multi-column list using a file.</b>  For example, create a text file with these contents:
<pre><i>
^Letter
A
B
C
^Number
--colwidth=200
1
2
3
</i></pre>

Save the above text to a file named '/tmp/dialog-list'.  Note that the --colwidth option must be placed on a line by itself in a file.  Then load the file:
<pre>	 spacefm -g --list <b>@</b>/tmp/dialog-list</pre>

<b>It's also possible to set a data type for a column.</b>  Data types include 'string' (the default type if none is specified), 'int' (integer), 'double' (a double-precision floating point number), and 'progress' (a progress bar with values ranging 0-100).  Different data types will be displayed and sorted differently.  To define a data type for a column, include it in the column header after a colon.  For example, edit the  '/tmp/dialog-list' so it contains this list with three columns:
<pre><i>
^Job
A
B
C
^Number:int
1
2
3
^Complete:progress
35
75
90
</i></pre>

In the above example, the "Job" column is type 'string', the "Number" column contains integers, and the "Complete" column will show progress bars.  Once again, show the list:
<pre>	 spacefm -g --list <b>@</b>/tmp/dialog-list</pre>

Note:  If you want a column header to end with a colon (eg "Number:"), and you want to define a data type, use two colons (eg "Number::int").

<p>If a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run when the user double-clicks an item in the list.  If no COMMAND is included, double-clicking an item in the list will automatically press the right-most dialog button, if present.

<p>In commands, the value of a --list element (eg %list1) will equal the currently selected item (first column data, or hidden column - see below).  If internal command <a href="#dialog-int-set">set</a> is used on a --list element, the command will set a new file to read the list from.  The internal <a href="#dialog-int-select">select</a> command will select an item in the list, and the <a href="#dialog-int-unselect">unselect</a> command will unselect any selection.

<p>In SpaceFM Dialog's output, the selected item can be read from, for example, "$dialog_list1", and its index from "$dialog_list1_index" (-1 if nothing is selected).

<p><b>It's also possible to set a hidden data column</b> to be used for return values.  Rather than returning the first column data of the selected item, the hidden column data will be returned.  To set a hidden column, name the <i>first</i> column header "HIDE" (uppercase) (with optional data type :TYPE).  For example:
<pre><i>
^HIDE
return1
return2
return3
^Job
A
B
C
^Number:int
1
2
3
^Complete:progress
35
75
90
</i></pre>

The above list still has only three visible columns.  The values in the "HIDE" column will be returned in the dialog's output, and in commands.  For example, save the above list as '/tmp/dialog-list' and run:
<pre>	 spacefm -g --list <b>@</b>/tmp/dialog-list bash -c 'echo "# %n = %v" &gt;&amp;2'</pre>

When you double-click an item in the list, the return value will be printed to the terminal (eg "# list1 = return2").  bash -c is required to send the output to stderr instead of stdout.
<br><br>


<!-- # --mlist #mlist -->
Usage: <code><b>--mlist {[^HEAD[:TYPE]] [--colwidth=W] TEXT... --}|@FILE [COMMAND...]]</b></code>

<p>An --mlist element behaves like a <a href="#dialog-lists-list">--list</a> except that multiple items may be selected.  (To select more than one item, hold down Ctrl and click, or hold down Ctrl and press arrows keys and Space to select.)

<p>In SpaceFM Dialog's output, the --mlist element variable (eg "$dialog_mlist1") is set to an array containing all selected items, and the index variable (eg $dialog_mlist1_index) is set to an array containing the indices of all selected items.  For example:

<pre>
#!/bin/bash
# <b>This script creates an mlist from an array</b>

alist=( Aaa Bbb Ccc Ddd Eee Fff Ggg Hhh )
eval "`spacefm -g --mlist "${alist[@]}" -- --button ok`"
if [[ "${dialog_mlist1[0]}" != "" ]]; then
    echo "Selected items:"
    for item in "${dialog_mlist1[@]}"; do
	echo "    $item"
    done
else
    echo "No item selected."
fi
</pre>

In <a href="#dialog-cmd">commands</a>, the --mlist element's value (eg %v, %mlist1) is set to a list of quoted values (eg 'Aaa' 'Bcc' 'Ccc') which can be passed to an executable's command line.
<br><br>


<!-- # --chooser #chooser -->
Usage: <code><b>--chooser [CHOOSER-OPTIONS] [DIR|FILE|@FILE [COMMAND...]]</b></code><br>
Chooser Options: <code><b>[--save] [--dir] [--multi] [--filter F[:F...]]</b></code>

<p>A --chooser element adds a GTK file chooser to the dialog, which includes a file list, recent places list, and other widgets as a group, allowing the user to select or enter the name of a file or directory.  Filters can be added to control what types of files are displayed.

<p><b>To allow the user to select a file which already exists:</b>
<pre>     spacefm -g --chooser</pre>

<p>If no path is specified, the chooser will open in "Recently Used".  You can add a directory to the command line to make the chooser open in a default directory, or add a file path to select a file by default.  For example:
<pre>     spacefm -g --chooser <b>/etc/fstab</b></pre>

<p><b>The default file or directory can also be read from a file.</b>  For example:
<pre>
    echo "/etc/fstab" > /tmp/dialog-chooser
    spacefm -g --chooser <b>@</b>/tmp/dialog-chooser</pre>
</pre>

In the above example, the file '/tmp/dialog-chooser' will be watched.  When its contents change, the chooser will change directory and/or select a file to reflect the new value on the first line of the file.  When the dialog closes, the current directory of the chooser will be written to the file.  Thus the next time the dialog opens, it will open to the same directory.

<p><b>To allow the user to select multiple files</b>, add the --multi option (all options must precede any arguments):
<pre>     spacefm -g --chooser --multi /etc</pre>

<p><b>To allow the user to select a directory which already exists:</b>
<pre>     spacefm -g --chooser --dir</pre>

To allow the user to select multiple directories:</b>
<pre>     spacefm -g --chooser --dir --multi</pre>

<p><b>To allow the user to select an existing file, or enter a filename that doesn't exist</b> (to save a file, for example):</b>
<pre>     spacefm -g --chooser --save</pre>

<p><b>To allow the user to select an existing directory, or enter a directory name that doesn't exist</b> (to create a directory, for example):</b>
<pre>     spacefm -g --chooser --dir --save</pre>

Note that it is up to your script to determine if a file already exists before overwriting it, or to prompt the user for overwrite confirmation.

<p><b>Filters can be added</b> to control what types of files are displayed.  The F value in a filter can be a MIME type (eg "text/plain" or "video/*") or a filename pattern (eg *.txt).  For example, to allow the user to choose only files with MIME type "text/plain":
<pre>     spacefm -g --chooser --filter text/plain</pre>

Or to allow the user to select only files ending in ".avi":
<pre>     spacefm -g --chooser --filter '*.avi'</pre>

<b>Multiple filters can be added.</b>  The user will be able to select the desired filter from a drop-down list in the chooser.  For example:
<pre>     spacefm -g --chooser --filter '*.avi' --filter video/x-matroska</pre>

<b>A single filter can include multiple types or patterns</b> separated by a colon.  For example:
<pre>     spacefm -g --chooser --filter '*.avi<b>:</b>*.mpg<b>:</b>video/*'</pre>

<b>More than one --chooser element can be added to a dialog.</b>

<p>If a <a href="#dialog-cmd">command</a> is included, the COMMAND(s) will be run when the user double-clicks a file in the list.  In commands, the value of a --chooser element (eg %v, %chooser1) will equal the currently selected file or files.  If internal command <a href="#dialog-int-set">set</a> is used on a chooser, the command will change directory (and/or select a file).  The <a href="#dialog-int-select">select</a> and <a href="#dialog-int-unselect">unselect</a> commands can be used to select and unselect files.

<p>In SpaceFM Dialog's output, the selected file(s) can be read from, for example, "$dialog_chooser1", and the current directory from "$dialog_chooser1_dir".  Note that in some cases, such as when the chooser is in "Recently Used", "$dialog_chooser1_dir" will be null.  Also, if the --multi option is used, "$dialog_chooser1" will be an array containing the selected paths.
<br><br>




<!-- @Dialog @Non-Visible Elements #nonvis -->

<P>The following elements control how the dialog appears or behaves, and how other elements are packed into the dialog, but don't add a visible widget to the dialog:


<!-- # --prefix #prefix -->
Usage: <code><b>--prefix NAME|@FILE</b></code>

<p>--prefix is a non-visible element which sets the base variable name that SpaceFM Dialog will use when writing output.  By default, the base name is "dialog" (eg "$dialog_pressed").  In some cases you may want to use another name, especially if your script uses multiple dialogs.  For example:
<pre>    spacefm -g --prefix var</pre>

In this case, the output will use variables such as "$var_pressed" instead.

<p><b>As with many elements, --prefix also accepts a file instead of a string</b>, and will read the value from the first line of the file.  For example:
<pre>    echo "var" > /tmp/dialog-prefix
    spacefm -g --prefix <b>@</b>/tmp/dialog-prefix</pre>

The "at" sign (@) indicates that a file path is being specified, and that SpaceFM Dialog should read the value from the first line of the file /tmp/dialog-prefix.  The file is not watched or modified, but its value is not read until output is produced.
<br><br>


<!-- # --window-size #winsize -->
Usage: <code><b>--window-size "WIDTHxHEIGHT [PAD]"|@FILE</b></code>

<p>The --window-size element sets a minimum WIDTH and/or HEIGHT for the dialog window.  This element is used to make the window larger by default.  If WIDTH or HEIGHT is negative, that dimension's minimum remains unchanged.

<p>For example, to make the minimum window size 800x600:
<pre>    spacefm -g --window-size 800x600</pre>

Note that depending on the other elements added, <b>the window may grow larger</b> than the minimum size specified.  Also, window managers are capable of overriding the default size request.

<p>Or, to only set a minimum width of 800, leaving the height at the default:
<pre>    spacefm -g --window-size 800x-1</pre>

<p><b>A padding amount can also be included.</b>.  This sets the amount of empty space around widgets (0-20 is a reasonable range of values for PAD, 4 is the default).  For example:
<pre>    spacefm -g --window-size "800x600 <b>10</b>"</pre>

<b>IMPORTANT:</b>  The --window-size element must come before other elements on the command line for the padding value to have an effect.

<p><b>The minimum window size and padding can also be read from a file:</b>
<pre>    spacefm -g --window-size <b>@</b>/tmp/dialog-wsize</pre>

When the file is changed, the window will be resized to the specified size.  As the dialog is running, in another terminal run:
<pre>    echo 500x500 > /tmp/dialog-wsize</pre>

and the window will be resized.  (Note that the padding will not change once the dialog is running.)  Also, when the dialog closes, the window size (and padding if specified) are written to the file.  Thus when the dialog is next run, it will be at least whatever size the user last resized the window to.

<p>In <a href="#dialog-cmd">commands</a>, you can resize the window by using the internal <a href="#dialog-int-set">set</a> command on 'windowsize' (eg 'set windowsize 800x600'), even if you have not added a --window-size element.

<p>In SpaceFM Dialog's output, you can always read the window's last size (and padding if specified) from "$dialog_windowsize" (no numeric suffix), even if you have not added a --window-size element.  To get the current size while the window is running, use the <a href="#dialog-int-source">source</a> command.

<p>See also: <a href="#dialog-simple-title">--title</a> and <a href="#dialog-simple-wicon">--window-icon</a>
<br><br>


<!-- # --hbox #hbox -->
Usage: <code><b>--hbox [--compact] [PAD|@FILE]</b></code>

<p>The --hbox and <a href="#dialog-nonvis-vbox">--vbox</a> elements allow to you create more sophisticated-looking dialogs.  Instead of all elements being stacked vertically in the dialog, one after another, boxes also allow you to arrange elements horizontally in rows.  You can also pack boxes within boxes.  For example, a vertical box of small elements might be packed into a horizontal box of other elements.

<p>Boxes are invisible containers that hold elements - you can't actually see the box itself, only its affect on the elements within it.  They come in two varieties:  a vbox (vertical box) arranges its child elements in a vertical stack, while an hbox (horizontal box) arranges its child elements in a row.

<p>When you add an element to a dialog, it is packed into the <i>current box</i> of the dialog.  The current box refers to whatever box was last added to the dialog.  Or, if no boxes have been added, the current box is the default vbox of the dialog.  Thus if you add no box elements, all elements are arranged vertically in a dialog.

<p>An --hbox element packs a new hbox into the current box.  The hbox then becomes the new current box.  Any widgets you add after the --hbox element will be packed into it, and thus arranged in a row.  For example:
<pre>
    spacefm -g <b>--hbox</b> \
               --free-button "Button1" \
               --free-button "Button2" \
               --free-button "Button3"</pre>

In the above command, the initial --hbox element is packed into the default vbox of the dialog.  Then, the buttons are packed into the hbox, and are thus arranged in a row.

<p>When you are done adding elements to the hbox, you can close the box if you have other elements to add.  When the box is closed, the current box becomes the previous box, in this case the default vbox of the dialog again.  So any elements added after the box closure will again be stacked vertically in the dialog.  For example:

<pre>
    spacefm -g --hbox \
	       --free-button "Button1" \
	       --free-button "Button2" \
	       --free-button "Button3" \
	       <b>--close-box</b> \
               --free-button "Button4" \
               --free-button "Button5"</pre>

You will notice that if you resize the above window, the row of buttons expand vertically.  For some elements (like a --list or a --viewer) this is desirable, since the elements expand to fill the window.  For other elements, such as buttons, you don't normally want this expansion.  By default, an hbox will expand vertically consuming available window space, giving the extra space to its children, who in turn expand.  If you don't want the hbox to consume extra vertical space in the window, include the --compact option:

<pre>
    spacefm -g --hbox <b>--compact</b> \
	       --free-button "Button1" \
	       --free-button "Button2" \
	       --free-button "Button3" \
	       --close-box \
               --free-button "Button4" \
               --free-button "Button5"</pre>

As with all elements, the --compact option determines how much window space a box will absorb.  --compact tells the box not to expand in the <i>other</i> dimension.  For an hbox, --compact will affect the vertical dimension (height), and for a vbox, --compact will affect the horizontal dimension (width).  With --compact, the box will not consume extra window space beyond what its children require as a minimum, so the children will in turn not expand.  The extra space in the window will be divided among other boxes (if they can expand), or will remain empty (as in the above example).  Also, whether children expand in the <i>same</i> dimension (horizontally in an hbox or vertically in a vbox) depends on the type of elements in the box, and whether you have included --compact or --expand options for them.  The box itself will expand in the same dimension, but its children may not (as seen in the above example).

<p>Note: A box with no children in it will take no space - it is effectively hidden.

<p>Finally, a PAD value may also be added to an hbox, which adds padding (empty space) <i>between</i> the children.  For example:
<pre>
    spacefm -g --hbox <b>30</b> \
	       --free-button "Button1" \
	       --free-button "Button2" \
	       --free-button "Button3"
</pre>

<p><b>If an --hbox is <a href="#dialog-int-hide">hidden</a>, all of its children become invisible.</b>
<br><br>


<!-- # --vbox #vbox -->
Usage: <code><b>--vbox [--compact] [PAD|@FILE]</b></code>

<p>For a general discussion of boxes, see <a href="#dialog-nonvis-hbox">--hbox</a>.  A --vbox element works similarly to an --hbox, except that the child elements in the box are stacked vertically rather than horizontally.

<p>The default box in a dialog is a vbox, so elements are added in a vertical stack.  Adding a --vbox element to the dialog's default vbox will have no apparent effect.  Thus these two commands create the same dialog:
<pre>
    spacefm -g --free-button "Button1" \
               --free-button "Button2" \
               --free-button "Button3"

    # Produces the same dialog as:

    spacefm -g <b>--vbox</b> \
               --free-button "Button1" \
               --free-button "Button2" \
               --free-button "Button3"
</pre>

To see the effects of a vbox, we need to pack it into an hbox containing other elements:
<pre>
    spacefm -g --hbox \
               --list AAA BBB CCC \
	       --vbox \
	       --check "Option Alpha" \
	       --check "Option Beta" \
	       --check "Option Gamma"
</pre>

In the above example, an hbox is first packed in the dialog.  This hbox contains two elements:  a list and a vbox.  Since its an hbox, those elements are arranged side-by-side, in a row - the list and the vbox will be next to each other.  Finally, three check options are packed into the vbox.  Since its a vbox, they are stacked vertically.

<p>If we wanted to add another element below all of that, in the original default vbox of the dialog, we would first need to close the boxes we added:
<pre>
    spacefm -g --hbox \
               --list AAA BBB CCC \
	       --vbox \
	       --check "Option Alpha" \
	       --check "Option Beta" \
	       --check "Option Gamma" \
	       <b>--close-box</b> \
	       <b>--close-box</b> \
	       --drop item
</pre>

A --close-box always closes the <i>current box</i>.  In the above example, the first --close-box closes the vbox, and the second closes the hbox.  (You cannot close the default vbox of the dialog, so an additional --close-box would be ignored.)

<p>As with an --hbox, a --compact option can be added to a --vbox to prevent it from expanding in the <i>other</i> dimension - horizontally.  In our example this will compact the check options to the right side of the window, giving the list more horizontal space in the window:
<pre>
    spacefm -g --hbox \
               --list AAA BBB CCC \
	       --vbox <b>--compact</b> \
	       --check "Option Alpha" \
	       --check "Option Beta" \
	       --check "Option Gamma" \
	       --close-box \
	       --close-box \
	       --drop item
</pre>

Finally, as with an --hbox, a PAD value may be added to a --vbox to add empty space <i>between</i> its children:
<pre>
    spacefm -g --hbox \
               --list AAA BBB CCC \
	       --vbox --compact <b>30</b> \
	       --check "Option Alpha" \
	       --check "Option Beta" \
	       --check "Option Gamma" \
	       --close-box \
	       --close-box \
	       --drop item
</pre>

<p><b>If a --vbox is <a href="#dialog-int-hide">hidden</a>, all of its children become invisible.</b>
<br><br>


<!-- # --close-box #closebox -->
Usage: <code><b>--close-box</b></code>

<p>A --close-box element closes the <i>current box</i> of the dialog, as demonstrated in <a href="#dialog-nonvis-hbox">--hbox</a> and <a href="#dialog-nonvis-vbox">--vbox</a>.  Elements after the --close-box will be added to the previous current box of the dialog.
<br><br>


<!-- # --keypress #keypress -->
Usage: <code><b>--keypress KEYCODE MODIFIER COMMAND...</b></code>

<p>A --keypress element associates a key combination with a COMMAND while the dialog is running.  Pressing the key combination will run the COMMAND(s), which as always may be internal, external, or a mixture of both.

<p>For example, to associate Ctrl+K with a command that prints a value to the terminal and updates a label:
<pre>    spacefm -g --label "Press Ctrl+K" \
               <b>--keypress 0x6b 0x4</b> bash -c 'echo "# %n %v" &gt;&amp;2' -- \
                                   set label1 "You pressed Ctrl+K"
</pre>

In the above example, "0x6b" is the KEYCODE for the 'k' key, and "0x4" is the MODIFIER for Ctrl.  When Ctrl+K is pressed, "# keypress1 0x6b 0x4" is written to the terminal.

<p>Keycodes and modifiers may be obtained using SpaceFM's Design Mode <a href="#designmode-designmenu-key">Key Shortcut</a> setting.  Right-click on a menu item in SpaceFM and select Key Shortcut.  Press the desired key combination to see the keycode and modifier, then click Cancel.

<p><b>Multiple --keypress elements can be added to a dialog.</b>

<p>In <a href="#dialog-cmd">commands</a>, the value of a --keypress element (eg %v, %keypress1) will equal the keycode and modifier.
<br><br>

<!-- # --window-close #winclose -->
Usage: <code><b>--window-close COMMAND...</b></code>

<p>A --window-close element runs COMMAND when the user attempts to close the dialog (usually by clicking the 'X' button in the upper right corner or using Alt-F4, etc.)  The window closure will be inhibited, but COMMAND can be used to close it conditionally.

<p>For example:
<pre>
    spacefm -g --label "You can't close this window unless you enter text:" \
               --input \
	       --window-close close %input1</pre>

In the above example, the internal <a href="#dialog-int-close">close</a> command is passed the contents of the --input element, which acts as a reversal to the close command.  If %input1 is empty, the close command does nothing, otherwise it closes the window.

<!-- # --command #command -->
Usage: <code><b>--command FILE|PIPE [COMMAND...]</b></code>

<p>A --command element causes SpaceFM Dialog to monitor a regular file or a pipe for <a href="#dialog-int">internal commands</a>.  For example, to monitor a regular file:
<pre>    spacefm -g --command /tmp/dialog-cmd</pre>

No command will be read from the file during dialog creation even if it contains one.  When you write a command to the first line of the file while the dialog is running, it will be run as an internal command.  In another terminal run:
<pre>    echo "set title A Window Title" > /tmp/dialog-cmd</pre>

Note that separate quotes should NOT be used around the third argument, even if it contains spaces.

<p><b>Or, to monitor a pipe:</b>
<pre>
    # First create the pipe:
    mkfifo /tmp/dialog-cmdpipe
    spacefm -g --command /tmp/dialog-cmdpipe
</pre>

Then in another terminal, write text to the pipe:
<pre>    echo "set windowsize 500x500" > /tmp/dialog-cmdpipe</pre>

<p><b>Multiple --command elements may be added</b> if desired.  This can help prevent race conditions when submitting commands rapidly, etc.

<p>You can use a command file or pipe from your script to get data from a running dialog by submitting a 'source' command (eg 'source /tmp/dialog-source').  Then in your script, parse the source file:
<pre>    source /tmp/dialog-source</pre>

Note that you may or may not need to add a small delay (eg sleep 0.1) for the source file to be written in response to your command, before reading the file.

<p>COMMAND, if included, specifies initialization <a href="#dialog-cmd">commands</a> for the dialog.  COMMAND(s) associated with a --command element are run only once, just after the dialog is created.  These are used to initialize the dialog, such as <a href="#dialog-int-disable">disabling</a> or <a href="#dialog-int-hide">hiding</a> some elements.  (FILE|PIPE may be "" if you want to include an initialization COMMAND but don't want to watch a command file.)




<!-- @Dialog @Commands #cmd -->

<p>One or more commands may be associated with a SpaceFM Dialog element if the element accepts COMMAND on its command line.  Most commands are run when the element is activated - a user clicks a button, double-clicks an item in a list, presses Enter in a text box, etc.

<P>Commands may be <a href="#dialog-int">internal</a> (used to internally change aspects of the dialog while it's running) or external (an executable to be run).  SpaceFM Dialog recognizes its internal commands by name; any commands which are not internal are run as external.

<p>The COMMAND argument may represent a single command followed by its command arguments, or multiple commands each with arguments.  A "--" argument is used to separate multiple commands.  Both internal and external may be mixed.  For example:
<pre>
    spacefm -g --label "Press Button" \
	       --button "Button" <b>set label1 "Button was pressed" --</b> \
				 <b>bash -c 'echo "# Button %n was pressed" &gt;&amp;2'</b>
</pre>

The --button element above includes two commands with arguments, separated by a "--" argument.  The first command (set label1 "Button was pressed") is an internal command.  The second command (bash -c echo...) is an external command.  When the button is pressed, both commands are run - the first changes the label internally, and the second runs the echo executable to write text to stderr of the terminal.  (Note that any output to stdout will be discarded because this may interfere with <a href="#dialog-invocation-eval">evaluating the output</a>.)

<p>Although commands are run in the order presented, note that <b>external commands are run asynchronously</b>.  SpaceFM Dialog runs and forgets the command, and doesn't wait for it to finish.  This means later commands may run before an earlier command has finished.  (To run an external command synchronously, run it inside an internal noop command's <a href="#dlgsubcmd">%(command) substitution</a>.)

<!-- # Substitution Variables #sub -->
Before SpaceFM Dialog runs a command, internal or external, it replaces some variables anywhere in the command or arguments with current values.  The following substitution variables are replaced:<br>
<center><table width="70%">
	<tr>
		<td>%n</td> <td>Name of the current element</td>
	</tr><tr>
		<td>%v</td> <td>Value of the current element</td>
	</tr><tr>
		<td>%NAME</td> <td>Value of element named NAME (eg: %input1)</td>
	</tr><tr>
		<td>%(command)</td> <td>stdout from an external command</td>
	</tr><tr>
		<td>%%</td> <td>%</td>
	</tr>
</table></center>

<p><b>%n</b><br>
In the above button example, %n would equal "button1", the name of the element.  Elements are named automatically as they are added.  These are the same names used in the variables in SpaceFM Dialog's output.

<p><b>%v</b><br>
The value of the current element, or "my value" from the element's perspective, is substituted for %v.  This is equivalent to referring to the element's own value by name (eg %button1 in the above example).

<p><b>%NAME</b><br>
%NAME is used to get the value of any other element in the dialog.  For example, the text in the first --input element of a dialog is always "%input1".  If element NAME does not exist, %NAME has value "".  Note that the value read from an element may differ from the value used to set an element.  For example, using <a href="#dialog-int-set">set</a> on a --list element sets the file path for the list.  But "%list1" will contain the selected items in the list.

<p><a name="dlgsubcmd"><b>%(command)</b></a><br>
%(command) executes an external bash command line <i>synchronously</i>, and is substituted with the stdout output of the command.  For example:
<pre>
    spacefm -g --label \
	       --button 'Get Date' set label1 '<b>%(date +%%D)</b>'</pre>

Generally, you will need to quote the '%(command)' argument as shown above when running spacefm, or the shell will misinterpret the parentheses.  The command line "date +%D" (remember %% is changed to %) is run, and the output is substituted.

<p><b>IMPORTANT:</b>  Because the %(command) command line is run synchronously, SpaceFM Dialog will wait until it finishes.  While it's waiting, the dialog GUI and other functions will be suspended.  If the command takes an appreciable amount of time, you will notice the GUI lags or hangs.  Thus fast commands work best.

<p>Also, if you want to run an external command synchronously, you can run it inside an internal command with %(command).  The <a href="#dialog-int-noop">noop</a> command, which does nothing except evaluate arguments, is good for this, eg noop '%(command)'.  In this case, the stdout output will be discarded, but the command will be run synchronously.

<p>Note that a small bash script can be run directly inside a %(command) substitution.  For example:
<pre>
spacefm -g --check Option 0                                                      \
		   set label1 '<b>%( echo -n Option is\ ;</b>                  \
				  <b>(( %v )) &amp;&amp; echo checked || echo unchecked )</b>' \
	   --label "Option is unchecked"
</pre>


<!-- @Dialog @Internal Commands #int -->
<p>Internal commands are run internally by the dialog to change elements while the dialog is running.  They can be included as part of an element's <A href="#dialog-cmd">COMMAND</a> arguments, or submitted from an external process using a <a href="#dialog-nonvis-command">--command</a> element.

<p>The following internal commands may be used:

<!-- #noop -->
Usage: <b>noop</b>

<p>The noop (no operation) command simply does nothing, but its arguments, if any, are evaluated.

<p>One use for a noop command is to prevent a dialog closing when a button or other element is activated.  Buttons will automatically close the dialog when pressed if no COMMAND is included.  Other elements, such as lists and inputs, will press the right-most dialog button to close the dialog when they are activated if no COMMAND is included.  To prevent this behavior, you can set COMMAND to noop.  For example:
<pre>    spacefm -g --button ok noop</pre>

Another use for the noop command is to evaluate arguments.  This can be used to run an external command synchronously as detailed in <a href="#dlgsubcmd">%(command) substitution</a>.  For example:
<pre>    spacefm -g --button ok <b>noop '%(myscript)'</b> -- close</pre>

In the above example, when the OK button is pressed, first 'myscript' will be run <i>synchronously</i> (an imaginary script which does something critical before closure).  SpaceFM Dialog will wait for it to finish.  Then and only then, the 'close' command will close the dialog.

<!-- #close -->
Usage: <b>close [REVERSE]</b>

<p>The close command simply closes the dialog window, as if the user clicked the X in the top-right corner or used Alt+F4.  $dialog_pressed_index will equal -2.

<p>REVERSE, if supplied and equal to "", "0", or "false", causes the close command to do nothing.  This can be used with the value from another element, for example, to make the close command conditional.  For example:
<pre>
    spacefm -g --label "You can't close this window unless you enter text:" \
               --input \
	       <a href="#dialog-nonvis-winclose">--window-close</a> <b>close %input1</b></pre>

Note: Element @FILE values are NOT saved when the dialog is closed via the close command (or via a SIGQUIT signal, etc).  You can perform a <a href="#dialog-int-source">source</a> command first if you want values to be written for @FILEs.  [Note:  In SpaceFM 0.9.3 and prior, the close command DID save element @FILE values.]

<!-- #press -->
Usage: <b>press BUTTON-NAME</b>

<p>The press command presses a button in the dialog, just as if the user clicked it.  It is passed the name of the button to press.  For example:
<pre>
    spacefm -g --icon gtk-ok <b>press button1</b> \
	       --button ok</pre>

When the above command is run and the icon is clicked, the OK button will be pressed, closing the dialog ($dialog_pressed = button1).

<p>Other elements, if no COMMAND is included, will press the right-most dialog button when activated.  The press command can also be used to press another button instead.

<!-- #set -->
Usage: <b>set NAME VALUE</b>

<p>The set command sets a new VALUE for the element named NAME.  What effect this has will depend on the type of element.  For most elements, set will change what they are displaying or their state.  For details on how a particular element handles set, see the element's <a href="#dialog-simple">documentation</a>.

<p>For example:
<pre>
    spacefm -g --label "Press Button" \
	       --button "Button" <b>set label1 "Button was pressed"</b>
</pre>

<!-- #select -->
Usage: <b>select NAME [VALUE]</b>

<p>The select command is used to select an item in any kind of list, or if no VALUE is supplied, all items are selected if possible.  select can also be used to select a filename in a <a href="#dialog-lists-chooser">--chooser</a>, or set the text in a <a href="#dialog-lists-combo">--combo</a>.

<p>For example:
<pre>
    spacefm -g --list AAA BBB CCC \
               --button "Select CCC" <b>select list1 CCC</b> \
	       --button ok</pre>
	       
<!-- #unselect -->
Usage: <b>unselect NAME [VALUE]</b>

<p>The unselect command is used to unselect an item in any kind of list, or if no VALUE is supplied, all items are unselected.  unselect can also be used to unselect a filename in a <a href="#dialog-lists-chooser">--chooser</a>, or clear the text in a <a href="#dialog-lists-combo">--combo</a>.

<p>For example:
<pre>
    spacefm -g --mlist AAA BBB CCC \
	       --command "" select mlist1 \
               --button "Unselect All" <b>unselect mlist1</b> \
	       --button ok</pre>

<!-- #focus -->
Usage: <b>focus [NAME [REVERSE]]</b>

<p>The focus command gives the element NAME the focus in the dialog.  The focused element receives keyboard input.

<p>If no NAME argument is included, the dialog window is presented (this may mean raising the window in the stacking order, deiconifying it, and/or moving it to the current desktop, dependending on window manager settings).

<p>REVERSE, if supplied and equal to "", "0", or "false", causes the focus command to do nothing.  This can be used with the value from a --check element, for example, to make the focus command conditional.

<!-- #hide -->
Usage: <b>hide NAME [REVERSE]</b>

<p>The hide command makes the element named NAME invisible.  A hidden element takes no space, so other elements may shift position or size in response to an element being hidden.  hide can be used to hide or show dialog elements conditionally in a certain mode or use of the dialog.

<p>REVERSE, if supplied and equal to "", "0", or "false", causes the hide command to have the reversed effect (it becomes a <a href="#dialog-int-show">show</a> command).  This can be used with the value from a --check element, for example, to make the hide command conditional.

<!-- #show -->
Usage: <b>show [NAME [REVERSE]]</b>

<p>The show command makes the element named NAME visible.  All elements are visible by default, so a show command only has an effect if an element was previously hidden with <A href="#dialog-int-hide">hide</a> (or a reversed show).

<p>If no NAME argument is included, the dialog window is presented (this may mean raising the window in the stacking order, deiconifying it, and/or moving it to the current desktop, dependending on window manager settings).

<p>REVERSE, if supplied and equal to "", "0", or "false", causes the show command to have the reversed effect (it becomes a <A href="#dialog-int-hide">hide</a> command).  This can be used with the value from a --check element, for example, to make the show command conditional.  For example:
<pre>
    spacefm -g --check "Show text" 1 <b>show label1 %v</b> \
               --label "Some text"
</pre>

<!-- #disable -->
Usage: <b>disable NAME [REVERSE]</b>

<p>The disable command sets the element named NAME insensitive (grayed).  A disabled element cannot be clicked or used by the user.

<p>REVERSE, if supplied and equal to "", "0", or "false", causes the disable command to have the reversed effect (it becomes an <a href="#dialog-int-enable">enable</a> command).  This can be used with the value from a --check element, for example, to make the disable command conditional.


<!-- #enable -->
Usage: <b>enable NAME [REVERSE]</b>

<p>The enable command sets the element named NAME sensitive (not grayed).  All elements are enabled by default, so an enable command only has an effect if an element was previously disabled with <A href="#dialog-int-disable">disable</a> (or a reversed enable).

<p>REVERSE, if supplied and equal to "", "0", or "false", causes the enable command to have the reversed effect (it becomes a <A href="#dialog-int-disable">disable</a> command).  This can be used with the value from a --check element, for example, to make the enable command conditional.

<p>For example (you can't click OK unless you select a function):
<pre>
    spacefm -g --label "Select a function and click OK:"           \
               --drop "Function A" "Function B" "Function C" -- "" \
	              <b>enable button1 %v</b>                            \
	       --button ok                                         \
	       --command "" disable button1
</pre>

In the above example, the drop's %v equals "", reversing the enable, unless a function is selected.  The <a href="#dialog-nonvis-command">--command</a> element is used to initialize the dialog by disabling button1 when the dialog is first created.

<!-- #source -->
Usage: <b>source FILE</b>

<p>When a dialog closes, it saves some @FILE values, and it writes <a href="#dialog-invocation-eval">output</a> to stdout containing variables for use in a script.   The source command is used to trigger this output to be written to a file while the dialog is still running.  The file can then be used as a source file in bash or a similar script, providing the script with the current state of the dialog elements.

<p>The source command also saves @FILEs for some elements, such as <a href="#dialog-simple-input">--input</a>, which are normally only saved when the dialog closes byt the user pressing a button other than Cancel.  It also saves the contents of an <a href="#dialog-simple-editor">--editor</a> or <a href="#dialog-simple-viewer">--viewer</a> element to SAVEFILE.

<p>If FILE is omitted or equals "", the output is written to stderr by the dialog process (useful for debuging).  To run source with no output use 'source /dev/null'.





<!-- @Sockets @Introduction #intro -->

<p>SpaceFM socket commands allow external processes (including <a href="#designmode-designmenu-new">custom commands</a>) to easily communicate with a running instance of SpaceFM.  They can be used to gather information about the state of the GUI and to make changes to the GUI.  When used in <a href="#sockets-events">event handlers</a>, socket commands can respond to various events in the SpaceFM window.

<p>When a user's first instance of SpaceFM is started, either by the user opening a window, starting a daemon instance, or starting a desktop manager daemon instance, a <a href="#programfiles-tmp-socket">socket</a> is created in /tmp for this instance.  This socket is used by SpaceFM to open additional windows or tabs, and is also used to process socket commands.  This allows other processes owned by the same user to communicate with the running instance.

<p>For example, socket commands can be used to record or change the size of a SpaceFM window; show or hide panels or side panes; resize panels, panes, and columns; select files in a given window, panel, or tab; place text or files on the clipboard; read text or files from the clipboard; place text in a panel's status bar; update the progress bar and other information displayed about running tasks, and much more.




<!-- @Sockets @Invocation #invoc -->
<p>To send a socket command and receive any reply, run SpaceFM with the -s (--socket-cmd) option.  Any reply will be written to stdout and any errors or warnings to stderr.  If an error occurs, the exit status will be set.

<!-- # Help Reference #help -->
<p>To see the help reference for SpaceFM's socket commands, run:
<pre><b>$ spacefm -s help</b>
SpaceFM socket commands permit external processes (such as command scripts)
to read and set GUI property values and execute methods inside running SpaceFM
windows.  To handle events see <a href="#sockets-menu">View|Event Manager</a> in the main menu bar.

Usage:
    spacefm --socket-cmd|-s METHOD [OPTIONS] [ARGUMENT...]
Example:
    spacefm -s set window_size 800x600

<a href="#sockets-methods">METHODS</a>
-------
spacefm -s <a href="#sockets-methods-set">set</a> [OPTIONS] PROPERTY [VALUE...]
    Sets a property

spacefm -s <a href="#sockets-methods-get">get</a> [OPTIONS] PROPERTY
    Gets a property

spacefm -s <a href="#sockets-methods-set-task">set-task</a> [OPTIONS] TASKID TASKPROPERTY [VALUE...]
    Sets a task property

spacefm -s <a href="#sockets-methods-get-task">get-task</a> [OPTIONS] TASKID TASKPROPERTY
    Gets a task property

spacefm -s <a href="#sockets-methods-run-task">run-task</a> [OPTIONS] TASKTYPE ARGUMENTS
    Starts a new task

spacefm -s <a href="#sockets-methods-emit-key">emit-key</a> [OPTIONS] KEYCODE [MODIFIER]
    Activates a menu item by emitting its shortcut key

spacefm -s <a href="#sockets-methods-show-menu">show-menu</a> [OPTIONS] MENUNAME
    Shows custom submenu named MENUNAME as a popup menu

spacefm -s <a href="#sockets-methods-add-event">add-event</a> EVENT COMMAND ...
    Add asynchronous handler COMMAND to EVENT

spacefm -s <a href="#sockets-methods-replace-event">replace-event</a> EVENT COMMAND ...
    Add synchronous handler COMMAND to EVENT, replacing default handler

spacefm -s <a href="#sockets-methods-remove-event">remove-event</a> EVENT COMMAND ...
    Remove handler COMMAND from EVENT

spacefm -s help|--help
    Shows this help reference.

<a name="socket-options"><a href="#socket-options">OPTIONS</a></a>
-------
Add options after METHOD to specify a specific window, panel, and/or tab.
Otherwise the current tab of the current panel in the last window is used.

--window WINDOWID
    Specify window.  eg: spacefm -s set --window 0x104ca80 window_size 800x600
--panel PANEL
    Specify panel 1-4.  eg: spacefm -s set --panel 2 bookmarks_visible true
--tab TAB
    Specify tab 1-...  eg: spacefm -s set --tab 3 selected_filenames fstab

<a name="socket-props"><a href="#socket-props">PROPERTIES</a></a>
----------
Set properties with METHOD 'set', or get the value with 'get'.

window_size                     eg '800x600'
window_position                 eg '100x50'
window_maximized                1|true|yes|0|false|no
window_fullscreen               1|true|yes|0|false|no
screen_size                     eg '1024x768'  (read-only)
window_vslider_top              eg '100'
window_vslider_bottom           eg '100'
window_hslider                  eg '100'
window_tslider                  eg '100'
focused_panel                   1|2|3|4|prev|next|hide
focused_pane                    filelist|devices|bookmarks|dirtree|pathbar
current_tab                     1|2|...|prev|next|close
tab_count                       1|2|...
new_tab                         [DIR]    Open DIR or default in a new tab
devices_visible                 1|true|yes|0|false|no
bookmarks_visible               1|true|yes|0|false|no
dirtree_visible                 1|true|yes|0|false|no
toolbar_visible                 1|true|yes|0|false|no
sidetoolbar_visible             1|true|yes|0|false|no
hidden_files_visible            1|true|yes|0|false|no
panel1_visible                  1|true|yes|0|false|no
panel2_visible                  1|true|yes|0|false|no
panel3_visible                  1|true|yes|0|false|no
panel4_visible                  1|true|yes|0|false|no
panel_hslider_top               eg '100'
panel_hslider_bottom            eg '100'
panel_vslider                   eg '100'
column_width                    name|size|type|permission|owner|modified WIDTH
sort_by                         name|size|type|permission|owner|modified
sort_ascend                     1|true|yes|0|false|no
sort_natural                    1|true|yes|0|false|no
sort_case                       1|true|yes|0|false|no
sort_hidden_first               1|true|yes|0|false|no
sort_first                      files|folders|mixed
large_icons                     1|true|yes|0|false|no
statusbar_text                  eg 'Current Status: Example'
pathbar_text                    [TEXT [SELSTART [SELEND]]]
current_dir                     DIR            eg '/etc'
selected_filenames              [FILENAME ...]
selected_pattern                [PATTERN]      eg '*.jpg'
clipboard_text                  eg 'Some\nlines\nof text'
clipboard_primary_text          eg 'Some\nlines\nof text'
clipboard_from_file             eg '~/copy-file-contents-to-clipboard.txt'
clipboard_primary_from_file     eg '~/copy-file-contents-to-clipboard.txt'
clipboard_copy_files            FILE ...  Files copied to clipboard
clipboard_cut_files             FILE ...  Files cut to clipboard

<a name="socket-tprops"><a href="#socket-tprops">TASK PROPERTIES</a></a>
---------------
status                          contents of Status task column  (read-only)
icon                            eg 'gtk-open'
count                           text to show in Count task column
folder                          text to show in Folder task column
item                            text to show in Item task column
to                              text to show in To task column
progress                        Progress percent (1..100) or '' to pulse
total                           text to show in Total task column
curspeed                        text to show in Current task column
curremain                       text to show in CRemain task column
avgspeed                        text to show in Average task column
avgremain                       text to show in Remain task column
elapsed                         contents of Elapsed task column (read-only)
started                         contents of Started task column (read-only)
queue_state                     run|pause|queue|stop
<a href="#pophandler">popup_handler</a>                   COMMAND  command to show a custom task dialog

<a href="#sockets-methods-run-task">TASK TYPES</a>
----------
<a href="#run-task-cmd">cmd</a> [--task] [--popup] [--scroll] [--terminal] [--icon ICON] \
    [--dir DIR] COMMAND...      Run COMMAND as USER in DIR
<a href="#run-task-copy">copy|move|link</a> [--dir DIR] FILE|DIR... TARGET
                                Copy|Move|Link FILE(s) or DIR(s) to TARGET dir
<a href="#run-task-del">delete</a> [--dir DIR] FILE|DIR...  Recursively delete FILE(s) or DIR(s)
<a href="#run-task-edit">edit</a> [--as-root] FILE           Open FILE in user's or root's text editor
<a href="#run-task-web">web</a> URL                         Open URL in user's web browser
<a href="#run-task-mount">mount</a> DEVICE|URL                Mount DEVICE or URL
<a href="#run-task-unmount">unmount</a> DEVICE|DIR              Unmount DEVICE or mount point DIR

<a href="#sockets-events">EVENTS</a>
------
<a href="#sockets-events-start">evt_start</a>                       Instance start        %e
<a href="#sockets-events-exit">evt_exit</a>                        Instance exit         %e
<a href="#sockets-events-winnew">evt_win_new</a>                     Window new            %e %w %p %t
<a href="#sockets-events-winfoc">evt_win_focus</a>                   Window focus          %e %w %p %t
<a href="#sockets-events-winmov">evt_win_move</a>                    Window move/resize    %e %w %p %t
<a href="#sockets-events-winclk">evt_win_click</a>                   Mouse click           %e %w %p %t %b %m %f
<a href="#sockets-events-winkey">evt_win_key</a>                     Window keypress       %e %w %p %t %k %m
<a href="#sockets-events-wincls">evt_win_close</a>                   Window close          %e %w %p %t
<a href="#sockets-events-pnlfoc">evt_pnl_focus</a>                   Panel focus           %e %w %p %t
<a href="#sockets-events-pnlshw">evt_pnl_show</a>                    Panel show/hide       %e %w %p %t %f %v
<a href="#sockets-events-pnlsel">evt_pnl_sel</a>                     Selection changed     %e %w %p %t
<a href="#sockets-events-tabnew">evt_tab_new</a>                     Tab new               %e %w %p %t
<a href="#sockets-events-tabfoc">evt_tab_focus</a>                   Tab focus             %e %w %p %t
<a href="#sockets-events-tabcls">evt_tab_close</a>                   Tab close             %e %w %p %t
<a href="#sockets-events-device">evt_device</a>                      Device change         %e %f %v

<a name="evtsub"><a href="#evtsub">Event COMMAND Substitution Variables:</a></a>
%e   event name (evt_start|evt_exit|...)
%w   window ID
%p   panel number (1-4)
%t   tab number (1-...)
%b   mouse button (0=double 1=left 2=middle 3=right ...
%k   key code  (eg 0x63)
%m   modifier key (eg 0x4  used with clicks and keypresses)
%f   focus element (panelN|filelist|devices|bookmarks|dirtree|pathbar)
%v   focus element is visible (0 or 1, or device state change)

Examples:

    window_size="$(spacefm -s get window_size)"
    spacefm -s set window_size 1024x768
    spacefm -s set column_width name 100
    spacefm -s set-task $fm_my_task progress 25
    spacefm -s run-task --window $fm_my_window cmd --task --popup ls /etc
    spacefm -s run-task copy --dir /etc fstab hosts /destdir
    spacefm -r /etc; sleep 0.3; spacefm -s set selected_filenames fstab hosts
    spacefm -s set clipboard_copy_files /etc/fstab /etc/hosts
    spacefm -s emit-key 0xffbe 0   # press F1 to show Help
    spacefm -s show-menu --window $fm_my_window "Custom Menu"
    spacefm -s add-event evt_pnl_sel 'spacefm -s set statusbar_text "$fm_file"'

    #!/bin/bash
    eval copied_files="$(spacefm -s get clipboard_copy_files)"
    echo "These files have been copied to the clipboard:"
    i=0
    while [ "${copied_files[i]}" != "" ]; do
        echo "    ${copied_files[i]}"
        (( i++ ))
    done
    if (( i != 0 )); then
        echo "MD5SUMS:"
        md5sum "${copied_files[@]}"
    fi
</pre>

<!-- @Sockets @Methods -->
<p>Methods represent different kinds of socket commands:

<!-- # set -->
Usage: <b>spacefm -s set [OPTIONS] PROPERTY [VALUE...]</b>

<p>The set method sets a property to one or more values.  Different properties accept different kinds of values.  To see what values a property accepts, look the property up in the <a href="#socket-props">Help Reference</a>.

<p>As with all methods, by default the set method will apply to the current tab in the current panel of the last used SpaceFM window.  You can also specify a particular window, panel, and/or tab using the --window, --panel, and/or --tab <a href="#socket-options">OPTIONS</a>.  (The WINDOWID used by the --window option is obtained from the $fm_my_window <a href="#exvar">bash variable</a>.)  For example:
<pre>
    spacefm -s set --window $fm_my_window --panel 3 --tab 2 pathbar_text "/"
</pre>

<p>Examples using the set method:
<pre>
    # Set the size of the last used SpaceFM window:
    spacefm -s set window_size 1024x768
    
    # Set the size of my tasks's SpaceFM window
    spacefm -s set <b>--window $fm_my_window</b> window_size 1024x768

    # Maximize the window:
    spacefm -s set window_maximized 1
    
    # Show panel 3:
    spacefm -s set panel3_visible true
    
    # Focus panel 3:
    spacefm -s set focused_panel 3

    # Hide the Dir Tree:
    spacefm -s set dirtree_visible 0
    
    # Set the position of the vertical slider between panels 1 and 2:
    spacefm -s set window_vslider_top 400

    # Set the width of the Name column:
    spacefm -s set column_width name 100
    
    # Set the text in panel 2's status bar:
    spacefm -s set <b>--panel 2</b> statusbar_text "Custom Status"

    # Remove the custom text in panel 2's status bar:
    spacefm -s set <b>--panel 2</b> statusbar_text

    # Set the text in the pathbar:
    spacefm -s set pathbar_text "/etc"
    
    # Set the text in the pathbar and select it:
    spacefm -s set pathbar_text "/etc" 0
    
    # Focus the pathbar (put cursor there):
    spacefm -s set focused_pane pathbar
    
    # Change to directory '/etc':
    spacefm -s set current_dir '/etc'

    # Select files named 'fstab' and 'hosts', unselect others:
    spacefm -s set selected_files 'fstab' 'hosts'

    # Unselect all files:
    spacefm -s set selected_files

    # Select all files:
    spacefm -s set selected_pattern '*'

    # Select all jpg files, unselect others:
    spacefm -s set selected_pattern '*.jpg'

    # Copy text to the clipboard:
    spacefm -s set clipboard_text 'Some text'
    
    # Copy multiple lines of text to the clipboard:
    spacefm -s set clipboard_text 'Some\nlines\nof text'
    
    # Copy the contents of a text file to the clipboard:
    spacefm -s set clipboard_from_file /etc/fstab
    
    # Copy text to the primary (middle-click) clipboard:
    spacefm -s set clipboard_primary_text 'Some primary text'

    # Copy files to the clipboard:
    spacefm -s set clipboard_copy_files /etc/fstab /etc/hosts

    # Cut files to the clipboard:
    spacefm -s set clipboard_cut_files /etc/fstab /etc/hosts

    # Adjust sort settings:
    spacefm -s set sort_by size
    spacefm -s set sort_by name
    spacefm -s set sort_ascend false
    spacefm -s set sort_natural true
    spacefm -s set sort_first folders
</pre>




<!-- # get -->
Usage: <b>spacefm -s get [OPTIONS] PROPERTY</b>

<p>The get method gets a property's value.  The reply is written to stdout.

<p>As with all methods, by default the get method will apply to the current tab in the current panel of the last used SpaceFM window.  You can also specify a particular window, panel, and/or tab using the --window, --panel, and/or --tab OPTIONS.

<p>The reply to a get can be saved in a bash variable directly:
<pre>
    size="$(spacefm -s get window_size)"
    echo "$size"
</pre>

Or, the reply can be tested directly:
<pre>
    if [ "$(spacefm -s get clipboard_text)" == "" ]; then
	echo "The clipboard is empty"
    fi
</pre>

<p>Examples using the get method:
<pre>
    # Is the window maximized?
    spacefm -s get window_maximized
    
    # Is panel 3 shown?
    spacefm -s get panel3_visible
    
    # Which panel is focused?
    spacefm -s get focused_panel
    
    # Is the Bookmarks pane shown in panel 4?
    spacefm -s get <b>--panel 4</b> bookmarks_visible
    
    # Get the position of the vertical slider between panels 1 and 2:
    spacefm -s get window_vslider_top

    # Get the width of the Size column:
    spacefm -s get column_width size
    
    # Get the text in panel 2's status bar:
    spacefm -s get <b>--panel 2</b> statusbar_text

    # Get the current directory of tab 2:
    spacefm -s get <b>--tab 2</b> current_dir 

    # Get the text on the clipboard:
    spacefm -s get clipboard_text
    
    # Get the text on the clipboard and write it to a file:
    spacefm -s get clipboard_text > /tmp/clipboard-contents.txt
</pre>
<br><br><b>When the clipboard contains cut or copied files</b>, <i>clipboard_text</i> will contain the paths of the files, one per line, as text.

<p>Or, when getting the value of <i>clipboard_copy_files</i> or <i>clipboard_cut_files</i>, SpaceFM will reply with an array of quoted paths.  For example:
<pre>
    # First copy some files to the clipboard:
    spacefm -s set clipboard_copy_files /etc/fstab /etc/hosts

    # Now get the files on the clipboard:
    spacefm -s get clipboard_copy_files
    <i>('/etc/fstab' '/etc/hosts' )</i>
</pre>

The returned value in the above example is intended to be saved to a bash array using eval.  For example, the following script reads the copied files into an array, prints each member of the array, one per line, then calculates the MD5 sums of the files by passing the array to md5sum as a list:
<pre>
    #!/bin/bash
    # Read the copied files into an array:
    eval copied_files="$(spacefm -s get clipboard_copy_files)"

    echo "These files have been copied to the clipboard:"
    i=0
    while [ "${copied_files[i]}" != "" ]; do
        echo "    ${copied_files[i]}"
        (( i++ ))
    done
    if (( i != 0 )); then
        echo "MD5SUMS:"
        md5sum "${copied_files[@]}"
    fi
</pre>

Note that when files have been <i>copied</i> to the clipboard, <i>clipboard_copy_files</i> will contain the list, and <i>clipboard_cut_files</i> will be empty.  When files have been <i>cut</i> to the clipboard, <i>clipboard_cut_files</i> will contain the list, and <i>clipboard_copy_files</i> will be empty.

<p>Traditionally, when cut files are successfully copied to another location, you should then delete them from their original location, whereas files which have merely been copied to the clipboard are never deleted.

<p>Likewise, <b>when getting the value of <i>selected_filenames</i></b>, SpaceFM will reply with an array of quoted filenames.  For example:
<pre>
    #!/bin/bash
    # Read the selected filenames into an array:
    eval sel_files="$(spacefm -s get selected_filenames)"
    
    echo "These filenames are selected:"
    i=0
    while [ "${sel_files[i]}" != "" ]; do
        echo "    ${sel_files[i]}"
        (( i++ ))
    done
    if (( i != 0 )); then
        cd "$(spacefm -s get current_dir)"
        echo "MD5SUMS:"
        md5sum "${sel_files[@]}"
    fi
</pre>
<br>




<!-- # set-task -->
Usage: <b>spacefm -s set-task [OPTIONS] TASKID TASKPROPERTY [VALUE...]</b>

<p>The set-task method is used to change the display values for a task, and also to stop, pause, queue, or resume a task, by setting a task property.  Different task properties accept different kinds of values.  To see what values a task property accepts, look the task property up in the <a href="#socket-tprops">Help Reference</a>.

<p>Display values for a task are shown in the <a href="#tasks-man">Task Manager</a>, and also in task <a  href="#tasks-dlg">popup dialogs</a>.  These include such things as the Item, Total, Current, Remain, and other columns, the progress bar percentage, etc.

<p>As with all methods, by default the set-task method will apply to the current tab in the current panel of the last used SpaceFM window.  You can also specify a particular window, panel, and/or tab using the --window, --panel, and/or --tab OPTIONS.

<p>The set-task method requires a TASKID, which indicates what task is being modified.  There are two ways to obtain the TASKID.  One is to use the <a href="#exvar">exported bash variable</a> $fm_my_task, which refers to the current command task.  The other is to use $fm_task_id, which refers to the task currently <i>selected</i> in the task list when the current task is run.  Note that a TASKID is only valid in the window in which the task is currently running, so it's generally appropriate to specify a WINDOWID ($fm_my_window) with the --window option to ensure the correct window is accessed.

<p>Note that when using $fm_my_task, the TASKID will not be valid when the command is first run - <b>it usually takes about a half second for a task to appear in the task manager</b>.  If your script uses $fm_my_task immediately, it should plan for the socket command to fail until the task is shown in the task manager, or it can use a small delay (sleep 0.75) before sending task-related socket commands.

<p>Also, <b>if a custom command is run from the SpaceFM desktop manager menu</b>, note that there is no task manager or window associated with the task, so the TASKID will not be valid in socket commands.

<p>Examples using the set-task method:
<pre>
    # Set my task's progress bar to 25%:
    spacefm -s set-task --window $fm_my_window $fm_my_task progress 25

    # Set the current item being processed in my task:
    spacefm -s set-task --window $fm_my_window $fm_my_task item "File 2"

    # Set the average speed displayed for my task (any text is valid):
    spacefm -s set-task --window $fm_my_window $fm_my_task avgspeed "10 M/s"

    # Pause my task:
    spacefm -s set-task --window $fm_my_window $fm_my_task queue_state pause
</pre>

<br>
<a name="pophandler"><b>The task property 'popup_handler'</b></a>, which accepts a bash command line, allows you to set a command to be run when the user clicks on the task in the Task Manager.  Normally a click opens a task's <a  href="#tasks-dlg">popup dialog</a>, but if popup_handler is set, that command will be run instead.  This allows you to integrate your custom command's dialog into SpaceFM.  The following script, <i>to be run as a <a href="#designmode-command-script">custom command script</a> in SpaceFM</i>, demonstrates this property's use:
<pre>
    #!/bin/bash
    # Set a custom task dialog in SpaceFM.
    # Run this script as a SpaceFM custom command script.
    $fm_import
    
    # make a command pipe to talk to the dialog
    cmdpipe=/tmp/spacefm-task-dialog.pipe
    rm -f "$cmdpipe"
    mkfifo "$cmdpipe"
    
    # must wait for this task to be shown in manager before setting property
    <b>( sleep .75; \
      spacefm -s set-task $fm_my_task popup_handler "echo show > '$cmdpipe'" ) &amp;</b>
    
    # show dialog
    spacefm -g --label "\nThis window will be shown when you click on this \
    task in SpaceFM's Task Manager." \
               --button close rm "$cmdpipe" -- close \
               --command "$cmdpipe" \
               --window-close rm "$cmdpipe" -- close > /dev/null
    
    # cleanup
    <b>spacefm -s set-task $fm_my_task popup_handler</b>
    rm -f "$cmdpipe"
    exit
</pre>

Running the above command script within SpaceFM will show the dialog.  Anytime you click on the task in the list, the dialog will be raised.  Note that the popup_handler command is only run when the user clicks on the task in the list.  It is not run when the normal task popup dialog is raised due to a task's <a href="#designmode-command-popup">Popup settings</a>.

<p>When popup_handler is set, the additional <a href="#tasks-menu-showout">Show Output</a> menu item will appear in the right-click context menu for the task, which opens the normal popup dialog.


<!-- # get-task -->
Usage: <b>spacefm -s get-task [OPTIONS] TASKID TASKPROPERTY</b>

<p>The get-task method gets a task property's value.  The reply is written to stdout.  For instructions on saving the reply to a variable or testing it directly, see the examples in <a href="#sockets-methods-get">get</a>.

<p>As with the <a href="#sockets-methods-set-task">set-task</a> method, get-task requires a TASKID, and passing a WINDOWID is also recommended.

<p>Examples using the get-task method:
<pre>
    # Get my task's progress bar value:
    spacefm -s get-task --window $fm_my_window $fm_my_task progress

    # Get the current status of my task (this is a read-only value):
    spacefm -s get-task --window $fm_my_window $fm_my_task status

    # Get the <a href="#tasks-queue">running state</a> of my task (run|pause|queue):
    spacefm -s get-task --window $fm_my_window $fm_my_task queue_state
</pre>

<!-- # run-task -->
Usage: <b>spacefm -s run-task [OPTIONS] TASKTYPE [TYPEOPTIONS] ARGUMENTS</b>

<p>The run-task method is used to tell a running SpaceFM window to start a new task.  A task may run an asynchronous command (run and forget), a command run as a SpaceFM task (shown in the <a href="#tasks-man">Task Manager</a> if it runs for more than one half second), or an internal task to copy, move, or delete files, or create links.  A task can also be used to run a command in the user's configured terminal, open a file in the user's configured text editor, or open a URL in the user's web browser.

<p>To run a task in a particular SpaceFM window, or with the <a href="#exvar">exported bash variables</a> of a particular tab, --window, --panel, and --tab <a href="#socket-options">OPTIONS</a> may be included.

<p>Each TASKTYPE accepts a different set of TYPEOPTIONS and ARGUMENTS, as detailed below.

<p><b>NOTE:</b>  The run-task method was added in SpaceFM 0.8.7.  If sharing a plugin the user's current SpaceFM version can be examined with <code>spacefm --version</code>.

<p><a name="run-task-cmd"><a href="#run-task-cmd">cmd [--task] [--popup] [--scroll] [--terminal] [--icon ICON] [--dir DIR] COMMAND...</a></a>

<p>The <b>cmd</b> (or 'command') TASKTYPE is used to run a program or bash command.  <a href="#exvar">Exported bash variables</a> may be used in any COMMAND - just remember to include the $fm_import line in your command or script.  Note that the contents of the variables will reflect the window, panel, and tab active for the socket command, not necessarily the focused tab of SpaceFM.

<p>By default COMMAND is run asynchronously (run and forgotten).  It will not appear in the <a href="#tasks-man">Task Manager</a>, and no popup will be shown.  For example:
<pre>    spacefm -s run-task cmd <b>touch /tmp/a_new_file</b></pre>

cmd also accepts the following TYPEOPTIONS:

<p>
<table border=1 cellpadding="5">
<tr>
	<th>TYPEOPTION</th>
	<th>Use</th>
</tr>
	<tr>
		<td>--task</td>
		<td>Run COMMAND as a SpaceFM task and list it in the Task Manager if it runs for more than one half second, and show a <a href="#tasks-dlg">popup dialog</a> if the command's exit status is non-zero.  This is equivalent to custom command options <a href="#designmode-command-task">Run As Task</a> plus <a href="#designmode-command-poperr">Popup Error</a>.</td>
	</tr><tr>
		<td>--popup</td>
		<td>Run COMMAND as a SpaceFM task and show a popup dialog if the task runs for longer than one half second or produces output or an error.  This is equivalent to custom command options <a href="#designmode-command-task">Run As Task</a> plus <a href="#designmode-command-popout">Popup Output</a> plus <a href="#designmode-command-poperr">Popup Error</a>.</td>
	</tr><tr>
		<td>--scroll</td>
		<td>If option --task or --popup is used with --scroll, the scrollbar in the popup will be moved down, equivalent to custom command option <a href="#designmode-command-scroll">Scroll</a>.</td>
	</tr><tr>
		<td>--terminal</td>
		<td>Run COMMAND in the user's configured terminal emulator.  This is equivalent to custom command option <a href="#designmode-command-terminal">Run In Terminal</a>.  Generally this option is used <i>without</i> --task or --popup.</td>
	</tr><tr>
		<td>--icon ICON</td>
		<td>Use ICON as the task's icon in the Task Manager and popup dialog, where ICON is an icon name or absolute path.  Not all icons may be shown due to various issues.</td>
	</tr><tr>
		<td>--dir DIR</td>
		<td>Start COMMAND in working directory DIR.  If not specified, SpaceFM's current working directory is used.</td>
	</tr>
</table>

<p>If the --task or --popup options are used, meaning the task is run as a SpaceFM task, the command will return values for $new_task_id and $new_task_window, to be used in future socket commands for this running task.  For example:
<pre>    spacefm -s run-task cmd --popup 'while true; do date; sleep 1; done'
<i>    #!/bin/bash
    # Note: $new_task_id not valid until approx one half second after task start
    new_task_window=0x207a030
    new_task_id=0x2343150</i></pre>

The output can be evaluated in one step like so (note the double-quoted backticks):
<pre>    eval "`spacefm -s run-task cmd --popup 'while true; do date; sleep 1; done'`"
    echo "Task window is $new_task_window and ID is $new_task_id."
<i>    Task window is 0x207a030 and ID is 0x23432a0.</i></pre>

Note when attempting to use $new_task_id in socket commands, the task ID will not be recognized until the task is listed in the <a href="#tasks-man">Task Manager</a>, which takes about one half second (if the command runs that long).


<p><a name="run-task-copy"><a href="#run-task-copy">copy|move|link [--dir DIR] FILE|DIR... TARGET</a></a>

<p>The copy, move, and link TASKTYPEs start an internal SpaceFM task to copy, move, or create links to files and folders.  The task will be listed in the <a href="#tasks-man">Task Manager</a> if it runs for longer than one half second.  If files already exist in the TARGET directory, the SpaceFM overwrite query dialog will be shown as usual.

<p>FILE(s) and DIR(s) may be specified as absolute paths.  Or, if the --dir DIR option is used to specify an (absolute) source directory, they may be relative to DIR.  Each FILE and DIR specified must exist.  TARGET, which is required as the last argument, specifies an absolute destination directory.

<p>For example:
<pre>    spacefm -s run-task copy /etc/fstab /etc/hosts /tmp</pre>

The above command will copy the files 'fstab' and 'hosts' from /etc to /tmp.  Also, the following command is equivalent:
<pre>    spacefm -s run-task copy <b>--dir /etc</b> fstab hosts /tmp</pre>

In the above case, a source directory is specified so that simple filenames may be used in place of absolute paths.

<p>Another example, to create links to files and folders:
<pre>    spacefm -s run-task link /etc /etc/fstab /tmp</pre>

The above command will create links to the folder /etc and the file /etc/fstab, placing them in /tmp.

<p>As with the cmd TASKTYPE, copy, move, and link TASKTYPEs will output $new_task_window and $new_task_id for evaluation and later use.

<p><a name="run-task-del"><a href="#run-task-del">delete [--dir DIR] FILE|DIR...</a></a>

<p>The delete TASKTYPE starts an internal SpaceFM task to <b>recursively</b> delete files and folders.  The task will be listed in the Task Manager if it runs for longer than one half second.

<p>FILE(s) and DIR(s) may be specified as absolute paths.  Or, if the --dir DIR option is used to specify an (absolute) source directory, they may be relative to DIR.  Each FILE and DIR must exist.

<p><b>WARNING:</b>  No confirmation dialog is shown to the user before files are deleted permanently.  If you want a confirmation dialog, your command or script must show one itself.  Also note that any specified folders are deleted recursively.

<p>For example, to delete the links created in the previous example:
<pre>    spacefm -s run-task delete /tmp/etc /tmp/fstab</pre>

<p>As with the cmd TASKTYPE, the delete TASKTYPE will output $new_task_window and $new_task_id for evaluation and later use.


<p><a name="run-task-edit"><a href="#run-task-edit">edit [--as-root] FILE</a></a>

<p>The edit TASKTYPE opens FILE in the user's configured text editor (set in View|Preferences|Advanced).  Or, if the --as-root option is included, FILE is opened in the user's configured root editor.  This task type is always asynchronous (run and forgotten).  For example:
<pre>    spacefm -s run-task edit /etc/fstab</pre>

<b>IMPORTANT:</b>  If sharing a plugin which does anything as root, please be sure to include this information clearly in the plugin's description.

<p><a name="run-task-web"><a href="#run-task-web">web URL</a></a>

<p>The web TASKTYPE opens URL in the user's configured or auto-discovered web browser (set in Help|Options|Browser).  This task type is always asynchronous (run and forgotten).  For example:
<pre>    spacefm -s run-task web http://ignorantguru.github.io/spacefm/</pre>

<b>IMPORTANT:</b>  If sharing a plugin which open URLs in the user's browser, please be sure to include this information clearly in the plugin's description.
<br><br>

<p><a name="run-task-mount"><a href="#run-task-mount">mount DEVICE|URL</a></a>

<p>The mount TASKTYPE uses the appropriate device or protocol <a href="#handlers">handler</a> to mount a DEVICE (eg /dev/sdd1) or URL (eg ftp://mirrors.kernel.org/).  This task type may produce an error pop-up message, but does not set an error status on failure.  For example:
<pre>    spacefm -s run-task mount /dev/sdd1</pre>

Note: If you want to both mount and open a device or URL in SpaceFM's file manager, consider using:
<pre>    spacefm /dev/sdd1
    <b>or</b>
    spacefm ftp://mirrors.kernel.org/</pre>


<p><a name="run-task-unmount"><a href="#run-task-unmount">unmount DEVICE|DIR</a></a>

<p>The unmount TASKTYPE uses the appropriate device or protocol <a href="#handlers">handler</a> to unmount a DEVICE (eg /dev/sdd1) or mount point DIR.  This task type may produce an error pop-up message, but does not set an error status on failure.  For example:
<pre>    spacefm -s run-task unmount /dev/sdd1</pre>


<!-- # emit-key -->
Usage: <b>spacefm -s emit-key [OPTIONS] KEYCODE [MODIFIER]</b>

<p>The emit-key method activates the menu item with the given shortcut key, as if the user had pressed the key combination.

<p>The KEYCODE and MODIFIER for a given key combination can be see by right-clicking on a menu item, selecting <a href="#designmode-designmenu-key">Key Shortcut</a>, and pressing the key combination.

<p>For example, to activate the menu item associated with Ctrl+C (associated with Copy by default):
<pre>    spacefm -s emit-key 0x63 0x4</pre>

The KEYCODE and MODIFIER may also be specifed as decimal numbers by omitting the '0x' hexadecimal prefix.


<!-- # show-menu -->
Usage: <b>spacefm -s show-menu [OPTIONS] MENUNAME</b>

<p>The show-menu method is used to display any <a href="#designmode-designmenu-submenu">custom submenu</a> as a popup menu.  MENUNAME is the name of the submenu as it appears in the menu (underscores may be omitted).  If multiple custom submenus have MENUNAME as their name, only one be displayed.

<p>For example, add a submenu anywhere named "Gizmos", and add one or more commands inside the submenu.  To make it popup:
<pre>    spacefm -s show-menu 'Gizmos'</pre>

<p>When using show-menu from within an <a href="#sockets-events-winclk">evt_win_click</a> event handler for the file list, a small delay may be needed before the menu is shown to prevent it from closing immediately when the mouse button is released:
<pre>    *if [ "%b" != "2" ]; then exit 1; fi; ( sleep .2; spacefm -s show-menu "A-C" ) &amp;</pre>

Because the sleep and spacefm commands are within parentheses, they are both backgrounded by the ampersand (&amp;), preventing a lag in the GUI.



<!-- # add-event -->
Usage: <b>spacefm -s add-event EVENT COMMAND ...</b>

<p>The add-event method is used to dynamically add an asynchronous handler command to an event, such that when <a href="#sockets-events">EVENT</a> occurs, COMMAND will be run asynchronously (SpaceFM won't wait for it to finish).

<p>COMMAND is a bash command line.  If any arguments follow it, they are added to the command before it is passed to bash.  For all events <i>except</i> <a href="#sockets-events-start">evt_start</a>, <a href="#sockets-events-exit">evt_exit</a>, <a href="#sockets-events-tabcls">evt_tab_close</a>, and <a href="#sockets-events-device">evt_device</a>, the <a href="#exvar">exported bash variables</a> can be used in the command.  COMMAND also accepts <a href="#evtsub">event substitution variables</a>, which will vary with the event type.

<p>add-event may be used any number of times to add additional event handler commands to the same or different event types.

<p>Note that COMMAND will continue to run anytime EVENT occurs during the lifetime of the current SpaceFM instance, so be sure to <a href="#sockets-methods-remove-event">remove the handler</a> when your script is finished using it.

<p>In addition to adding dynamic event handlers, you can also set static event handlers using the <a href="#sockets-menu">View|Event Manager menu</a>.

<p>Note that a single SpaceFM instance may open multiple windows, so your handler will run when events occur in any window.  The handler can test for a specific window using the %w (window ID) substitution variable in the command (which will correspond to a task's $fm_my_window <a href="#exvar">bash variable</a>).

<p>For example, the following command will add a handler to the <a href="#sockets-events-pnlsel">evt_pnl_sel</a> (selection has changed) event, such that anytime the user changes the selection of files in the file list, the status bar will be set to display the first selected file's path:
<pre>    spacefm -s add-event evt_pnl_sel 'spacefm -s set statusbar_text "$fm_file"'</pre>

Note that to preserve the quotes and dollar sign for bash to evaluate, the entire command is single-quoted and passed as a single argument.  Alternatively, escaping those characters yields the same result:
<pre>    spacefm -s add-event evt_pnl_sel spacefm -s set statusbar_text \"\$fm_file\"</pre>


<!-- # replace-event -->
Usage: <b>spacefm -s replace-event EVENT COMMAND ...</b>

<p>The replace-event method is used to dynamically add a synchronous handler command to an event, such that when <a href="#sockets-events">EVENT</a> occurs, COMMAND will be run synchronously (SpaceFM will wait for it to finish, and will examine the exit status).

<p>Because the command is run synchronously, SpaceFM's GUI will freeze while the command is being run.  Your command should return a quick exit status to make this freeze minimal, then spawn a process to continue to perform whatever actions are desired.

<p>For event types <a href="#sockets-events-winclk">evt_win_click</a> (a mouse click), <a href="#sockets-events-winkey">evt_win_key</a> (a keypress), and <a href="#sockets-events-pnlsel">evt_pnl_sel</a> (file selection changed), SpaceFM will use the exit status of your command to determine whether SpaceFM's built-in handler for the event type should run after your command.  If the exit status is zero, this will inhibit the built-in handler.  For example, if the user clicks the right mouse button, and your command returns zero exit status, SpaceFM will not show the right-click context menu normally shown by the built-in handler.

<p>If more than one replace-event is set for a evt_win_click, evt_win_key, or evt_pnl_sel event type (including one set in the <a href="#sockets-menu">View|Event Manager</a> menu), any zero exit status will inhibit the built-in handler.

<p>Using replace-event to set a handler for an event type <i>other than</i> evt_win_click, evt_win_key or evt_pnl_sel will cause the command to run synchronously (SpaceFM will wait for it and it will freeze the GUI until it exits) but the exit status will have no effect.  (These events are notification only, so there is no built-in handler to inhibit.)

<p>COMMAND is a bash command line.  If any arguments follow it, they are added to the command before it is passed to bash.  <a href="#exvar">Exported bash variables</a> may NOT be used in COMMAND.  COMMAND also accepts <a href="#evtsub">event substitution variables</a>, which will vary with the event type.

<p>replace-event may be used any number of times to add additional synchronous event handler commands to the same or different event types.

<p>Note that COMMAND will continue to run anytime EVENT occurs during the lifetime of the current SpaceFM instance, so be sure to <a href="#sockets-methods-remove-event">remove the handler</a> when your script is finished using it.

<p>For example, the following command will add a handler to the <a href="#sockets-events-winclk">evt_win_click</a> event.  If the user clicks a button other than the middle mouse button (%b = 2), the command returns exit status 1, so the built-in handler is used.  But if the user clicks the middle mouse button, then a dialog message is displayed, and the command returns 0 (the default status on success), inhibiting the built-in handler.
<pre>    spacefm -s replace-event evt_win_click 'if [ "%b" != "2" ]; then exit 1; fi; \
        spacefm -g --label "\nMiddle button was clicked" --button ok &amp;'</pre>

Note the ampersand (&amp;) after the 'spacefm -g' command.  This runs the command asynchronously (run and forget) so the exit status is returned immediately and it doesn't cause a lag in the GUI.


<!-- # remove-event -->
Usage: <b>spacefm -s remove-event EVENT COMMAND ...</b>

<p>The remove-event method removes an event handler previously set with the <a href="#sockets-methods-add-event">add-event</a> or <a href="#sockets-methods-replace-event">replace-event</a> methods.  You must pass remove-event the exact same EVENT and COMMAND that you passed when adding the handler.

<p>Because all handlers continue to run for the lifetime of the current SpaceFM instance, your scripts should remove all handlers they have added before finishing.  When the SpaceFM instance exits, all dynamic event handlers are automatically removed.  (If you want dynamic handlers to always be present, use the <a href="#sockets-events-start">evt_start</a> event to add them.)

<p>remove-event cannot remove static handlers set in the <a href="#sockets-menu">View|Event Manager</a> menu.

<!-- @Sockets @Events -->
<p>Events represent actions or changes in the GUI, such as the user closing a tab, selecting a file, or opening a new window.  SpaceFM has built-in handlers for these events, which update the GUI, open menus, or take other actions.  You can also add your own handlers for events, commands which are run to take a custom action after the event occurs.  In some cases your custom handler can replace the action normally taken by SpaceFM's built-in handler, allowing you to modify the default behavior in the GUI.

<p>Event handlers can be added in the <a href="#sockets-menu">Event Manager</a> menu.  Those handler commands always run until you remove them.  Dynamic event handlers can also be added using the <a href="#sockets-methods-add-event">add-event</a> or <a href="#sockets-methods-replace-event">replace-event</a> socket methods.  These handlers will remain in effect until you remove them with the remove-event method, or until the SpaceFM instance exits.

<p>The following events are available.  The name in parentheses is the event name as found in the <a href="#sockets-menu">Event Manager</a> menu.  Any <a href="#evtsub">event substitution variables</a> available with the event are shown after it (eg %e).

<!-- # evt_start (Instance|Start) %e # start -->
Occurs only once per instance when the SpaceFM instance first starts.  Note that a single SpaceFM instance may open multiple windows.  This is a good event to use to add any dynamic event handlers which you always want running.

<!-- # evt_exit (Instance|Exit) %e # exit -->
Occurs only once per instance when the SpaceFM instance exits.  If a daemon or desktop manager instance is running, this event will occur when the user logs out.  Otherwise, the instance will exit when the last SpaceFM window is closed.

<!-- # evt_win_new (Window|New) %e %w %p %t # winnew -->
Occurs whenever a new SpaceFM window is opened, including the initial window.

<!-- # evt_win_focus (Window|Focus) %e %w %p %t # winfoc -->
Occurs whenever a SpaceFM window receives focus.  For example, if you switch to another window in your window manager, then switch back to a SpaceFM window, this event will occur.

<!-- # evt_win_move (Window|Move) %e %w %p %t # winmov -->
Occurs whenever a SpaceFM window is moved or resized.  Note that during resizing, any handler for this event may be run multiple times (up to five times per second).

<!-- # evt_win_click (Window|Click) %e %w %p %t %b %m %f # winclk -->
Occurs when the user clicks the mouse in most areas of a SpaceFM window.  The mouse button pressed is available via the substitution variable %b, any key modifier (eg Ctrl+Click) via %m, and the window element which received the click via %f.

<p>If a handler set for the evt_win_click event is synchronous (has an asterisk prefix or is added with the <a href="#sockets-methods-replace-event">replace-event</a> method), and it returns a zero exit status, the built-in handler for the event will be inhibited.

<p>When using <a href="#sockets-methods-show-menu">show-menu</a> from within an evt_win_click event handler, a small delay may be needed before the menu is shown to prevent it from closing immediately when the mouse button is released:
<pre>    *if [ "%b" != "2" ]; then exit 1; fi; ( sleep .2; spacefm -s show-menu "A-C" ) &amp;</pre>

Because the sleep and spacefm command are within parentheses, they are both backgrounded by the ampersand (&amp;), preventing a lag in the GUI.

<!-- # evt_win_key (Window|Keypress) %e %w %p %t %k %m # winkey -->
Occurs when the user presses a key in most areas of a SpaceFM window.  The key code pressed is available via the substitution variable %k, and any key modifier (eg Ctrl+C) via %m.

<p>If a handler set for the evt_win_key event is synchronous (has an asterisk prefix or is added with the <a href="#sockets-methods-replace-event">replace-event</a> method), and it returns a zero exit status, the built-in handler for the event will be inhibited (SpaceFM will not react to the keypress in most cases, even if it's assigned to a menu item).

<!-- # evt_win_close (Window|Close) %e %w %p %t # wincls -->
Occurs whenever a SpaceFM window is closed, including the last window of the instance.

<!-- # evt_pnl_focus (Panel|Focus) %e %w %p %t # pnlfoc -->
Occurs whenever a panel gets focus.  Any handler command for this event will be run whenever a user clicks in the panel, even if the panel is not changed.  The command will also be run if the user switches focus to another panel.

<!-- # evt_pnl_show (Panel|Show) %e %w %p %t %f %v # pnlshw -->
Occurs whenever a panel or panel element is shown or hidden.  The element shown or hidden is available via the substitution variable %f (panelN|filelist|devices|bookmarks|dirtree|pathbar), and the element's visibility (shown or hidden) is available via %v (1=shown or 0=hidden).

<!-- # evt_pnl_sel (Panel|Select) %e %w %p %t # pnlsel -->
Occurs whenever the file selection in a panel changes.  

<p>If a handler set for the evt_pnl_sel event is synchronous (has an asterisk prefix or is added with the <a href="#sockets-methods-replace-event">replace-event</a> method), and it returns a zero exit status, the built-in handler for the event will be inhibited.  (The built-in handler for evt_pnl_sel updates the contents of the panel's status bar, so if you want to handle this yourself, you can inhibit it.)

<!-- # evt_tab_new (Tab|New) %e %w %p %t # tabnew -->
Occurs whenever a new tab is added to a panel, including initial tabs when the window is opened or the panel is first shown.

<!-- # evt_tab_focus (Tab|Focus) %e %w %p %t # tabfoc -->
Occurs whenever a tab gets focus within a panel.  For example, changing tabs will trigger this event.  However, merely switching panels will trigger the <a href="#sockets-events-pnlfoc">evt_pnl_focus</a> event, but not evt_tab_focus.

<!-- # evt_tab_close (Tab|Close) %e %w %p %t # tabcls -->
Occurs whenever a tab is closed.  The tab number which was closed is available via the substitution variable %t, and its panel via %p.  (Note that closing a tab changes panel focus to the panel containing the tab being closed.)

<p>Note that <a href="#exvar">exported bash variables</a> <i>cannot</i> be used in the handler commands for evt_tab_close.

<!-- # evt_device (Device) %e %f %v # device -->
Occurs whenever a device is added, removed, or otherwise changes state (mounted, unmounted, media inserted, etc).  The device file is available via the substitution variable %f, and the change via %v (added|removed|changed).

<p>Note that <a href="#exvar">exported bash variables</a> <i>cannot</i> be used in the handler commands for evt_device.


<!-- @Sockets @Event Manager #menu -->
<p>The Event Manager submenu, located in the main menu bar's View menu, is used to configure static event handler commands to be run when <a href="#sockets-events">events</a> occur.  Each item in this menu opens a dialog in which a program name or bash command line can be entered.  The dialog for each event type also explains when the event occurs and what <a href="#evtsub">event substitution variables</a> are available for use in the command for that event.

<p><a href="#sockets">Socket commands</a> are of particular use in these command lines.  For example, to alter the default text in the status bar so that it shows only the filename of the first selected file, set <a href="#sockets-events-pnlsel">Events|Panel|Select</a> (an event which occurs when the file selection in a panel changes) to:
<pre>    spacefm -s set statusbar_text "$fm_filename"</pre>

<p>Any command line set in the Event Manager menu which is prefixed with an asterisk (*) as the first character, will be run synchronously, as if it was added with the <a href="#sockets-methods-replace-event">replace-event</a> method.  (The asterisk is removed before the command is run.)  This means the GUI will freeze while SpaceFM waits for the command to exit.  For <a href="#sockets-events-winclk">evt_win_click</a>, <a href="#sockets-events-winkey">evt_win_key</a>, and <a href="#sockets-events-pnlsel">evt_pnl_sel</a> event types, a zero exit status will also inhibit the built-in handler.

<p>In addition to setting commands in the Event Manager menu, you can also add event handler commands dynamically using the <a href="#sockets-methods-add-event">add-event</a> or <a href="#sockets-methods-replace-event">replace-event</a> socket command methods.  






<!-- @Program Files @/home -->

<p>Your entire SpaceFM configuration, including settings and custom menu items, is stored in the config directory: <b>~/.config/spacefm/</b> (unless you use <code>--config-dir</code> on the <a href="#invocation-commandline">command line</a> to specify another location).

<p>If the config directory doesn't exist, and <a href="#programfiles-etc-xdg">/etc/xdg/spacefm/</a> does exist, the contents of /etc/xdg/spacefm/ will be copied to the new config directory on startup.

<p><b>Files in ~/.config/spacefm/ include:</b>

<!-- # session -->
Holds most user settings and customisations.  This file is plain text so you can review its contents, but <b>it should NOT be edited</b>.  SpaceFM saves the current session anytime you make a change to the configuration (at most once every 15 seconds or so).  If SpaceFM can't find a session file at startup, it will use session-last or session-prior instead.  If all session, session-last, and session-prior files are deleted, SpaceFM will be restored to factory default settings.

<!-- # session-last &amp; session-prior #last -->
These are the session files from your last and prior-to-last runs of SpaceFM.  If you encounter a configuration problem or loss of settings when starting or using SpaceFM, be sure to make a backup copy of these files before running SpaceFM again.  To revert to an older session, stop all instances of SpaceFM and rename the older session file 'session'.

<!-- # session.tmp #tmp -->
For stability, when SpaceFM saves your session file, it first saves it as 'session.tmp'.  If successful, it then renames it 'session', overwriting the old session file.  Usually you won't find a session.tmp file because it is quickly written and renamed.

<!-- # bookmarks -->
As of version 1.0.1, this file is no longer used or updated by SpaceFM, but it may remain if you used earlier versions.  When upgrading to version 1.0.1 or later from an earlier version, this file is automatically imported into the new Bookmarks menu.

<!-- # plugin-data/ -->
Contains the <a href="#designmode-command-browse-data">data directories</a> for custom commands and plugins, if any.  If commands need to store persistent user data, this is where they store it.  It is should generally be safe to remove files from this folder, but your commands may lose their settings.

<!-- # scripts/ -->
Contains the <a href="#designmode-command-browse-files">command directories</a> for custom commands you have added to SpaceFM's menus or toolbars, if any.

<p>Because SpaceFM is highly configurable, you may have much time and effort invested in your SpaceFM config folder, so it's a good idea to <b>keep an up-to-date backup!</b>

<!-- # scripts/default-script #defscript -->
This file, <i>if you create it</i>, is used as your default <a href="#designmode-command-script">command script</a> rather than the <a href="#exvar">automatically generated one</a>.  When you create a new custom command as a Script, ~/.config/spacefm/scripts/default-script will be copied to the <a href="#designmode-command-browse-files">command directory</a> as exec.sh.

<p><b>Other locations in your home folder used by SpaceFM include:</b>

<!-- # ~/.local/share/applications/ #localapps -->
This folder contains desktop files which define applications available on your system, and the defaults.list file specifies default applications for given MIME types.  SpaceFM checks this directory to determine what application to use to open files, will modify the <a href="#mimeappslist">mimeapps.list</a> file when you change the default application for a MIME type, and may create custom desktop files when needed.  The system-wide <a href="#programfiles-usr-usrapps">/usr/share/applications/</a> folder is used similarly, though settings in the local folder take precedence.  You can copy desktop files from /usr/share/applications/ to ~/.local/share/applications/ in order to modify them on a per-user basis, and also add your own custom desktop files.

<!-- # ~/.templates/ #tmpl -->
The ~/.templates/ folder (or $XDG_TEMPLATES_DIR/ or ~/Templates/) holds file and folder templates for use in the <a href="#gui-newf">New File/Folder Dialog</a>.


<!-- @Program Files @/etc -->

<p>The first time you click OK in the View|Preferences dialog, and anytime you change your terminal or root editor in that dialog, SpaceFM will ask to save some settings as root to /etc/spacefm/ &nbsp;Although optional, this is recommended to help secure your use of SpaceFM's perform-as-root commands.  Also, anytime you run a perform-as-root command, such as to <a href="#devices-root-format">format a partition</a>, these settings may be updated.  Without these settings saved as root, your system security may be more easily compromised.

<p>The following files may be found in /etc/spacefm:

<!-- # USERNAME-as-root #as-root -->
For each USERNAME who runs SpaceFM, you may find this file which contains the user's prefered root editor, terminal, and other perform-as-root settings.  This file should NOT be edited.

<!-- # spacefm.conf #conf -->
This file is designed to be edited by the administrative user.  Currently, the only setting in this file is tmp_dir, which specifies what <a href="#programfiles-tmp">temporary directory</a> SpaceFM should use.  If unset, it defaults to /tmp.  If this file is not present and you want to specify a different temporary directory (/dev/shm in this example), create the file /etc/spacefm.conf as root and add this line:
<blockquote>tmp_dir=/dev/shm</blockquote>

Be sure to use a temporary directory which is root-owned/protected and user-writable (see /tmp's permissions).  /dev/shm is usually a good choice too.  The temporary directory <b>may not contain spaces or other special characters</b> - keep it simple.  Because SpaceFM may run commands as other users (including root), the temporary directory must be accessible to all users.

<!-- # /etc/xdg/spacefm/ #xdg -->
This folder, if it exists, is used to copy a default configuration for new SpaceFM users.  If no <a href="#programfiles-home">config directory</a> (eg ~/.config/spacefm) exists for the current user when SpaceFM is first started, the contents of /etc/xdg/spacefm/ will be copied to the new config directory (be sure to kill all running instances of spacefm before testing this).  This allows a distro or system admin to set a default SpaceFM configuration for new users.  To do so, simply configure SpaceFM as you want it to appear and work by default, then copy the contents of the config directory to /etc/xdg/spacefm/ as root.  Be sure to set all files in /etc/xdg/spacefm/ to be readable by all users:
<pre>
    sudo cp -r /home/USER/.config/spacefm /etc/xdg/spacefm
    sudo chmod -R ugo+rX /etc/xdg/spacefm</pre>

To test, start SpaceFM with a test config directory which doesn't exist:
<pre>    
    killall spacefm
    rm -rf /tmp/spacefm-test-config
    spacefm --config-dir /tmp/spacefm-test-config</pre>

<p>If you want to install plugins by default, install them uncompressed to /usr/share/spacefm/plugins/, just as SpaceFM does when you select Plugins|Install. In the user's configuration, plugins can be copied to other menus as well.  Or you can simply import plugins into the user's menus before copying the config dir to /etc/xdg/spacefm.


<!-- @Program Files @/tmp -->

<p>SpaceFM writes small files to the temporary directory (which can be changed in <a href="#programfiles-etc-conf">spacefm.conf</a>).  These include:

<!-- # .spacefm-socketDISPLAY-USERNAME #socket -->
A socket which SpaceFM uses to <a href="#invocation-windows">open additional windows</a> and other functions (including <a href="#sockets">socket commands</a>), removing the need to start additional instances of the entire program.  DISPLAY is the current display of the user (eg :0) and USERNAME the username.  Generally, this file will be removed when the current instance of SpaceFM exits.

<!-- # spacefm.tmp/ #shrtmp -->
This folder, shared by all users, contains temporary files used for running a command as another user, including root.  Once a root command is run, this folder will be owned by root.

<!-- # spacefm-USERNAME-RANDOM.tmp/ #pidtmp -->
This folder contains temporary files used by USERNAME running SpaceFM.  It is owned by the user and will be deleted on exit.  Other users can access this folder, but usually not the files within it, unless a command is being run as another user.

<!-- # spacefm*.tmp/ID-tmp.sh #exec -->
A temporary bash script used to execute a command run in SpaceFM, which will be deleted when the command completes.  ID will be an eight digit hexadecimal number.  This script creates a suitable bash environment for the command being run, including import of file manager variables for use in commands.  While the command is running, you can import the file manager variables from this script into another script using:
<pre>    $fm_import
    # OR
    source <i>ID</i>-tmp.sh</pre>

<!-- # spacefm*.tmp/ID/ #dattmp-->
A folder used to store temporary data, usually plugin data which has been copied via <a href="#plugins-import">Plugins|Import</a> or <a href="#designmode-designmenu-import">New|Import</a>, where ID is an eight digit hexadecimal number.


<!-- @Program Files @/usr -->

<p>The parent folder (--prefix=) for files listed below may be '/usr' or '/usr/local' depending on how you installed SpaceFM.  With the exception of plugins installed by the user, all files stored in /usr are created only when SpaceFM is installed, and are not changed by SpaceFM.  These include:

<!-- # bin/spacefm #bin-spacefm -->
The SpaceFM executable file.

<!-- # bin/spacefm-auth #bin-spacefm-auth -->
This script is used internally by spacefm to authenticate temporary scripts run as another user (using /usr/bin/sha256sum).  This file should not be modified or run directly.  This file was added to SpaceFM version 0.7.2 to simplify the command line for su programs, which often handle special characters poorly and have inconsistent command line usage.  If spacefm-auth or /usr/bin/sha256sum are missing, SpaceFM will operate in a less secure mode.

<!-- # share/doc/spacefm/spacefm-manual-en.html #manual -->
A local copy of this manual you're reading (also may be in share/spacefm/, or in your distro's standard html docs folder).  This copy is accessed when using context-sensitive help within SpaceFM.  If available, a version for your language will automatically be used.  To use a different manual location within SpaceFM, set your preference in Help|Options|Manual Location.

<!-- # share/spacefm/plugins/ #plugins -->
A folder containing <a href="#plugins">plugins</a> installed by the user.  Plugin files should NOT be copied directly to this folder.  Instead, use <a href="#plugins-install">Plugins|Install</a> to install them, or <a href="#designmode-designmenu-remove">Design Mode</a> to remove them.  However, if you make a package for your plugin, you can instruct the package manager to install the correct uncompressed files to this folder, allowing users to install your plugin via their package manager.

<!-- # share/spacefm/included/ #included -->
Plugins included in a standard SpaceFM installation.  This folder should NOT be modified.

<!-- # share/spacefm/ui/ #ui -->
A folder containing glade files for some of SpaceFM's dialogs.

<!-- # share/icons/hicolor/48x48/apps/spacefm.png &amp; spacefm-root.png #png -->
The 48 pixel window icons for the non-root and root user of SpaceFM.  Use of these icons can be avoided by changing View|Window Icon.  See also icons in share/icons/hicolor/128x128/apps/ and share/icons/Faenza/apps/48/, as well as the alternate icons named "spacefm-<i>[48|128]</i>-<i>[cube|pyramid|folder]</i>-<i>[blue|green|red]</i>.png".

<p>Note:  If configure option --enable-pixmaps is used during build, icons will be installed to share/pixmaps/ instead.

<!-- # share/locale/*/LC_MESSAGES/spacefm.mo #mo -->
Language files used by SpaceFM, where '*' is a locale.

<!-- # share/applications/ #usrapps -->
This folder contains desktop files which define applications available on your system, and the defaults.list file specifies default applications for given MIME types.  SpaceFM checks both <a href="#programfiles-home-localapps">~/.local/share/applications/</a> and /usr/share/applications/ to determine what application to use to open files.  Settings in the local folder take precedence.  You can copy desktop files from /usr/share/applications/ to ~/.local/share/applications/ in order to modify them on a per-user basis, and also add your own custom desktop files.

<!-- # share/applications/spacefm.desktop #spac-dt -->
A desktop file which opens a SpaceFM <a href="#invocation-windows">window</a>.

<!-- # share/applications/spacefm-find.desktop #find-dt -->
A desktop file which open a SpaceFM File Search window.

<!-- # share/applications/spacefm-folder-handler.desktop #fold-dt -->
A desktop file which uses SpaceFM to open a folder

<!-- # share/mime/packages/spacefm-mime.xml #mime -->
Additional MIME types provided by libmimetype, adding globs for some missing but frequently seen file types.





<!-- @tail -->

</table>
<br>
<center>

<p>Copyright (C) @@@year@@@

<p>DISCLAIMER:  While the authors, copyright holders, and maintainers of this software endeavour to keep all content up to date and valuable, we make no representations or warranties of any kind, express or implied, about the completeness, accuracy, reliability, suitability or availability with respect to the software or the information, communications, products, services, or related graphics for any purpose. Any reliance you place on such content is therefore strictly AT YOUR OWN RISK.<br>
<br>
<p>@@@version@@@
<br><br>
</center>
</td></tr></table>
</body></head></html>
